
build/ch_icmu.elf:     file format elf32-littlearm


Disassembly of section .vectors:

08000000 <_vectors>:
 8000000:	20000400 	.word	0x20000400
 8000004:	080002c9 	.word	0x080002c9
 8000008:	080002cb 	.word	0x080002cb
 800000c:	080002cb 	.word	0x080002cb
 8000010:	080002cb 	.word	0x080002cb
 8000014:	080002cb 	.word	0x080002cb
 8000018:	080002cb 	.word	0x080002cb
 800001c:	080002cb 	.word	0x080002cb
 8000020:	080002cb 	.word	0x080002cb
 8000024:	080002cb 	.word	0x080002cb
 8000028:	080002cb 	.word	0x080002cb
 800002c:	080083f1 	.word	0x080083f1
 8000030:	080002cb 	.word	0x080002cb
 8000034:	080002cb 	.word	0x080002cb
 8000038:	080002cb 	.word	0x080002cb
 800003c:	080002cb 	.word	0x080002cb
 8000040:	080002cb 	.word	0x080002cb
 8000044:	080002cb 	.word	0x080002cb
 8000048:	080002cb 	.word	0x080002cb
 800004c:	080002cb 	.word	0x080002cb
 8000050:	080002cb 	.word	0x080002cb
 8000054:	080002cb 	.word	0x080002cb
 8000058:	080002cb 	.word	0x080002cb
 800005c:	080002cb 	.word	0x080002cb
 8000060:	080002cb 	.word	0x080002cb
 8000064:	080002cb 	.word	0x080002cb
 8000068:	080002cb 	.word	0x080002cb
 800006c:	08003aa1 	.word	0x08003aa1
 8000070:	08003b01 	.word	0x08003b01
 8000074:	08003b61 	.word	0x08003b61
 8000078:	08003bc1 	.word	0x08003bc1
 800007c:	08003c21 	.word	0x08003c21
 8000080:	08003c81 	.word	0x08003c81
 8000084:	08003ce1 	.word	0x08003ce1
 8000088:	080002cb 	.word	0x080002cb
 800008c:	080002cb 	.word	0x080002cb
 8000090:	080002cb 	.word	0x080002cb
 8000094:	080002cb 	.word	0x080002cb
 8000098:	080002cb 	.word	0x080002cb
 800009c:	080002cb 	.word	0x080002cb
 80000a0:	080002cb 	.word	0x080002cb
 80000a4:	080059b1 	.word	0x080059b1
 80000a8:	080002cb 	.word	0x080002cb
 80000ac:	080059e1 	.word	0x080059e1
 80000b0:	080058e1 	.word	0x080058e1
 80000b4:	080002cb 	.word	0x080002cb
 80000b8:	080002cb 	.word	0x080002cb
 80000bc:	080002cb 	.word	0x080002cb
 80000c0:	080002cb 	.word	0x080002cb
 80000c4:	080002cb 	.word	0x080002cb
 80000c8:	080002cb 	.word	0x080002cb
 80000cc:	080002cb 	.word	0x080002cb
 80000d0:	080002cb 	.word	0x080002cb
 80000d4:	080002cb 	.word	0x080002cb
 80000d8:	08005da1 	.word	0x08005da1
 80000dc:	080002cb 	.word	0x080002cb
 80000e0:	080002cb 	.word	0x080002cb
 80000e4:	080002cb 	.word	0x080002cb
 80000e8:	080002cb 	.word	0x080002cb
 80000ec:	080002cb 	.word	0x080002cb
 80000f0:	080002cb 	.word	0x080002cb
 80000f4:	080002cb 	.word	0x080002cb
 80000f8:	080002cb 	.word	0x080002cb
 80000fc:	08003d41 	.word	0x08003d41
 8000100:	080002cb 	.word	0x080002cb
 8000104:	080002cb 	.word	0x080002cb
 8000108:	080002cb 	.word	0x080002cb
 800010c:	080002cb 	.word	0x080002cb
 8000110:	080002cb 	.word	0x080002cb
 8000114:	080002cb 	.word	0x080002cb
 8000118:	080002cb 	.word	0x080002cb
 800011c:	080002cb 	.word	0x080002cb
 8000120:	08003da1 	.word	0x08003da1
 8000124:	08003e01 	.word	0x08003e01
 8000128:	08003e61 	.word	0x08003e61
 800012c:	08003ec1 	.word	0x08003ec1
 8000130:	08003f21 	.word	0x08003f21
 8000134:	080002cb 	.word	0x080002cb
 8000138:	080002cb 	.word	0x080002cb
 800013c:	080002cb 	.word	0x080002cb
 8000140:	080002cb 	.word	0x080002cb
 8000144:	080002cb 	.word	0x080002cb
 8000148:	080002cb 	.word	0x080002cb
 800014c:	08004de1 	.word	0x08004de1
 8000150:	08003f81 	.word	0x08003f81
 8000154:	08003fe1 	.word	0x08003fe1
 8000158:	08004041 	.word	0x08004041
 800015c:	080002cb 	.word	0x080002cb
 8000160:	080002cb 	.word	0x080002cb
 8000164:	080002cb 	.word	0x080002cb
 8000168:	080002cb 	.word	0x080002cb
 800016c:	080002cb 	.word	0x080002cb
 8000170:	080002cb 	.word	0x080002cb
 8000174:	08004e11 	.word	0x08004e11
 8000178:	080002cb 	.word	0x080002cb
 800017c:	080002cb 	.word	0x080002cb
 8000180:	080002cb 	.word	0x080002cb
 8000184:	080002cb 	.word	0x080002cb
 8000188:	080002cb 	.word	0x080002cb
 800018c:	080002cb 	.word	0x080002cb
 8000190:	080002cb 	.word	0x080002cb
 8000194:	080002cb 	.word	0x080002cb
 8000198:	080002cb 	.word	0x080002cb
 800019c:	080002cb 	.word	0x080002cb
 80001a0:	080002cb 	.word	0x080002cb
 80001a4:	080002cb 	.word	0x080002cb
 80001a8:	080002cb 	.word	0x080002cb
 80001ac:	080002cb 	.word	0x080002cb
 80001b0:	080002cb 	.word	0x080002cb
 80001b4:	080002cb 	.word	0x080002cb
 80001b8:	080002cb 	.word	0x080002cb
 80001bc:	080002cb 	.word	0x080002cb
 80001c0:	080002cb 	.word	0x080002cb
 80001c4:	080002cb 	.word	0x080002cb
 80001c8:	080002cb 	.word	0x080002cb
 80001cc:	080002cb 	.word	0x080002cb
 80001d0:	080002cb 	.word	0x080002cb
 80001d4:	080002cb 	.word	0x080002cb
 80001d8:	080002cb 	.word	0x080002cb
 80001dc:	080002cb 	.word	0x080002cb

Disassembly of section .text:

080001f0 <_crt0_entry>:
                .align  2
                .thumb_func
                .global _crt0_entry
_crt0_entry:
                /* Interrupts are globally masked initially.*/
                cpsid   i
 80001f0:	b672      	cpsid	i

#if CRT0_FORCE_MSP_INIT == TRUE
                /* MSP stack pointers initialization.*/
                ldr     r0, =__main_stack_end__
 80001f2:	4827      	ldr	r0, [pc, #156]	; (8000290 <endfiniloop+0x4>)
                msr     MSP, r0
 80001f4:	f380 8808 	msr	MSP, r0
#endif

                /* PSP stack pointers initialization.*/
                ldr     r0, =__process_stack_end__
 80001f8:	4826      	ldr	r0, [pc, #152]	; (8000294 <endfiniloop+0x8>)
                msr     PSP, r0
 80001fa:	f380 8809 	msr	PSP, r0

#if CRT0_VTOR_INIT == TRUE
                ldr     r0, =_vectors
 80001fe:	4826      	ldr	r0, [pc, #152]	; (8000298 <endfiniloop+0xc>)
                movw    r1, #SCB_VTOR & 0xFFFF
 8000200:	f64e 5108 	movw	r1, #60680	; 0xed08
                movt    r1, #SCB_VTOR >> 16
 8000204:	f2ce 0100 	movt	r1, #57344	; 0xe000
                str     r0, [r1]
 8000208:	6008      	str	r0, [r1, #0]

                /* Enforcing FPCA bit in the CONTROL register.*/
                movs    r0, #CRT0_CONTROL_INIT | CONTROL_FPCA

#else
                movs    r0, #CRT0_CONTROL_INIT
 800020a:	2002      	movs	r0, #2
#endif

                /* CONTROL register initialization as configured.*/
                msr     CONTROL, r0
 800020c:	f380 8814 	msr	CONTROL, r0
                isb
 8000210:	f3bf 8f6f 	isb	sy

#if CRT0_INIT_CORE == TRUE
                /* Core initialization.*/
                bl      __core_init
 8000214:	f000 fd7c 	bl	8000d10 <__core_init>
#endif

                /* Early initialization.*/
                bl      __early_init
 8000218:	f005 fe82 	bl	8005f20 <__early_init>

#if CRT0_INIT_STACKS == TRUE
                ldr     r0, =CRT0_STACKS_FILL_PATTERN
 800021c:	f04f 3055 	mov.w	r0, #1431655765	; 0x55555555
                /* Main Stack initialization. Note, it assumes that the
                   stack size is a multiple of 4 so the linker file must
                   ensure this.*/
                ldr     r1, =__main_stack_base__
 8000220:	491e      	ldr	r1, [pc, #120]	; (800029c <endfiniloop+0x10>)
                ldr     r2, =__main_stack_end__
 8000222:	4a1b      	ldr	r2, [pc, #108]	; (8000290 <endfiniloop+0x4>)

08000224 <msloop>:
msloop:
                cmp     r1, r2
 8000224:	4291      	cmp	r1, r2
                itt     lo
 8000226:	bf3c      	itt	cc
                strlo   r0, [r1], #4
 8000228:	f841 0b04 	strcc.w	r0, [r1], #4
                blo     msloop
 800022c:	e7fa      	bcc.n	8000224 <msloop>

                /* Process Stack initialization. Note, it assumes that the
                   stack size is a multiple of 4 so the linker file must
                   ensure this.*/
                ldr     r1, =__process_stack_base__
 800022e:	491c      	ldr	r1, [pc, #112]	; (80002a0 <endfiniloop+0x14>)
                ldr     r2, =__process_stack_end__
 8000230:	4a18      	ldr	r2, [pc, #96]	; (8000294 <endfiniloop+0x8>)

08000232 <psloop>:
psloop:
                cmp     r1, r2
 8000232:	4291      	cmp	r1, r2
                itt     lo
 8000234:	bf3c      	itt	cc
                strlo   r0, [r1], #4
 8000236:	f841 0b04 	strcc.w	r0, [r1], #4
                blo     psloop
 800023a:	e7fa      	bcc.n	8000232 <psloop>
#endif

#if CRT0_INIT_DATA == TRUE
                /* Data initialization. Note, it assumes that the DATA size
                  is a multiple of 4 so the linker file must ensure this.*/
                ldr     r1, =_textdata_start
 800023c:	4919      	ldr	r1, [pc, #100]	; (80002a4 <endfiniloop+0x18>)
                ldr     r2, =_data_start
 800023e:	4a1a      	ldr	r2, [pc, #104]	; (80002a8 <endfiniloop+0x1c>)
                ldr     r3, =_data_end
 8000240:	4b1a      	ldr	r3, [pc, #104]	; (80002ac <endfiniloop+0x20>)

08000242 <dloop>:
dloop:
                cmp     r2, r3
 8000242:	429a      	cmp	r2, r3
                ittt    lo
 8000244:	bf3e      	ittt	cc
                ldrlo   r0, [r1], #4
 8000246:	f851 0b04 	ldrcc.w	r0, [r1], #4
                strlo   r0, [r2], #4
 800024a:	f842 0b04 	strcc.w	r0, [r2], #4
                blo     dloop
 800024e:	e7f8      	bcc.n	8000242 <dloop>
#endif

#if CRT0_INIT_BSS == TRUE
                /* BSS initialization. Note, it assumes that the DATA size
                  is a multiple of 4 so the linker file must ensure this.*/
                movs    r0, #0
 8000250:	2000      	movs	r0, #0
                ldr     r1, =_bss_start
 8000252:	4917      	ldr	r1, [pc, #92]	; (80002b0 <endfiniloop+0x24>)
                ldr     r2, =_bss_end
 8000254:	4a17      	ldr	r2, [pc, #92]	; (80002b4 <endfiniloop+0x28>)

08000256 <bloop>:
bloop:
                cmp     r1, r2
 8000256:	4291      	cmp	r1, r2
                itt     lo
 8000258:	bf3c      	itt	cc
                strlo   r0, [r1], #4
 800025a:	f841 0b04 	strcc.w	r0, [r1], #4
                blo     bloop
 800025e:	e7fa      	bcc.n	8000256 <bloop>
#endif

#if CRT0_INIT_RAM_AREAS == TRUE
                /* RAM areas initialization.*/
                bl      __init_ram_areas
 8000260:	f000 fd6e 	bl	8000d40 <__init_ram_areas>
#endif

                /* Late initialization..*/
                bl      __late_init
 8000264:	f000 fd5c 	bl	8000d20 <__late_init>

#if CRT0_CALL_CONSTRUCTORS == TRUE
                /* Constructors invocation.*/
                ldr     r4, =__init_array_start
 8000268:	4c13      	ldr	r4, [pc, #76]	; (80002b8 <endfiniloop+0x2c>)
                ldr     r5, =__init_array_end
 800026a:	4d14      	ldr	r5, [pc, #80]	; (80002bc <endfiniloop+0x30>)

0800026c <initloop>:
initloop:
                cmp     r4, r5
 800026c:	42ac      	cmp	r4, r5
                bge     endinitloop
 800026e:	da03      	bge.n	8000278 <endinitloop>
                ldr     r1, [r4], #4
 8000270:	f854 1b04 	ldr.w	r1, [r4], #4
                blx     r1
 8000274:	4788      	blx	r1
                b       initloop
 8000276:	e7f9      	b.n	800026c <initloop>

08000278 <endinitloop>:
endinitloop:
#endif

                /* Main program invocation, r0 contains the returned value.*/
                bl      main
 8000278:	f000 fcba 	bl	8000bf0 <main>

#if CRT0_CALL_DESTRUCTORS == TRUE
                /* Destructors invocation.*/
                ldr     r4, =__fini_array_start
 800027c:	4c10      	ldr	r4, [pc, #64]	; (80002c0 <endfiniloop+0x34>)
                ldr     r5, =__fini_array_end
 800027e:	4d11      	ldr	r5, [pc, #68]	; (80002c4 <endfiniloop+0x38>)

08000280 <finiloop>:
finiloop:
                cmp     r4, r5
 8000280:	42ac      	cmp	r4, r5
                bge     endfiniloop
 8000282:	da03      	bge.n	800028c <endfiniloop>
                ldr     r1, [r4], #4
 8000284:	f854 1b04 	ldr.w	r1, [r4], #4
                blx     r1
 8000288:	4788      	blx	r1
                b       finiloop
 800028a:	e7f9      	b.n	8000280 <finiloop>

0800028c <endfiniloop>:
endfiniloop:
#endif

                /* Branching to the defined exit handler.*/
                b       __default_exit
 800028c:	f000 bd50 	b.w	8000d30 <__default_exit>
                ldr     r0, =__main_stack_end__
 8000290:	20000400 	.word	0x20000400
                ldr     r0, =__process_stack_end__
 8000294:	20000800 	.word	0x20000800
                ldr     r0, =_vectors
 8000298:	08000000 	.word	0x08000000
                ldr     r1, =__main_stack_base__
 800029c:	20000000 	.word	0x20000000
                ldr     r1, =__process_stack_base__
 80002a0:	20000400 	.word	0x20000400
                ldr     r1, =_textdata_start
 80002a4:	080099e0 	.word	0x080099e0
                ldr     r2, =_data_start
 80002a8:	20000800 	.word	0x20000800
                ldr     r3, =_data_end
 80002ac:	20000808 	.word	0x20000808
                ldr     r1, =_bss_start
 80002b0:	20000808 	.word	0x20000808
                ldr     r2, =_bss_end
 80002b4:	20002560 	.word	0x20002560
                ldr     r4, =__init_array_start
 80002b8:	080001e0 	.word	0x080001e0
                ldr     r5, =__init_array_end
 80002bc:	080001e4 	.word	0x080001e4
                ldr     r4, =__fini_array_start
 80002c0:	080001e4 	.word	0x080001e4
                ldr     r5, =__fini_array_end
 80002c4:	080001e4 	.word	0x080001e4

080002c8 <Reset_Handler>:

        .align      2
        .thumb_func
        .weak       Reset_Handler
Reset_Handler:
         b          _crt0_entry
 80002c8:	e792      	b.n	80001f0 <_crt0_entry>

080002ca <BusFault_Handler>:
        .thumb_func
Vector3F8:
        .thumb_func
Vector3FC:
#endif
        bl          _unhandled_exception
 80002ca:	f000 f800 	bl	80002ce <_unhandled_exception>

080002ce <_unhandled_exception>:

        .thumb_func
        .weak       _unhandled_exception
_unhandled_exception:
.stay:
        b           .stay
 80002ce:	e7fe      	b.n	80002ce <_unhandled_exception>

080002d0 <_port_switch>:
 * Performs a context switch between two threads.
 *--------------------------------------------------------------------------*/
                .thumb_func
                .globl  _port_switch
_port_switch:
                push    {r4, r5, r6, r7, r8, r9, r10, r11, lr}
 80002d0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
#if CORTEX_USE_FPU
                vpush   {s16-s31}
#endif

                str     sp, [r1, #CONTEXT_OFFSET]
 80002d4:	f8c1 d00c 	str.w	sp, [r1, #12]
#if (CORTEX_SIMPLIFIED_PRIORITY == FALSE) &&                                \
    ((CORTEX_MODEL == 3) || (CORTEX_MODEL == 4))
                /* Workaround for ARM errata 752419, only applied if
                   condition exists for it to be triggered.*/
                ldr     r3, [r0, #CONTEXT_OFFSET]
 80002d8:	68c3      	ldr	r3, [r0, #12]
                mov     sp, r3
 80002da:	469d      	mov	sp, r3
#endif

#if CORTEX_USE_FPU
                vpop    {s16-s31}
#endif
                pop     {r4, r5, r6, r7, r8, r9, r10, r11, pc}
 80002dc:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

080002e0 <_port_thread_start>:
 *--------------------------------------------------------------------------*/
                .thumb_func
                .globl  _port_thread_start
_port_thread_start:
#if CH_DBG_SYSTEM_STATE_CHECK
                bl      _dbg_check_unlock
 80002e0:	f006 f8be 	bl	8006460 <_dbg_check_unlock>
                bl      _stats_stop_measure_crit_thd
#endif
#if CORTEX_SIMPLIFIED_PRIORITY
                cpsie   i
#else
                movs    r3, #0              /* CORTEX_BASEPRI_DISABLED */
 80002e4:	2300      	movs	r3, #0
                msr     BASEPRI, r3
 80002e6:	f383 8811 	msr	BASEPRI, r3
#endif
                mov     r0, r5
 80002ea:	4628      	mov	r0, r5
                blx     r4
 80002ec:	47a0      	blx	r4
#if defined(_CHIBIOS_RT_CONF_)
                movs    r0, #0              /* MSG_OK */
 80002ee:	2000      	movs	r0, #0
                bl      chThdExit
 80002f0:	f007 f9c6 	bl	8007680 <chThdExit>

080002f4 <_port_switch_from_isr>:
_port_switch_from_isr:
#if CH_DBG_STATISTICS
                bl      _stats_start_measure_crit_thd
#endif
#if CH_DBG_SYSTEM_STATE_CHECK
                bl      _dbg_check_lock
 80002f4:	f006 f89c 	bl	8006430 <_dbg_check_lock>
#endif
                bl      chSchDoReschedule
 80002f8:	f006 fef2 	bl	80070e0 <chSchDoReschedule>
#if CH_DBG_SYSTEM_STATE_CHECK
                bl      _dbg_check_unlock
 80002fc:	f006 f8b0 	bl	8006460 <_dbg_check_unlock>

08000300 <_port_exit_from_isr>:
                movt    r3, #:upper16:SCB_ICSR
                mov     r2, ICSR_PENDSVSET
                str     r2, [r3, #0]
                cpsie   i
#else /* !CORTEX_SIMPLIFIED_PRIORITY */
                svc     #0
 8000300:	df00      	svc	0
#endif /* !CORTEX_SIMPLIFIED_PRIORITY */
.L1:            b       .L1
 8000302:	e7fe      	b.n	8000302 <_port_exit_from_isr+0x2>

08000304 <memcpy>:
 8000304:	4684      	mov	ip, r0
 8000306:	ea41 0300 	orr.w	r3, r1, r0
 800030a:	f013 0303 	ands.w	r3, r3, #3
 800030e:	d16d      	bne.n	80003ec <memcpy+0xe8>
 8000310:	3a40      	subs	r2, #64	; 0x40
 8000312:	d341      	bcc.n	8000398 <memcpy+0x94>
 8000314:	f851 3b04 	ldr.w	r3, [r1], #4
 8000318:	f840 3b04 	str.w	r3, [r0], #4
 800031c:	f851 3b04 	ldr.w	r3, [r1], #4
 8000320:	f840 3b04 	str.w	r3, [r0], #4
 8000324:	f851 3b04 	ldr.w	r3, [r1], #4
 8000328:	f840 3b04 	str.w	r3, [r0], #4
 800032c:	f851 3b04 	ldr.w	r3, [r1], #4
 8000330:	f840 3b04 	str.w	r3, [r0], #4
 8000334:	f851 3b04 	ldr.w	r3, [r1], #4
 8000338:	f840 3b04 	str.w	r3, [r0], #4
 800033c:	f851 3b04 	ldr.w	r3, [r1], #4
 8000340:	f840 3b04 	str.w	r3, [r0], #4
 8000344:	f851 3b04 	ldr.w	r3, [r1], #4
 8000348:	f840 3b04 	str.w	r3, [r0], #4
 800034c:	f851 3b04 	ldr.w	r3, [r1], #4
 8000350:	f840 3b04 	str.w	r3, [r0], #4
 8000354:	f851 3b04 	ldr.w	r3, [r1], #4
 8000358:	f840 3b04 	str.w	r3, [r0], #4
 800035c:	f851 3b04 	ldr.w	r3, [r1], #4
 8000360:	f840 3b04 	str.w	r3, [r0], #4
 8000364:	f851 3b04 	ldr.w	r3, [r1], #4
 8000368:	f840 3b04 	str.w	r3, [r0], #4
 800036c:	f851 3b04 	ldr.w	r3, [r1], #4
 8000370:	f840 3b04 	str.w	r3, [r0], #4
 8000374:	f851 3b04 	ldr.w	r3, [r1], #4
 8000378:	f840 3b04 	str.w	r3, [r0], #4
 800037c:	f851 3b04 	ldr.w	r3, [r1], #4
 8000380:	f840 3b04 	str.w	r3, [r0], #4
 8000384:	f851 3b04 	ldr.w	r3, [r1], #4
 8000388:	f840 3b04 	str.w	r3, [r0], #4
 800038c:	f851 3b04 	ldr.w	r3, [r1], #4
 8000390:	f840 3b04 	str.w	r3, [r0], #4
 8000394:	3a40      	subs	r2, #64	; 0x40
 8000396:	d2bd      	bcs.n	8000314 <memcpy+0x10>
 8000398:	3230      	adds	r2, #48	; 0x30
 800039a:	d311      	bcc.n	80003c0 <memcpy+0xbc>
 800039c:	f851 3b04 	ldr.w	r3, [r1], #4
 80003a0:	f840 3b04 	str.w	r3, [r0], #4
 80003a4:	f851 3b04 	ldr.w	r3, [r1], #4
 80003a8:	f840 3b04 	str.w	r3, [r0], #4
 80003ac:	f851 3b04 	ldr.w	r3, [r1], #4
 80003b0:	f840 3b04 	str.w	r3, [r0], #4
 80003b4:	f851 3b04 	ldr.w	r3, [r1], #4
 80003b8:	f840 3b04 	str.w	r3, [r0], #4
 80003bc:	3a10      	subs	r2, #16
 80003be:	d2ed      	bcs.n	800039c <memcpy+0x98>
 80003c0:	320c      	adds	r2, #12
 80003c2:	d305      	bcc.n	80003d0 <memcpy+0xcc>
 80003c4:	f851 3b04 	ldr.w	r3, [r1], #4
 80003c8:	f840 3b04 	str.w	r3, [r0], #4
 80003cc:	3a04      	subs	r2, #4
 80003ce:	d2f9      	bcs.n	80003c4 <memcpy+0xc0>
 80003d0:	3204      	adds	r2, #4
 80003d2:	d008      	beq.n	80003e6 <memcpy+0xe2>
 80003d4:	07d2      	lsls	r2, r2, #31
 80003d6:	bf1c      	itt	ne
 80003d8:	f811 3b01 	ldrbne.w	r3, [r1], #1
 80003dc:	f800 3b01 	strbne.w	r3, [r0], #1
 80003e0:	d301      	bcc.n	80003e6 <memcpy+0xe2>
 80003e2:	880b      	ldrh	r3, [r1, #0]
 80003e4:	8003      	strh	r3, [r0, #0]
 80003e6:	4660      	mov	r0, ip
 80003e8:	4770      	bx	lr
 80003ea:	bf00      	nop
 80003ec:	2a08      	cmp	r2, #8
 80003ee:	d313      	bcc.n	8000418 <memcpy+0x114>
 80003f0:	078b      	lsls	r3, r1, #30
 80003f2:	d08d      	beq.n	8000310 <memcpy+0xc>
 80003f4:	f010 0303 	ands.w	r3, r0, #3
 80003f8:	d08a      	beq.n	8000310 <memcpy+0xc>
 80003fa:	f1c3 0304 	rsb	r3, r3, #4
 80003fe:	1ad2      	subs	r2, r2, r3
 8000400:	07db      	lsls	r3, r3, #31
 8000402:	bf1c      	itt	ne
 8000404:	f811 3b01 	ldrbne.w	r3, [r1], #1
 8000408:	f800 3b01 	strbne.w	r3, [r0], #1
 800040c:	d380      	bcc.n	8000310 <memcpy+0xc>
 800040e:	f831 3b02 	ldrh.w	r3, [r1], #2
 8000412:	f820 3b02 	strh.w	r3, [r0], #2
 8000416:	e77b      	b.n	8000310 <memcpy+0xc>
 8000418:	3a04      	subs	r2, #4
 800041a:	d3d9      	bcc.n	80003d0 <memcpy+0xcc>
 800041c:	3a01      	subs	r2, #1
 800041e:	f811 3b01 	ldrb.w	r3, [r1], #1
 8000422:	f800 3b01 	strb.w	r3, [r0], #1
 8000426:	d2f9      	bcs.n	800041c <memcpy+0x118>
 8000428:	780b      	ldrb	r3, [r1, #0]
 800042a:	7003      	strb	r3, [r0, #0]
 800042c:	784b      	ldrb	r3, [r1, #1]
 800042e:	7043      	strb	r3, [r0, #1]
 8000430:	788b      	ldrb	r3, [r1, #2]
 8000432:	7083      	strb	r3, [r0, #2]
 8000434:	4660      	mov	r0, ip
 8000436:	4770      	bx	lr

08000438 <__aeabi_uldivmod>:
 8000438:	b953      	cbnz	r3, 8000450 <__aeabi_uldivmod+0x18>
 800043a:	b94a      	cbnz	r2, 8000450 <__aeabi_uldivmod+0x18>
 800043c:	2900      	cmp	r1, #0
 800043e:	bf08      	it	eq
 8000440:	2800      	cmpeq	r0, #0
 8000442:	bf1c      	itt	ne
 8000444:	f04f 31ff 	movne.w	r1, #4294967295
 8000448:	f04f 30ff 	movne.w	r0, #4294967295
 800044c:	f000 b972 	b.w	8000734 <__aeabi_idiv0>
 8000450:	f1ad 0c08 	sub.w	ip, sp, #8
 8000454:	e96d ce04 	strd	ip, lr, [sp, #-16]!
 8000458:	f000 f806 	bl	8000468 <__udivmoddi4>
 800045c:	f8dd e004 	ldr.w	lr, [sp, #4]
 8000460:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 8000464:	b004      	add	sp, #16
 8000466:	4770      	bx	lr

08000468 <__udivmoddi4>:
 8000468:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 800046c:	9e08      	ldr	r6, [sp, #32]
 800046e:	4604      	mov	r4, r0
 8000470:	4688      	mov	r8, r1
 8000472:	2b00      	cmp	r3, #0
 8000474:	d14b      	bne.n	800050e <__udivmoddi4+0xa6>
 8000476:	428a      	cmp	r2, r1
 8000478:	4615      	mov	r5, r2
 800047a:	d967      	bls.n	800054c <__udivmoddi4+0xe4>
 800047c:	fab2 f282 	clz	r2, r2
 8000480:	b14a      	cbz	r2, 8000496 <__udivmoddi4+0x2e>
 8000482:	f1c2 0720 	rsb	r7, r2, #32
 8000486:	fa01 f302 	lsl.w	r3, r1, r2
 800048a:	fa20 f707 	lsr.w	r7, r0, r7
 800048e:	4095      	lsls	r5, r2
 8000490:	ea47 0803 	orr.w	r8, r7, r3
 8000494:	4094      	lsls	r4, r2
 8000496:	ea4f 4e15 	mov.w	lr, r5, lsr #16
 800049a:	0c23      	lsrs	r3, r4, #16
 800049c:	fbb8 f7fe 	udiv	r7, r8, lr
 80004a0:	fa1f fc85 	uxth.w	ip, r5
 80004a4:	fb0e 8817 	mls	r8, lr, r7, r8
 80004a8:	ea43 4308 	orr.w	r3, r3, r8, lsl #16
 80004ac:	fb07 f10c 	mul.w	r1, r7, ip
 80004b0:	4299      	cmp	r1, r3
 80004b2:	d909      	bls.n	80004c8 <__udivmoddi4+0x60>
 80004b4:	18eb      	adds	r3, r5, r3
 80004b6:	f107 30ff 	add.w	r0, r7, #4294967295
 80004ba:	f080 811b 	bcs.w	80006f4 <__udivmoddi4+0x28c>
 80004be:	4299      	cmp	r1, r3
 80004c0:	f240 8118 	bls.w	80006f4 <__udivmoddi4+0x28c>
 80004c4:	3f02      	subs	r7, #2
 80004c6:	442b      	add	r3, r5
 80004c8:	1a5b      	subs	r3, r3, r1
 80004ca:	b2a4      	uxth	r4, r4
 80004cc:	fbb3 f0fe 	udiv	r0, r3, lr
 80004d0:	fb0e 3310 	mls	r3, lr, r0, r3
 80004d4:	ea44 4403 	orr.w	r4, r4, r3, lsl #16
 80004d8:	fb00 fc0c 	mul.w	ip, r0, ip
 80004dc:	45a4      	cmp	ip, r4
 80004de:	d909      	bls.n	80004f4 <__udivmoddi4+0x8c>
 80004e0:	192c      	adds	r4, r5, r4
 80004e2:	f100 33ff 	add.w	r3, r0, #4294967295
 80004e6:	f080 8107 	bcs.w	80006f8 <__udivmoddi4+0x290>
 80004ea:	45a4      	cmp	ip, r4
 80004ec:	f240 8104 	bls.w	80006f8 <__udivmoddi4+0x290>
 80004f0:	3802      	subs	r0, #2
 80004f2:	442c      	add	r4, r5
 80004f4:	ea40 4007 	orr.w	r0, r0, r7, lsl #16
 80004f8:	eba4 040c 	sub.w	r4, r4, ip
 80004fc:	2700      	movs	r7, #0
 80004fe:	b11e      	cbz	r6, 8000508 <__udivmoddi4+0xa0>
 8000500:	40d4      	lsrs	r4, r2
 8000502:	2300      	movs	r3, #0
 8000504:	e9c6 4300 	strd	r4, r3, [r6]
 8000508:	4639      	mov	r1, r7
 800050a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 800050e:	428b      	cmp	r3, r1
 8000510:	d909      	bls.n	8000526 <__udivmoddi4+0xbe>
 8000512:	2e00      	cmp	r6, #0
 8000514:	f000 80eb 	beq.w	80006ee <__udivmoddi4+0x286>
 8000518:	2700      	movs	r7, #0
 800051a:	e9c6 0100 	strd	r0, r1, [r6]
 800051e:	4638      	mov	r0, r7
 8000520:	4639      	mov	r1, r7
 8000522:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8000526:	fab3 f783 	clz	r7, r3
 800052a:	2f00      	cmp	r7, #0
 800052c:	d147      	bne.n	80005be <__udivmoddi4+0x156>
 800052e:	428b      	cmp	r3, r1
 8000530:	d302      	bcc.n	8000538 <__udivmoddi4+0xd0>
 8000532:	4282      	cmp	r2, r0
 8000534:	f200 80fa 	bhi.w	800072c <__udivmoddi4+0x2c4>
 8000538:	1a84      	subs	r4, r0, r2
 800053a:	eb61 0303 	sbc.w	r3, r1, r3
 800053e:	2001      	movs	r0, #1
 8000540:	4698      	mov	r8, r3
 8000542:	2e00      	cmp	r6, #0
 8000544:	d0e0      	beq.n	8000508 <__udivmoddi4+0xa0>
 8000546:	e9c6 4800 	strd	r4, r8, [r6]
 800054a:	e7dd      	b.n	8000508 <__udivmoddi4+0xa0>
 800054c:	b902      	cbnz	r2, 8000550 <__udivmoddi4+0xe8>
 800054e:	deff      	udf	#255	; 0xff
 8000550:	fab2 f282 	clz	r2, r2
 8000554:	2a00      	cmp	r2, #0
 8000556:	f040 808f 	bne.w	8000678 <__udivmoddi4+0x210>
 800055a:	1b49      	subs	r1, r1, r5
 800055c:	ea4f 4e15 	mov.w	lr, r5, lsr #16
 8000560:	fa1f f885 	uxth.w	r8, r5
 8000564:	2701      	movs	r7, #1
 8000566:	fbb1 fcfe 	udiv	ip, r1, lr
 800056a:	0c23      	lsrs	r3, r4, #16
 800056c:	fb0e 111c 	mls	r1, lr, ip, r1
 8000570:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
 8000574:	fb08 f10c 	mul.w	r1, r8, ip
 8000578:	4299      	cmp	r1, r3
 800057a:	d907      	bls.n	800058c <__udivmoddi4+0x124>
 800057c:	18eb      	adds	r3, r5, r3
 800057e:	f10c 30ff 	add.w	r0, ip, #4294967295
 8000582:	d202      	bcs.n	800058a <__udivmoddi4+0x122>
 8000584:	4299      	cmp	r1, r3
 8000586:	f200 80cd 	bhi.w	8000724 <__udivmoddi4+0x2bc>
 800058a:	4684      	mov	ip, r0
 800058c:	1a59      	subs	r1, r3, r1
 800058e:	b2a3      	uxth	r3, r4
 8000590:	fbb1 f0fe 	udiv	r0, r1, lr
 8000594:	fb0e 1410 	mls	r4, lr, r0, r1
 8000598:	ea43 4404 	orr.w	r4, r3, r4, lsl #16
 800059c:	fb08 f800 	mul.w	r8, r8, r0
 80005a0:	45a0      	cmp	r8, r4
 80005a2:	d907      	bls.n	80005b4 <__udivmoddi4+0x14c>
 80005a4:	192c      	adds	r4, r5, r4
 80005a6:	f100 33ff 	add.w	r3, r0, #4294967295
 80005aa:	d202      	bcs.n	80005b2 <__udivmoddi4+0x14a>
 80005ac:	45a0      	cmp	r8, r4
 80005ae:	f200 80b6 	bhi.w	800071e <__udivmoddi4+0x2b6>
 80005b2:	4618      	mov	r0, r3
 80005b4:	eba4 0408 	sub.w	r4, r4, r8
 80005b8:	ea40 400c 	orr.w	r0, r0, ip, lsl #16
 80005bc:	e79f      	b.n	80004fe <__udivmoddi4+0x96>
 80005be:	f1c7 0c20 	rsb	ip, r7, #32
 80005c2:	40bb      	lsls	r3, r7
 80005c4:	fa22 fe0c 	lsr.w	lr, r2, ip
 80005c8:	ea4e 0e03 	orr.w	lr, lr, r3
 80005cc:	fa01 f407 	lsl.w	r4, r1, r7
 80005d0:	fa20 f50c 	lsr.w	r5, r0, ip
 80005d4:	fa21 f30c 	lsr.w	r3, r1, ip
 80005d8:	ea4f 481e 	mov.w	r8, lr, lsr #16
 80005dc:	4325      	orrs	r5, r4
 80005de:	fbb3 f9f8 	udiv	r9, r3, r8
 80005e2:	0c2c      	lsrs	r4, r5, #16
 80005e4:	fb08 3319 	mls	r3, r8, r9, r3
 80005e8:	fa1f fa8e 	uxth.w	sl, lr
 80005ec:	ea44 4303 	orr.w	r3, r4, r3, lsl #16
 80005f0:	fb09 f40a 	mul.w	r4, r9, sl
 80005f4:	429c      	cmp	r4, r3
 80005f6:	fa02 f207 	lsl.w	r2, r2, r7
 80005fa:	fa00 f107 	lsl.w	r1, r0, r7
 80005fe:	d90b      	bls.n	8000618 <__udivmoddi4+0x1b0>
 8000600:	eb1e 0303 	adds.w	r3, lr, r3
 8000604:	f109 30ff 	add.w	r0, r9, #4294967295
 8000608:	f080 8087 	bcs.w	800071a <__udivmoddi4+0x2b2>
 800060c:	429c      	cmp	r4, r3
 800060e:	f240 8084 	bls.w	800071a <__udivmoddi4+0x2b2>
 8000612:	f1a9 0902 	sub.w	r9, r9, #2
 8000616:	4473      	add	r3, lr
 8000618:	1b1b      	subs	r3, r3, r4
 800061a:	b2ad      	uxth	r5, r5
 800061c:	fbb3 f0f8 	udiv	r0, r3, r8
 8000620:	fb08 3310 	mls	r3, r8, r0, r3
 8000624:	ea45 4403 	orr.w	r4, r5, r3, lsl #16
 8000628:	fb00 fa0a 	mul.w	sl, r0, sl
 800062c:	45a2      	cmp	sl, r4
 800062e:	d908      	bls.n	8000642 <__udivmoddi4+0x1da>
 8000630:	eb1e 0404 	adds.w	r4, lr, r4
 8000634:	f100 33ff 	add.w	r3, r0, #4294967295
 8000638:	d26b      	bcs.n	8000712 <__udivmoddi4+0x2aa>
 800063a:	45a2      	cmp	sl, r4
 800063c:	d969      	bls.n	8000712 <__udivmoddi4+0x2aa>
 800063e:	3802      	subs	r0, #2
 8000640:	4474      	add	r4, lr
 8000642:	ea40 4009 	orr.w	r0, r0, r9, lsl #16
 8000646:	fba0 8902 	umull	r8, r9, r0, r2
 800064a:	eba4 040a 	sub.w	r4, r4, sl
 800064e:	454c      	cmp	r4, r9
 8000650:	46c2      	mov	sl, r8
 8000652:	464b      	mov	r3, r9
 8000654:	d354      	bcc.n	8000700 <__udivmoddi4+0x298>
 8000656:	d051      	beq.n	80006fc <__udivmoddi4+0x294>
 8000658:	2e00      	cmp	r6, #0
 800065a:	d069      	beq.n	8000730 <__udivmoddi4+0x2c8>
 800065c:	ebb1 050a 	subs.w	r5, r1, sl
 8000660:	eb64 0403 	sbc.w	r4, r4, r3
 8000664:	fa04 fc0c 	lsl.w	ip, r4, ip
 8000668:	40fd      	lsrs	r5, r7
 800066a:	40fc      	lsrs	r4, r7
 800066c:	ea4c 0505 	orr.w	r5, ip, r5
 8000670:	e9c6 5400 	strd	r5, r4, [r6]
 8000674:	2700      	movs	r7, #0
 8000676:	e747      	b.n	8000508 <__udivmoddi4+0xa0>
 8000678:	f1c2 0320 	rsb	r3, r2, #32
 800067c:	fa20 f703 	lsr.w	r7, r0, r3
 8000680:	4095      	lsls	r5, r2
 8000682:	fa01 f002 	lsl.w	r0, r1, r2
 8000686:	fa21 f303 	lsr.w	r3, r1, r3
 800068a:	ea4f 4e15 	mov.w	lr, r5, lsr #16
 800068e:	4338      	orrs	r0, r7
 8000690:	0c01      	lsrs	r1, r0, #16
 8000692:	fbb3 f7fe 	udiv	r7, r3, lr
 8000696:	fa1f f885 	uxth.w	r8, r5
 800069a:	fb0e 3317 	mls	r3, lr, r7, r3
 800069e:	ea41 4103 	orr.w	r1, r1, r3, lsl #16
 80006a2:	fb07 f308 	mul.w	r3, r7, r8
 80006a6:	428b      	cmp	r3, r1
 80006a8:	fa04 f402 	lsl.w	r4, r4, r2
 80006ac:	d907      	bls.n	80006be <__udivmoddi4+0x256>
 80006ae:	1869      	adds	r1, r5, r1
 80006b0:	f107 3cff 	add.w	ip, r7, #4294967295
 80006b4:	d22f      	bcs.n	8000716 <__udivmoddi4+0x2ae>
 80006b6:	428b      	cmp	r3, r1
 80006b8:	d92d      	bls.n	8000716 <__udivmoddi4+0x2ae>
 80006ba:	3f02      	subs	r7, #2
 80006bc:	4429      	add	r1, r5
 80006be:	1acb      	subs	r3, r1, r3
 80006c0:	b281      	uxth	r1, r0
 80006c2:	fbb3 f0fe 	udiv	r0, r3, lr
 80006c6:	fb0e 3310 	mls	r3, lr, r0, r3
 80006ca:	ea41 4103 	orr.w	r1, r1, r3, lsl #16
 80006ce:	fb00 f308 	mul.w	r3, r0, r8
 80006d2:	428b      	cmp	r3, r1
 80006d4:	d907      	bls.n	80006e6 <__udivmoddi4+0x27e>
 80006d6:	1869      	adds	r1, r5, r1
 80006d8:	f100 3cff 	add.w	ip, r0, #4294967295
 80006dc:	d217      	bcs.n	800070e <__udivmoddi4+0x2a6>
 80006de:	428b      	cmp	r3, r1
 80006e0:	d915      	bls.n	800070e <__udivmoddi4+0x2a6>
 80006e2:	3802      	subs	r0, #2
 80006e4:	4429      	add	r1, r5
 80006e6:	1ac9      	subs	r1, r1, r3
 80006e8:	ea40 4707 	orr.w	r7, r0, r7, lsl #16
 80006ec:	e73b      	b.n	8000566 <__udivmoddi4+0xfe>
 80006ee:	4637      	mov	r7, r6
 80006f0:	4630      	mov	r0, r6
 80006f2:	e709      	b.n	8000508 <__udivmoddi4+0xa0>
 80006f4:	4607      	mov	r7, r0
 80006f6:	e6e7      	b.n	80004c8 <__udivmoddi4+0x60>
 80006f8:	4618      	mov	r0, r3
 80006fa:	e6fb      	b.n	80004f4 <__udivmoddi4+0x8c>
 80006fc:	4541      	cmp	r1, r8
 80006fe:	d2ab      	bcs.n	8000658 <__udivmoddi4+0x1f0>
 8000700:	ebb8 0a02 	subs.w	sl, r8, r2
 8000704:	eb69 020e 	sbc.w	r2, r9, lr
 8000708:	3801      	subs	r0, #1
 800070a:	4613      	mov	r3, r2
 800070c:	e7a4      	b.n	8000658 <__udivmoddi4+0x1f0>
 800070e:	4660      	mov	r0, ip
 8000710:	e7e9      	b.n	80006e6 <__udivmoddi4+0x27e>
 8000712:	4618      	mov	r0, r3
 8000714:	e795      	b.n	8000642 <__udivmoddi4+0x1da>
 8000716:	4667      	mov	r7, ip
 8000718:	e7d1      	b.n	80006be <__udivmoddi4+0x256>
 800071a:	4681      	mov	r9, r0
 800071c:	e77c      	b.n	8000618 <__udivmoddi4+0x1b0>
 800071e:	3802      	subs	r0, #2
 8000720:	442c      	add	r4, r5
 8000722:	e747      	b.n	80005b4 <__udivmoddi4+0x14c>
 8000724:	f1ac 0c02 	sub.w	ip, ip, #2
 8000728:	442b      	add	r3, r5
 800072a:	e72f      	b.n	800058c <__udivmoddi4+0x124>
 800072c:	4638      	mov	r0, r7
 800072e:	e708      	b.n	8000542 <__udivmoddi4+0xda>
 8000730:	4637      	mov	r7, r6
 8000732:	e6e9      	b.n	8000508 <__udivmoddi4+0xa0>

08000734 <__aeabi_idiv0>:
 8000734:	4770      	bx	lr
 8000736:	bf00      	nop
	...

08000740 <test32>:
 *      Author: Luczia
 */


void test32(int value)
{
 8000740:	b082      	sub	sp, #8
 8000742:	9001      	str	r0, [sp, #4]
  value = 4;
 8000744:	2304      	movs	r3, #4
 8000746:	9301      	str	r3, [sp, #4]
  return;
}
 8000748:	b002      	add	sp, #8
 800074a:	4770      	bx	lr
 800074c:	0000      	movs	r0, r0
	...

08000750 <port_lock>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 8000750:	b082      	sub	sp, #8
 8000752:	2320      	movs	r3, #32
 8000754:	9301      	str	r3, [sp, #4]
  \details Assigns the given value to the Base Priority register.
  \param [in]    basePri  Base Priority value to set
 */
__STATIC_FORCEINLINE void __set_BASEPRI(uint32_t basePri)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8000756:	9b01      	ldr	r3, [sp, #4]
 8000758:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800075c:	b002      	add	sp, #8
 800075e:	4770      	bx	lr

08000760 <port_unlock>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 8000760:	b082      	sub	sp, #8
 8000762:	2300      	movs	r3, #0
 8000764:	9301      	str	r3, [sp, #4]
 8000766:	9b01      	ldr	r3, [sp, #4]
 8000768:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800076c:	b002      	add	sp, #8
 800076e:	4770      	bx	lr

08000770 <port_lock_from_isr>:
 * @brief   Kernel-lock action from an interrupt handler.
 * @details In this port this function raises the base priority to kernel
 *          level.
 * @note    Same as @p port_lock() in this port.
 */
static inline void port_lock_from_isr(void) {
 8000770:	b508      	push	{r3, lr}

  port_lock();
 8000772:	f7ff ffed 	bl	8000750 <port_lock>
}
 8000776:	bd08      	pop	{r3, pc}
	...

08000780 <port_unlock_from_isr>:
 * @brief   Kernel-unlock action from an interrupt handler.
 * @details In this port this function lowers the base priority to user
 *          level.
 * @note    Same as @p port_unlock() in this port.
 */
static inline void port_unlock_from_isr(void) {
 8000780:	b508      	push	{r3, lr}

  port_unlock();
 8000782:	f7ff ffed 	bl	8000760 <port_unlock>
}
 8000786:	bd08      	pop	{r3, pc}
	...

08000790 <chSysLockFromISR>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysLockFromISR(void) {
 8000790:	b508      	push	{r3, lr}

  port_lock_from_isr();
 8000792:	f7ff ffed 	bl	8000770 <port_lock_from_isr>
  _stats_start_measure_crit_isr();
  _dbg_check_lock_from_isr();
 8000796:	f005 fe7b 	bl	8006490 <_dbg_check_lock_from_isr>
}
 800079a:	bd08      	pop	{r3, pc}
 800079c:	0000      	movs	r0, r0
	...

080007a0 <chSysUnlockFromISR>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {
 80007a0:	b508      	push	{r3, lr}

  _dbg_check_unlock_from_isr();
 80007a2:	f005 fe8d 	bl	80064c0 <_dbg_check_unlock_from_isr>
  _stats_stop_measure_crit_isr();
  port_unlock_from_isr();
 80007a6:	f7ff ffeb 	bl	8000780 <port_unlock_from_isr>
}
 80007aa:	bd08      	pop	{r3, pc}
 80007ac:	0000      	movs	r0, r0
	...

080007b0 <osalSysLockFromISR>:
 * @brief   Enters a critical zone from ISR context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysLockFromISR(void) {
 80007b0:	b508      	push	{r3, lr}

  chSysLockFromISR();
 80007b2:	f7ff ffed 	bl	8000790 <chSysLockFromISR>
}
 80007b6:	bd08      	pop	{r3, pc}
	...

080007c0 <osalSysUnlockFromISR>:
 * @brief   Leaves a critical zone from ISR context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysUnlockFromISR(void) {
 80007c0:	b508      	push	{r3, lr}

  chSysUnlockFromISR();
 80007c2:	f7ff ffed 	bl	80007a0 <chSysUnlockFromISR>
}
 80007c6:	bd08      	pop	{r3, pc}
	...

080007d0 <get_descriptor>:
 * handled here.
 */
static const USBDescriptor *get_descriptor(USBDriver *usbp,
                                           uint8_t dtype,
                                           uint8_t dindex,
                                           uint16_t lang) {
 80007d0:	b082      	sub	sp, #8
 80007d2:	9001      	str	r0, [sp, #4]
 80007d4:	4608      	mov	r0, r1
 80007d6:	4611      	mov	r1, r2
 80007d8:	461a      	mov	r2, r3
 80007da:	4603      	mov	r3, r0
 80007dc:	f88d 3003 	strb.w	r3, [sp, #3]
 80007e0:	460b      	mov	r3, r1
 80007e2:	f88d 3002 	strb.w	r3, [sp, #2]
 80007e6:	4613      	mov	r3, r2
 80007e8:	f8ad 3000 	strh.w	r3, [sp]

  (void)usbp;
  (void)lang;
  switch (dtype) {
 80007ec:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80007f0:	2b02      	cmp	r3, #2
 80007f2:	d005      	beq.n	8000800 <get_descriptor+0x30>
 80007f4:	2b03      	cmp	r3, #3
 80007f6:	d005      	beq.n	8000804 <get_descriptor+0x34>
 80007f8:	2b01      	cmp	r3, #1
 80007fa:	d10d      	bne.n	8000818 <get_descriptor+0x48>
  case USB_DESCRIPTOR_DEVICE:
    return &vcom_device_descriptor;
 80007fc:	4b08      	ldr	r3, [pc, #32]	; (8000820 <get_descriptor+0x50>)
 80007fe:	e00c      	b.n	800081a <get_descriptor+0x4a>
  case USB_DESCRIPTOR_CONFIGURATION:
    return &vcom_configuration_descriptor;
 8000800:	4b08      	ldr	r3, [pc, #32]	; (8000824 <get_descriptor+0x54>)
 8000802:	e00a      	b.n	800081a <get_descriptor+0x4a>
  case USB_DESCRIPTOR_STRING:
    if (dindex < 4)
 8000804:	f89d 3002 	ldrb.w	r3, [sp, #2]
 8000808:	2b03      	cmp	r3, #3
 800080a:	d805      	bhi.n	8000818 <get_descriptor+0x48>
      return &vcom_strings[dindex];
 800080c:	f89d 3002 	ldrb.w	r3, [sp, #2]
 8000810:	00db      	lsls	r3, r3, #3
 8000812:	4a05      	ldr	r2, [pc, #20]	; (8000828 <get_descriptor+0x58>)
 8000814:	4413      	add	r3, r2
 8000816:	e000      	b.n	800081a <get_descriptor+0x4a>
  }
  return NULL;
 8000818:	2300      	movs	r3, #0
}
 800081a:	4618      	mov	r0, r3
 800081c:	b002      	add	sp, #8
 800081e:	4770      	bx	lr
 8000820:	08009808 	.word	0x08009808
 8000824:	08009854 	.word	0x08009854
 8000828:	080098c8 	.word	0x080098c8
 800082c:	00000000 	.word	0x00000000

08000830 <usb_event>:
};

/*
 * Handles the USB driver global events.
 */
static void usb_event(USBDriver *usbp, usbevent_t event) {
 8000830:	b500      	push	{lr}
 8000832:	b083      	sub	sp, #12
 8000834:	9001      	str	r0, [sp, #4]
 8000836:	460b      	mov	r3, r1
 8000838:	f88d 3003 	strb.w	r3, [sp, #3]
//  extern SerialUSBDriver SDU1;

  switch (event) {
 800083c:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8000840:	2b06      	cmp	r3, #6
 8000842:	d822      	bhi.n	800088a <usb_event+0x5a>
 8000844:	a201      	add	r2, pc, #4	; (adr r2, 800084c <usb_event+0x1c>)
 8000846:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800084a:	bf00      	nop
 800084c:	0800088b 	.word	0x0800088b
 8000850:	0800088b 	.word	0x0800088b
 8000854:	08000869 	.word	0x08000869
 8000858:	0800088b 	.word	0x0800088b
 800085c:	0800088b 	.word	0x0800088b
 8000860:	0800088b 	.word	0x0800088b
 8000864:	0800088b 	.word	0x0800088b
  case USB_EVENT_RESET:
		return;
  case USB_EVENT_ADDRESS:
    return;
  case USB_EVENT_CONFIGURED:
    chSysLockFromISR();
 8000868:	f7ff ff92 	bl	8000790 <chSysLockFromISR>

    /* Enables the endpoints specified into the configuration.
       Note, this callback is invoked from an ISR so I-Class functions
       must be used.*/
    usbInitEndpointI(usbp, USBD2_DATA_REQUEST_EP, &ep1config);
 800086c:	4a08      	ldr	r2, [pc, #32]	; (8000890 <usb_event+0x60>)
 800086e:	2101      	movs	r1, #1
 8000870:	9801      	ldr	r0, [sp, #4]
 8000872:	f002 fc3d 	bl	80030f0 <usbInitEndpointI>
    usbInitEndpointI(usbp, USBD2_INTERRUPT_REQUEST_EP, &ep2config);
 8000876:	4a07      	ldr	r2, [pc, #28]	; (8000894 <usb_event+0x64>)
 8000878:	2102      	movs	r1, #2
 800087a:	9801      	ldr	r0, [sp, #4]
 800087c:	f002 fc38 	bl	80030f0 <usbInitEndpointI>

    /* Resetting the state of the CDC subsystem.*/
    sduConfigureHookI(&SDU1);
 8000880:	4805      	ldr	r0, [pc, #20]	; (8000898 <usb_event+0x68>)
 8000882:	f001 ff9d 	bl	80027c0 <sduConfigureHookI>

    chSysUnlockFromISR();
 8000886:	f7ff ff8b 	bl	80007a0 <chSysUnlockFromISR>
    return;
  case USB_EVENT_STALLED:
    return;
  }
  return;
}
 800088a:	b003      	add	sp, #12
 800088c:	f85d fb04 	ldr.w	pc, [sp], #4
 8000890:	080098e8 	.word	0x080098e8
 8000894:	0800990c 	.word	0x0800990c
 8000898:	2000142c 	.word	0x2000142c
 800089c:	00000000 	.word	0x00000000

080008a0 <sof_handler>:

/*
 * Handles the USB driver global events.
 */
static void sof_handler(USBDriver *usbp) {
 80008a0:	b500      	push	{lr}
 80008a2:	b083      	sub	sp, #12
 80008a4:	9001      	str	r0, [sp, #4]
  (void)usbp;
  osalSysLockFromISR();
 80008a6:	f7ff ff83 	bl	80007b0 <osalSysLockFromISR>
  sduSOFHookI(&SDU1);
 80008aa:	4804      	ldr	r0, [pc, #16]	; (80008bc <sof_handler+0x1c>)
 80008ac:	f001 ffe8 	bl	8002880 <sduSOFHookI>
  osalSysUnlockFromISR();
 80008b0:	f7ff ff86 	bl	80007c0 <osalSysUnlockFromISR>
}
 80008b4:	b003      	add	sp, #12
 80008b6:	f85d fb04 	ldr.w	pc, [sp], #4
 80008ba:	bf00      	nop
 80008bc:	2000142c 	.word	0x2000142c

080008c0 <init_usb_cdc>:
  USBD2_DATA_AVAILABLE_EP,
  USBD2_INTERRUPT_REQUEST_EP
};

int init_usb_cdc()  // Initializes a serial-over-USB CDC driver./
{
 80008c0:	b508      	push	{r3, lr}
    sduObjectInit(&SDU1);
 80008c2:	4811      	ldr	r0, [pc, #68]	; (8000908 <init_usb_cdc+0x48>)
 80008c4:	f001 fef4 	bl	80026b0 <sduObjectInit>
    sduStart(&SDU1, &serusbcfg);
 80008c8:	4910      	ldr	r1, [pc, #64]	; (800090c <init_usb_cdc+0x4c>)
 80008ca:	480f      	ldr	r0, [pc, #60]	; (8000908 <init_usb_cdc+0x48>)
 80008cc:	f001 ff30 	bl	8002730 <sduStart>
  //
  /** Activates the USB driver and then the USB bus pull-up on D+. Note, a delay is inserted in order to not
  have to disconnect the cable after a reset. */
    usbDisconnectBus(serusbcfg.usbp);
 80008d0:	4b0f      	ldr	r3, [pc, #60]	; (8000910 <init_usb_cdc+0x50>)
 80008d2:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 80008d4:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 80008d6:	4b0e      	ldr	r3, [pc, #56]	; (8000910 <init_usb_cdc+0x50>)
 80008d8:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 80008da:	f422 2200 	bic.w	r2, r2, #524288	; 0x80000
 80008de:	639a      	str	r2, [r3, #56]	; 0x38
    chThdSleepMilliseconds(1500);
 80008e0:	f643 2098 	movw	r0, #15000	; 0x3a98
 80008e4:	f006 ff1c 	bl	8007720 <chThdSleep>
    usbStart(serusbcfg.usbp, &usbcfg);
 80008e8:	4b09      	ldr	r3, [pc, #36]	; (8000910 <init_usb_cdc+0x50>)
 80008ea:	490a      	ldr	r1, [pc, #40]	; (8000914 <init_usb_cdc+0x54>)
 80008ec:	4618      	mov	r0, r3
 80008ee:	f002 fbbf 	bl	8003070 <usbStart>
    usbConnectBus(serusbcfg.usbp);
 80008f2:	4b07      	ldr	r3, [pc, #28]	; (8000910 <init_usb_cdc+0x50>)
 80008f4:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 80008f6:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 80008f8:	4b05      	ldr	r3, [pc, #20]	; (8000910 <init_usb_cdc+0x50>)
 80008fa:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 80008fc:	f442 2200 	orr.w	r2, r2, #524288	; 0x80000
 8000900:	639a      	str	r2, [r3, #56]	; 0x38

    return 1;
 8000902:	2301      	movs	r3, #1
}
 8000904:	4618      	mov	r0, r3
 8000906:	bd08      	pop	{r3, pc}
 8000908:	2000142c 	.word	0x2000142c
 800090c:	08009940 	.word	0x08009940
 8000910:	2000088c 	.word	0x2000088c
 8000914:	08009930 	.word	0x08009930
	...

08000920 <_ZN8IcHausMuC1Eh>:

#include "IcHausMu.hpp"

// ############################### Constructors ###############################

IcHausMu::IcHausMu(const unsigned char hwRev)
 8000920:	b500      	push	{lr}
 8000922:	b083      	sub	sp, #12
 8000924:	9001      	str	r0, [sp, #4]
 8000926:	460b      	mov	r3, r1
 8000928:	f88d 3003 	strb.w	r3, [sp, #3]
 800092c:	9b01      	ldr	r3, [sp, #4]
 800092e:	4a20      	ldr	r2, [pc, #128]	; (80009b0 <_ZN8IcHausMuC1Eh+0x90>)
 8000930:	3301      	adds	r3, #1
 8000932:	4611      	mov	r1, r2
 8000934:	227f      	movs	r2, #127	; 0x7f
 8000936:	4618      	mov	r0, r3
 8000938:	f7ff fce4 	bl	8000304 <memcpy>
 800093c:	9b01      	ldr	r3, [sp, #4]
 800093e:	4a1d      	ldr	r2, [pc, #116]	; (80009b4 <_ZN8IcHausMuC1Eh+0x94>)
 8000940:	3380      	adds	r3, #128	; 0x80
 8000942:	4611      	mov	r1, r2
 8000944:	227f      	movs	r2, #127	; 0x7f
 8000946:	4618      	mov	r0, r3
 8000948:	f7ff fcdc 	bl	8000304 <memcpy>
//  : _address(0x00) // can be used to initialize as list method
{
    debugVal = 0;
 800094c:	9b01      	ldr	r3, [sp, #4]
 800094e:	2200      	movs	r2, #0
 8000950:	701a      	strb	r2, [r3, #0]
    _tmpBuff64.dwords.msb.dword = 0x00000000;
 8000952:	9b01      	ldr	r3, [sp, #4]
 8000954:	2200      	movs	r2, #0
 8000956:	f8c3 2104 	str.w	r2, [r3, #260]	; 0x104
    _tmpBuff64.dwords.lsb.dword = 0x00000000;
 800095a:	9b01      	ldr	r3, [sp, #4]
 800095c:	2200      	movs	r2, #0
 800095e:	f8c3 2100 	str.w	r2, [r3, #256]	; 0x100
    _address = 0x00;
 8000962:	9b01      	ldr	r3, [sp, #4]
 8000964:	2200      	movs	r2, #0
 8000966:	f883 2108 	strb.w	r2, [r3, #264]	; 0x108
    _hardRev = hwRev;
 800096a:	9b01      	ldr	r3, [sp, #4]
 800096c:	f89d 2003 	ldrb.w	r2, [sp, #3]
 8000970:	f883 2109 	strb.w	r2, [r3, #265]	; 0x109
    _csFct_ptr = NULL;
 8000974:	9b01      	ldr	r3, [sp, #4]
 8000976:	2200      	movs	r2, #0
 8000978:	f8c3 2110 	str.w	r2, [r3, #272]	; 0x110
    _streamFct_ptr = NULL;
 800097c:	9b01      	ldr	r3, [sp, #4]
 800097e:	2200      	movs	r2, #0
 8000980:	f8c3 2114 	str.w	r2, [r3, #276]	; 0x114
    _initStatus = RET_W_UNINIT;
 8000984:	9b01      	ldr	r3, [sp, #4]
 8000986:	220a      	movs	r2, #10
 8000988:	f883 210d 	strb.w	r2, [r3, #269]	; 0x10d
    _sdadOutMsb = 0;
 800098c:	9b01      	ldr	r3, [sp, #4]
 800098e:	2200      	movs	r2, #0
 8000990:	f883 210a 	strb.w	r2, [r3, #266]	; 0x10a
    _sdadOutLsb = 0;
 8000994:	9b01      	ldr	r3, [sp, #4]
 8000996:	2200      	movs	r2, #0
 8000998:	f883 210b 	strb.w	r2, [r3, #267]	; 0x10b
    _sdadOutSize = 1;
 800099c:	9b01      	ldr	r3, [sp, #4]
 800099e:	2201      	movs	r2, #1
 80009a0:	f883 210c 	strb.w	r2, [r3, #268]	; 0x10c
}
 80009a4:	9b01      	ldr	r3, [sp, #4]
 80009a6:	4618      	mov	r0, r3
 80009a8:	b003      	add	sp, #12
 80009aa:	f85d fb04 	ldr.w	pc, [sp], #4
 80009ae:	bf00      	nop
 80009b0:	0800851c 	.word	0x0800851c
 80009b4:	0800859c 	.word	0x0800859c
	...

080009c0 <_ZL18chRegSetThreadNamePKc>:
 *
 * @param[in] name      thread name as a zero terminated string
 *
 * @api
 */
static inline void chRegSetThreadName(const char *name) {
 80009c0:	b082      	sub	sp, #8
 80009c2:	9001      	str	r0, [sp, #4]

#if CH_CFG_USE_REGISTRY == TRUE
  ch.rlist.current->name = name;
 80009c4:	4b02      	ldr	r3, [pc, #8]	; (80009d0 <_ZL18chRegSetThreadNamePKc+0x10>)
 80009c6:	699b      	ldr	r3, [r3, #24]
 80009c8:	9a01      	ldr	r2, [sp, #4]
 80009ca:	619a      	str	r2, [r3, #24]
#else
  (void)name;
#endif
}
 80009cc:	b002      	add	sp, #8
 80009ce:	4770      	bx	lr
 80009d0:	20000b38 	.word	0x20000b38
	...

080009e0 <_ZN10chibios_rt6System4initEv>:
     * @note    This function has special, architecture-dependent, requirements,
     *          see the notes into the various port reference manuals.
     *
     * @special
     */
    static void init(void) {
 80009e0:	b508      	push	{r3, lr}

      chSysInit();
 80009e2:	f005 fc6d 	bl	80062c0 <chSysInit>
    }
 80009e6:	bd08      	pop	{r3, pc}
	...

080009f0 <_ZN10chibios_rt10BaseThread5sleepEm>:
     *                      - @a TIME_IMMEDIATE this value is not allowed.
     *                      .
     *
     * @api
     */
    static void sleep(sysinterval_t interval) {
 80009f0:	b500      	push	{lr}
 80009f2:	b083      	sub	sp, #12
 80009f4:	9001      	str	r0, [sp, #4]

      chThdSleep(interval);
 80009f6:	9801      	ldr	r0, [sp, #4]
 80009f8:	f006 fe92 	bl	8007720 <chThdSleep>
    }
 80009fc:	b003      	add	sp, #12
 80009fe:	f85d fb04 	ldr.w	pc, [sp], #4
 8000a02:	bf00      	nop
	...

08000a10 <_ZL7Thread2Pv>:
/*===========================================================================*/
/* Shell Handler thread to spawn a shell                                                             */
/*===========================================================================*/

static THD_WORKING_AREA(waThread2, 2048);
static THD_FUNCTION(Thread2, arg) {
 8000a10:	b500      	push	{lr}
 8000a12:	b083      	sub	sp, #12
 8000a14:	9001      	str	r0, [sp, #4]
  (void)arg;
  chRegSetThreadName("shell_handler");
 8000a16:	4804      	ldr	r0, [pc, #16]	; (8000a28 <_ZL7Thread2Pv+0x18>)
 8000a18:	f7ff ffd2 	bl	80009c0 <_ZL18chRegSetThreadNamePKc>
                                                        "shell", NORMALPRIO + 1,
                                                        shellThread, (void *)&shell_cfg1);
                chThdWait(shelltp);               // Waiting termination.
               // palClearLine(LED_RED);
    }*/
    chThdSleepMilliseconds(1000);
 8000a1c:	f242 7010 	movw	r0, #10000	; 0x2710
 8000a20:	f006 fe7e 	bl	8007720 <chThdSleep>
 8000a24:	e7fa      	b.n	8000a1c <_ZL7Thread2Pv+0xc>
 8000a26:	bf00      	nop
 8000a28:	08009948 	.word	0x08009948
 8000a2c:	00000000 	.word	0x00000000

08000a30 <_ZL7Thread1Pv>:

/* =============================================================================
 * USB com status blinker thread, times are in milliseconds.
 ===============================================================================*/
static THD_WORKING_AREA(waThread1, 128);
static THD_FUNCTION(Thread1, arg) {
 8000a30:	b570      	push	{r4, r5, r6, lr}
 8000a32:	b084      	sub	sp, #16
 8000a34:	9001      	str	r0, [sp, #4]
  (void)arg;
  chRegSetThreadName("com_status");
 8000a36:	4859      	ldr	r0, [pc, #356]	; (8000b9c <_ZL7Thread1Pv+0x16c>)
 8000a38:	f7ff ffc2 	bl	80009c0 <_ZL18chRegSetThreadNamePKc>
  while (true) {
    systime_t time = 500;
 8000a3c:	f44f 73fa 	mov.w	r3, #500	; 0x1f4
 8000a40:	9303      	str	r3, [sp, #12]
    time = serusbcfg.usbp->state == USB_ACTIVE ? 250 : 1000;
 8000a42:	4b57      	ldr	r3, [pc, #348]	; (8000ba0 <_ZL7Thread1Pv+0x170>)
 8000a44:	681b      	ldr	r3, [r3, #0]
 8000a46:	781b      	ldrb	r3, [r3, #0]
 8000a48:	2b04      	cmp	r3, #4
 8000a4a:	d101      	bne.n	8000a50 <_ZL7Thread1Pv+0x20>
 8000a4c:	23fa      	movs	r3, #250	; 0xfa
 8000a4e:	e001      	b.n	8000a54 <_ZL7Thread1Pv+0x24>
 8000a50:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 8000a54:	9303      	str	r3, [sp, #12]
    palClearLine(LED_RED);
 8000a56:	4b53      	ldr	r3, [pc, #332]	; (8000ba4 <_ZL7Thread1Pv+0x174>)
 8000a58:	f44f 5200 	mov.w	r2, #8192	; 0x2000
 8000a5c:	835a      	strh	r2, [r3, #26]
    chThdSleepMilliseconds(time);
 8000a5e:	9b03      	ldr	r3, [sp, #12]
 8000a60:	461d      	mov	r5, r3
 8000a62:	f04f 0600 	mov.w	r6, #0
 8000a66:	462b      	mov	r3, r5
 8000a68:	4634      	mov	r4, r6
 8000a6a:	f04f 0100 	mov.w	r1, #0
 8000a6e:	f04f 0200 	mov.w	r2, #0
 8000a72:	00a2      	lsls	r2, r4, #2
 8000a74:	ea42 7293 	orr.w	r2, r2, r3, lsr #30
 8000a78:	0099      	lsls	r1, r3, #2
 8000a7a:	460b      	mov	r3, r1
 8000a7c:	4614      	mov	r4, r2
 8000a7e:	195b      	adds	r3, r3, r5
 8000a80:	eb44 0406 	adc.w	r4, r4, r6
 8000a84:	f04f 0100 	mov.w	r1, #0
 8000a88:	f04f 0200 	mov.w	r2, #0
 8000a8c:	00e2      	lsls	r2, r4, #3
 8000a8e:	ea42 7253 	orr.w	r2, r2, r3, lsr #29
 8000a92:	00d9      	lsls	r1, r3, #3
 8000a94:	460b      	mov	r3, r1
 8000a96:	4614      	mov	r4, r2
 8000a98:	1b5b      	subs	r3, r3, r5
 8000a9a:	eb64 0406 	sbc.w	r4, r4, r6
 8000a9e:	f04f 0100 	mov.w	r1, #0
 8000aa2:	f04f 0200 	mov.w	r2, #0
 8000aa6:	0122      	lsls	r2, r4, #4
 8000aa8:	ea42 7213 	orr.w	r2, r2, r3, lsr #28
 8000aac:	0119      	lsls	r1, r3, #4
 8000aae:	460b      	mov	r3, r1
 8000ab0:	4614      	mov	r4, r2
 8000ab2:	195b      	adds	r3, r3, r5
 8000ab4:	eb44 0406 	adc.w	r4, r4, r6
 8000ab8:	f04f 0100 	mov.w	r1, #0
 8000abc:	f04f 0200 	mov.w	r2, #0
 8000ac0:	0122      	lsls	r2, r4, #4
 8000ac2:	ea42 7213 	orr.w	r2, r2, r3, lsr #28
 8000ac6:	0119      	lsls	r1, r3, #4
 8000ac8:	460b      	mov	r3, r1
 8000aca:	4614      	mov	r4, r2
 8000acc:	4619      	mov	r1, r3
 8000ace:	4622      	mov	r2, r4
 8000ad0:	f240 33e7 	movw	r3, #999	; 0x3e7
 8000ad4:	f04f 0400 	mov.w	r4, #0
 8000ad8:	18cd      	adds	r5, r1, r3
 8000ada:	eb42 0604 	adc.w	r6, r2, r4
 8000ade:	4628      	mov	r0, r5
 8000ae0:	4631      	mov	r1, r6
 8000ae2:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
 8000ae6:	f04f 0300 	mov.w	r3, #0
 8000aea:	f7ff fca5 	bl	8000438 <__aeabi_uldivmod>
 8000aee:	4603      	mov	r3, r0
 8000af0:	460c      	mov	r4, r1
 8000af2:	4618      	mov	r0, r3
 8000af4:	f006 fe14 	bl	8007720 <chThdSleep>
    palSetLine(LED_RED);
 8000af8:	4b2a      	ldr	r3, [pc, #168]	; (8000ba4 <_ZL7Thread1Pv+0x174>)
 8000afa:	f44f 5200 	mov.w	r2, #8192	; 0x2000
 8000afe:	831a      	strh	r2, [r3, #24]
    chThdSleepMilliseconds(time);
 8000b00:	9b03      	ldr	r3, [sp, #12]
 8000b02:	461d      	mov	r5, r3
 8000b04:	f04f 0600 	mov.w	r6, #0
 8000b08:	462b      	mov	r3, r5
 8000b0a:	4634      	mov	r4, r6
 8000b0c:	f04f 0100 	mov.w	r1, #0
 8000b10:	f04f 0200 	mov.w	r2, #0
 8000b14:	00a2      	lsls	r2, r4, #2
 8000b16:	ea42 7293 	orr.w	r2, r2, r3, lsr #30
 8000b1a:	0099      	lsls	r1, r3, #2
 8000b1c:	460b      	mov	r3, r1
 8000b1e:	4614      	mov	r4, r2
 8000b20:	195b      	adds	r3, r3, r5
 8000b22:	eb44 0406 	adc.w	r4, r4, r6
 8000b26:	f04f 0100 	mov.w	r1, #0
 8000b2a:	f04f 0200 	mov.w	r2, #0
 8000b2e:	00e2      	lsls	r2, r4, #3
 8000b30:	ea42 7253 	orr.w	r2, r2, r3, lsr #29
 8000b34:	00d9      	lsls	r1, r3, #3
 8000b36:	460b      	mov	r3, r1
 8000b38:	4614      	mov	r4, r2
 8000b3a:	1b5b      	subs	r3, r3, r5
 8000b3c:	eb64 0406 	sbc.w	r4, r4, r6
 8000b40:	f04f 0100 	mov.w	r1, #0
 8000b44:	f04f 0200 	mov.w	r2, #0
 8000b48:	0122      	lsls	r2, r4, #4
 8000b4a:	ea42 7213 	orr.w	r2, r2, r3, lsr #28
 8000b4e:	0119      	lsls	r1, r3, #4
 8000b50:	460b      	mov	r3, r1
 8000b52:	4614      	mov	r4, r2
 8000b54:	195b      	adds	r3, r3, r5
 8000b56:	eb44 0406 	adc.w	r4, r4, r6
 8000b5a:	f04f 0100 	mov.w	r1, #0
 8000b5e:	f04f 0200 	mov.w	r2, #0
 8000b62:	0122      	lsls	r2, r4, #4
 8000b64:	ea42 7213 	orr.w	r2, r2, r3, lsr #28
 8000b68:	0119      	lsls	r1, r3, #4
 8000b6a:	460b      	mov	r3, r1
 8000b6c:	4614      	mov	r4, r2
 8000b6e:	4619      	mov	r1, r3
 8000b70:	4622      	mov	r2, r4
 8000b72:	f240 33e7 	movw	r3, #999	; 0x3e7
 8000b76:	f04f 0400 	mov.w	r4, #0
 8000b7a:	18cd      	adds	r5, r1, r3
 8000b7c:	eb42 0604 	adc.w	r6, r2, r4
 8000b80:	4628      	mov	r0, r5
 8000b82:	4631      	mov	r1, r6
 8000b84:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
 8000b88:	f04f 0300 	mov.w	r3, #0
 8000b8c:	f7ff fc54 	bl	8000438 <__aeabi_uldivmod>
 8000b90:	4603      	mov	r3, r0
 8000b92:	460c      	mov	r4, r1
 8000b94:	4618      	mov	r0, r3
 8000b96:	f006 fdc3 	bl	8007720 <chThdSleep>
 8000b9a:	e74f      	b.n	8000a3c <_ZL7Thread1Pv+0xc>
 8000b9c:	08009958 	.word	0x08009958
 8000ba0:	08009940 	.word	0x08009940
 8000ba4:	40020c00 	.word	0x40020c00
	...

08000bb0 <_ZL7Thread3Pv>:

/*=============================================================================
 * LED blinker heartbeat thread, times are in milliseconds.
 =============================================================================*/
static THD_WORKING_AREA(waThread3, 128);
static THD_FUNCTION(Thread3, arg) {
 8000bb0:	b500      	push	{lr}
 8000bb2:	b083      	sub	sp, #12
 8000bb4:	9001      	str	r0, [sp, #4]
  (void)arg;
  chRegSetThreadName("blinker");
 8000bb6:	480a      	ldr	r0, [pc, #40]	; (8000be0 <_ZL7Thread3Pv+0x30>)
 8000bb8:	f7ff ff02 	bl	80009c0 <_ZL18chRegSetThreadNamePKc>
  while (true) {
    palSetLine(LED_GREEN);
 8000bbc:	4b09      	ldr	r3, [pc, #36]	; (8000be4 <_ZL7Thread3Pv+0x34>)
 8000bbe:	f44f 5280 	mov.w	r2, #4096	; 0x1000
 8000bc2:	831a      	strh	r2, [r3, #24]
    chThdSleepMilliseconds(100);
 8000bc4:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 8000bc8:	f006 fdaa 	bl	8007720 <chThdSleep>
    palClearLine(LED_GREEN);
 8000bcc:	4b05      	ldr	r3, [pc, #20]	; (8000be4 <_ZL7Thread3Pv+0x34>)
 8000bce:	f44f 5280 	mov.w	r2, #4096	; 0x1000
 8000bd2:	835a      	strh	r2, [r3, #26]
    chThdSleepMilliseconds(900);
 8000bd4:	f242 3028 	movw	r0, #9000	; 0x2328
 8000bd8:	f006 fda2 	bl	8007720 <chThdSleep>
 8000bdc:	e7ee      	b.n	8000bbc <_ZL7Thread3Pv+0xc>
 8000bde:	bf00      	nop
 8000be0:	08009964 	.word	0x08009964
 8000be4:	40020c00 	.word	0x40020c00
	...

08000bf0 <main>:
void hw_init_gpio(void);

/*
 * Application entry point.
 */
int main(void) {
 8000bf0:	b500      	push	{lr}
 8000bf2:	b087      	sub	sp, #28

#ifdef HW_412
  hw_init_gpio();
#endif

  halInit();
 8000bf4:	f000 f8e4 	bl	8000dc0 <halInit>
  //chSysInit();
  System::init();
 8000bf8:	f7ff fef2 	bl	80009e0 <_ZN10chibios_rt6System4initEv>

  // Shell manager initialization.
  //shellInit();

  //Initialize pullup for LEDs
  palSetPadMode(GPIOC, 4, PAL_MODE_OUTPUT_PUSHPULL | PAL_STM32_OSPEED_HIGHEST);
 8000bfc:	2219      	movs	r2, #25
 8000bfe:	2110      	movs	r1, #16
 8000c00:	4826      	ldr	r0, [pc, #152]	; (8000c9c <main+0xac>)
 8000c02:	f003 fa8d 	bl	8004120 <_pal_lld_setgroupmode>
  palSetPadMode(GPIOC, 5, PAL_MODE_OUTPUT_PUSHPULL | PAL_STM32_OSPEED_HIGHEST);
 8000c06:	2219      	movs	r2, #25
 8000c08:	2120      	movs	r1, #32
 8000c0a:	4824      	ldr	r0, [pc, #144]	; (8000c9c <main+0xac>)
 8000c0c:	f003 fa88 	bl	8004120 <_pal_lld_setgroupmode>
  //Initialize pads and AF(Alternate functions) for PWM
  palSetPadMode(GPIOA, 8, PAL_MODE_ALTERNATE(1)); //PWM on PA8(dico) or D7(nucleo/arduino header)
 8000c10:	2282      	movs	r2, #130	; 0x82
 8000c12:	f44f 7180 	mov.w	r1, #256	; 0x100
 8000c16:	4822      	ldr	r0, [pc, #136]	; (8000ca0 <main+0xb0>)
 8000c18:	f003 fa82 	bl	8004120 <_pal_lld_setgroupmode>
 // palSetPadMode(PORT_SPI1_MISO, PIN_SPI1_MISO,PAL_MODE_ALTERNATE(5) | PAL_STM32_OSPEED_HIGHEST);    /* New MISO*/
  //palSetPadMode(PORT_SPI1_MOSI, PIN_SPI1_MOSI, PAL_MODE_ALTERNATE(5) | PAL_STM32_OSPEED_HIGHEST);    /* New MOSI*/
  //palSetPadMode(PORT_SPI1_CS, PIN_SPI1_CS, PAL_MODE_OUTPUT_PUSHPULL | PAL_STM32_OSPEED_HIGHEST);//PAL_MODE_OUTPUT_PUSHPULL | PAL_STM32_OSPEED_HIGHEST); /* New CS*/

  //Initialize pads for VPC
  palSetPadMode(GPIOA, 11, PAL_MODE_ALTERNATE(GPIO_AF_OTG_FS) | PAL_STM32_OTYPE_PUSHPULL | PAL_STM32_OSPEED_MID1);
 8000c1c:	f240 520a 	movw	r2, #1290	; 0x50a
 8000c20:	f44f 6100 	mov.w	r1, #2048	; 0x800
 8000c24:	481e      	ldr	r0, [pc, #120]	; (8000ca0 <main+0xb0>)
 8000c26:	f003 fa7b 	bl	8004120 <_pal_lld_setgroupmode>
  palSetPadMode(GPIOA, 12, PAL_MODE_ALTERNATE(GPIO_AF_OTG_FS) | PAL_STM32_OTYPE_PUSHPULL | PAL_STM32_OSPEED_MID1);
 8000c2a:	f240 520a 	movw	r2, #1290	; 0x50a
 8000c2e:	f44f 5180 	mov.w	r1, #4096	; 0x1000
 8000c32:	481b      	ldr	r0, [pc, #108]	; (8000ca0 <main+0xb0>)
 8000c34:	f003 fa74 	bl	8004120 <_pal_lld_setgroupmode>

  init_usb_cdc();
 8000c38:	f7ff fe42 	bl	80008c0 <init_usb_cdc>

  //comm_usb_init();
   test32(4);
 8000c3c:	2004      	movs	r0, #4
 8000c3e:	f7ff fd7f 	bl	8000740 <test32>
    *          programmed in one of the channels then the behavior is not;
    *          guaranteed." */
  //pwmEnableChannel(&PWMD1, 0, PWM_PERCENTAGE_TO_WIDTH(&PWMD1, 5000));

  // Creates the usb status blinker thread.
  chThdCreateStatic(waThread1, sizeof(waThread1), NORMALPRIO, Thread1, NULL);
 8000c42:	2300      	movs	r3, #0
 8000c44:	9300      	str	r3, [sp, #0]
 8000c46:	4b17      	ldr	r3, [pc, #92]	; (8000ca4 <main+0xb4>)
 8000c48:	2280      	movs	r2, #128	; 0x80
 8000c4a:	f44f 71a4 	mov.w	r1, #328	; 0x148
 8000c4e:	4816      	ldr	r0, [pc, #88]	; (8000ca8 <main+0xb8>)
 8000c50:	f006 fc5e 	bl	8007510 <chThdCreateStatic>
  // Creates the shell spawning thread.
  chThdCreateStatic(waThread2, sizeof(waThread2), LOWPRIO, Thread2, NULL);
 8000c54:	2300      	movs	r3, #0
 8000c56:	9300      	str	r3, [sp, #0]
 8000c58:	4b14      	ldr	r3, [pc, #80]	; (8000cac <main+0xbc>)
 8000c5a:	2202      	movs	r2, #2
 8000c5c:	f640 01c8 	movw	r1, #2248	; 0x8c8
 8000c60:	4813      	ldr	r0, [pc, #76]	; (8000cb0 <main+0xc0>)
 8000c62:	f006 fc55 	bl	8007510 <chThdCreateStatic>
  //Create the heartbeat thread
  chThdCreateStatic(waThread3, sizeof(waThread3), NORMALPRIO, Thread3, NULL);
 8000c66:	2300      	movs	r3, #0
 8000c68:	9300      	str	r3, [sp, #0]
 8000c6a:	4b12      	ldr	r3, [pc, #72]	; (8000cb4 <main+0xc4>)
 8000c6c:	2280      	movs	r2, #128	; 0x80
 8000c6e:	f44f 71a4 	mov.w	r1, #328	; 0x148
 8000c72:	4811      	ldr	r0, [pc, #68]	; (8000cb8 <main+0xc8>)
 8000c74:	f006 fc4c 	bl	8007510 <chThdCreateStatic>
        sdPutTimeout(&SD2, (int8_t)'t',TIME_MS2I(50));
        uint8_t msg[] = "\r\nD: SPI frame sent";
        chnWrite(&SDU1, msg, sizeof msg); //Example to send Debug Message on the VCP (Virtual Com Port)
        }*/
    //palTogglePad(GPIOD, LED_GREEN);
    uint8_t msg[] = "\r\nD: Main";
 8000c78:	4a10      	ldr	r2, [pc, #64]	; (8000cbc <main+0xcc>)
 8000c7a:	ab03      	add	r3, sp, #12
 8000c7c:	ca07      	ldmia	r2, {r0, r1, r2}
 8000c7e:	c303      	stmia	r3!, {r0, r1}
 8000c80:	801a      	strh	r2, [r3, #0]
    chnWrite(&SDU1, msg, sizeof msg); //Example to send Debug Message on the VCP (Virtual Com Port
 8000c82:	4b0f      	ldr	r3, [pc, #60]	; (8000cc0 <main+0xd0>)
 8000c84:	681b      	ldr	r3, [r3, #0]
 8000c86:	685b      	ldr	r3, [r3, #4]
 8000c88:	a903      	add	r1, sp, #12
 8000c8a:	220a      	movs	r2, #10
 8000c8c:	480c      	ldr	r0, [pc, #48]	; (8000cc0 <main+0xd0>)
 8000c8e:	4798      	blx	r3

    BaseThread::sleep(TIME_MS2I(5000)); // chThdSleepMilliseconds(200); // in C;
 8000c90:	f24c 3050 	movw	r0, #50000	; 0xc350
 8000c94:	f7ff feac 	bl	80009f0 <_ZN10chibios_rt10BaseThread5sleepEm>
 8000c98:	e7ee      	b.n	8000c78 <main+0x88>
 8000c9a:	bf00      	nop
 8000c9c:	40020800 	.word	0x40020800
 8000ca0:	40020000 	.word	0x40020000
 8000ca4:	08000a31 	.word	0x08000a31
 8000ca8:	200022d0 	.word	0x200022d0
 8000cac:	08000a11 	.word	0x08000a11
 8000cb0:	20001a08 	.word	0x20001a08
 8000cb4:	08000bb1 	.word	0x08000bb1
 8000cb8:	20002418 	.word	0x20002418
 8000cbc:	0800996c 	.word	0x0800996c
 8000cc0:	2000142c 	.word	0x2000142c
	...

08000cd0 <_Z41__static_initialization_and_destruction_0ii>:
  }

  return 0;
}
 8000cd0:	b500      	push	{lr}
 8000cd2:	b083      	sub	sp, #12
 8000cd4:	9001      	str	r0, [sp, #4]
 8000cd6:	9100      	str	r1, [sp, #0]
 8000cd8:	9b01      	ldr	r3, [sp, #4]
 8000cda:	2b01      	cmp	r3, #1
 8000cdc:	d108      	bne.n	8000cf0 <_Z41__static_initialization_and_destruction_0ii+0x20>
 8000cde:	9b00      	ldr	r3, [sp, #0]
 8000ce0:	f64f 72ff 	movw	r2, #65535	; 0xffff
 8000ce4:	4293      	cmp	r3, r2
 8000ce6:	d103      	bne.n	8000cf0 <_Z41__static_initialization_and_destruction_0ii+0x20>
#define ICHAUSMU_ICMU_UTILS_H_

#define BUS_SIZE 16
#include "ichausmu/IcHausMu.hpp"

 IcHausMu encoder(0x07);//Instanciate icMU
 8000ce8:	2107      	movs	r1, #7
 8000cea:	4803      	ldr	r0, [pc, #12]	; (8000cf8 <_Z41__static_initialization_and_destruction_0ii+0x28>)
 8000cec:	f7ff fe18 	bl	8000920 <_ZN8IcHausMuC1Eh>
 8000cf0:	b003      	add	sp, #12
 8000cf2:	f85d fb04 	ldr.w	pc, [sp], #4
 8000cf6:	bf00      	nop
 8000cf8:	200018ec 	.word	0x200018ec
 8000cfc:	00000000 	.word	0x00000000

08000d00 <_GLOBAL__sub_I_encoder>:
 8000d00:	b508      	push	{r3, lr}
 8000d02:	f64f 71ff 	movw	r1, #65535	; 0xffff
 8000d06:	2001      	movs	r0, #1
 8000d08:	f7ff ffe2 	bl	8000cd0 <_Z41__static_initialization_and_destruction_0ii>
 8000d0c:	bd08      	pop	{r3, pc}
 8000d0e:	bf00      	nop

08000d10 <__core_init>:

#if CORTEX_MODEL == 7
  SCB_EnableICache();
  SCB_EnableDCache();
#endif
}
 8000d10:	4770      	bx	lr
 8000d12:	bf00      	nop
	...

08000d20 <__late_init>:
 */
#if !defined(__DOXYGEN__)
__attribute__((weak))
#endif
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void __late_init(void) {}
 8000d20:	4770      	bx	lr
 8000d22:	bf00      	nop
	...

08000d30 <__default_exit>:
 */
#if !defined(__DOXYGEN__)
__attribute__((noreturn, weak))
#endif
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void __default_exit(void) {
 8000d30:	e7fe      	b.n	8000d30 <__default_exit>
 8000d32:	bf00      	nop
	...

08000d40 <__init_ram_areas>:
}

/**
 * @brief   Performs the initialization of the various RAM areas.
 */
void __init_ram_areas(void) {
 8000d40:	b084      	sub	sp, #16
#if CRT1_AREAS_NUMBER > 0
  const ram_init_area_t *rap = ram_areas;
 8000d42:	4b16      	ldr	r3, [pc, #88]	; (8000d9c <__init_ram_areas+0x5c>)
 8000d44:	9303      	str	r3, [sp, #12]

  do {
    uint32_t *tp = rap->init_text_area;
 8000d46:	9b03      	ldr	r3, [sp, #12]
 8000d48:	681b      	ldr	r3, [r3, #0]
 8000d4a:	9302      	str	r3, [sp, #8]
    uint32_t *p = rap->init_area;
 8000d4c:	9b03      	ldr	r3, [sp, #12]
 8000d4e:	685b      	ldr	r3, [r3, #4]
 8000d50:	9301      	str	r3, [sp, #4]
 8000d52:	e009      	b.n	8000d68 <__init_ram_areas+0x28>

    /* Copying initialization data.*/
    while (p < rap->clear_area) {
      *p = *tp;
 8000d54:	9b02      	ldr	r3, [sp, #8]
 8000d56:	681a      	ldr	r2, [r3, #0]
 8000d58:	9b01      	ldr	r3, [sp, #4]
 8000d5a:	601a      	str	r2, [r3, #0]
      p++;
 8000d5c:	9b01      	ldr	r3, [sp, #4]
 8000d5e:	3304      	adds	r3, #4
 8000d60:	9301      	str	r3, [sp, #4]
      tp++;
 8000d62:	9b02      	ldr	r3, [sp, #8]
 8000d64:	3304      	adds	r3, #4
 8000d66:	9302      	str	r3, [sp, #8]
    while (p < rap->clear_area) {
 8000d68:	9b03      	ldr	r3, [sp, #12]
 8000d6a:	689b      	ldr	r3, [r3, #8]
 8000d6c:	9a01      	ldr	r2, [sp, #4]
 8000d6e:	429a      	cmp	r2, r3
 8000d70:	d3f0      	bcc.n	8000d54 <__init_ram_areas+0x14>
 8000d72:	e005      	b.n	8000d80 <__init_ram_areas+0x40>
    }

    /* Zeroing clear area.*/
    while (p < rap->no_init_area) {
      *p = 0;
 8000d74:	9b01      	ldr	r3, [sp, #4]
 8000d76:	2200      	movs	r2, #0
 8000d78:	601a      	str	r2, [r3, #0]
      p++;
 8000d7a:	9b01      	ldr	r3, [sp, #4]
 8000d7c:	3304      	adds	r3, #4
 8000d7e:	9301      	str	r3, [sp, #4]
    while (p < rap->no_init_area) {
 8000d80:	9b03      	ldr	r3, [sp, #12]
 8000d82:	68db      	ldr	r3, [r3, #12]
 8000d84:	9a01      	ldr	r2, [sp, #4]
 8000d86:	429a      	cmp	r2, r3
 8000d88:	d3f4      	bcc.n	8000d74 <__init_ram_areas+0x34>
    }
    rap++;
 8000d8a:	9b03      	ldr	r3, [sp, #12]
 8000d8c:	3310      	adds	r3, #16
 8000d8e:	9303      	str	r3, [sp, #12]
  }
  while (rap < &ram_areas[CRT1_AREAS_NUMBER]);
 8000d90:	9b03      	ldr	r3, [sp, #12]
 8000d92:	4a03      	ldr	r2, [pc, #12]	; (8000da0 <__init_ram_areas+0x60>)
 8000d94:	4293      	cmp	r3, r2
 8000d96:	d3d6      	bcc.n	8000d46 <__init_ram_areas+0x6>
#endif
}
 8000d98:	b004      	add	sp, #16
 8000d9a:	4770      	bx	lr
 8000d9c:	0800861c 	.word	0x0800861c
 8000da0:	0800869c 	.word	0x0800869c
	...

08000db0 <osalInit>:
}
 8000db0:	4770      	bx	lr
 8000db2:	bf00      	nop
	...

08000dc0 <halInit>:
 *          board-specific initialization is performed by invoking
 *          @p boardInit() (usually defined in @p board.c).
 *
 * @init
 */
void halInit(void) {
 8000dc0:	b508      	push	{r3, lr}

  /* Initializes the OS Abstraction Layer.*/
  osalInit();
 8000dc2:	f7ff fff5 	bl	8000db0 <osalInit>

  /* Platform low level initializations.*/
  hal_lld_init();
 8000dc6:	f002 fd7b 	bl	80038c0 <hal_lld_init>

#if (HAL_USE_PAL == TRUE) || defined(__DOXYGEN__)
#if defined(PAL_NEW_INIT)
  palInit();
 8000dca:	f003 f9a1 	bl	8004110 <_pal_lld_init>
#endif
#if (HAL_USE_MAC == TRUE) || defined(__DOXYGEN__)
  macInit();
#endif
#if (HAL_USE_PWM == TRUE) || defined(__DOXYGEN__)
  pwmInit();
 8000dce:	f001 f8d7 	bl	8001f80 <pwmInit>
#endif
#if (HAL_USE_SERIAL == TRUE) || defined(__DOXYGEN__)
  sdInit();
 8000dd2:	f001 f9ed 	bl	80021b0 <sdInit>
#endif
#if (HAL_USE_SDC == TRUE) || defined(__DOXYGEN__)
  sdcInit();
#endif
#if (HAL_USE_SPI == TRUE) || defined(__DOXYGEN__)
  spiInit();
 8000dd6:	f001 fe63 	bl	8002aa0 <spiInit>
#endif
#if (HAL_USE_UART == TRUE) || defined(__DOXYGEN__)
  uartInit();
#endif
#if (HAL_USE_USB == TRUE) || defined(__DOXYGEN__)
  usbInit();
 8000dda:	f002 f919 	bl	8003010 <usbInit>
#endif
#if (HAL_USE_MMC_SPI == TRUE) || defined(__DOXYGEN__)
  mmcInit();
#endif
#if (HAL_USE_SERIAL_USB == TRUE) || defined(__DOXYGEN__)
  sduInit();
 8000dde:	f001 fc5f 	bl	80026a0 <sduInit>
  halCommunityInit();
#endif
#endif

  /* Board specific initialization.*/
  boardInit();
 8000de2:	f005 f8a5 	bl	8005f30 <boardInit>
/*
 *  The ST driver is a special case, it is only initialized if the OSAL is
 *  configured to require it.
 */
#if OSAL_ST_MODE != OSAL_ST_MODE_NONE
  stInit();
 8000de6:	f000 f833 	bl	8000e50 <stInit>
#endif
}
 8000dea:	bd08      	pop	{r3, pc}
 8000dec:	0000      	movs	r0, r0
	...

08000df0 <st_lld_start_alarm>:
 *
 * @param[in] time      the time to be set for the first alarm
 *
 * @notapi
 */
static inline void st_lld_start_alarm(systime_t time) {
 8000df0:	b082      	sub	sp, #8
 8000df2:	9001      	str	r0, [sp, #4]

  STM32_ST_TIM->CCR[0] = (uint32_t)time;
 8000df4:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
 8000df8:	9b01      	ldr	r3, [sp, #4]
 8000dfa:	6353      	str	r3, [r2, #52]	; 0x34
  STM32_ST_TIM->SR     = 0;
 8000dfc:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8000e00:	2200      	movs	r2, #0
 8000e02:	611a      	str	r2, [r3, #16]
  STM32_ST_TIM->DIER   = STM32_TIM_DIER_CC1IE;
 8000e04:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8000e08:	2202      	movs	r2, #2
 8000e0a:	60da      	str	r2, [r3, #12]
}
 8000e0c:	b002      	add	sp, #8
 8000e0e:	4770      	bx	lr

08000e10 <st_lld_stop_alarm>:
 *
 * @notapi
 */
static inline void st_lld_stop_alarm(void) {

  STM32_ST_TIM->DIER = 0;
 8000e10:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8000e14:	2200      	movs	r2, #0
 8000e16:	60da      	str	r2, [r3, #12]
}
 8000e18:	4770      	bx	lr
 8000e1a:	bf00      	nop
 8000e1c:	0000      	movs	r0, r0
	...

08000e20 <st_lld_set_alarm>:
 *
 * @param[in] time      the time to be set for the next alarm
 *
 * @notapi
 */
static inline void st_lld_set_alarm(systime_t time) {
 8000e20:	b082      	sub	sp, #8
 8000e22:	9001      	str	r0, [sp, #4]

  STM32_ST_TIM->CCR[0] = (uint32_t)time;
 8000e24:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
 8000e28:	9b01      	ldr	r3, [sp, #4]
 8000e2a:	6353      	str	r3, [r2, #52]	; 0x34
}
 8000e2c:	b002      	add	sp, #8
 8000e2e:	4770      	bx	lr

08000e30 <st_lld_is_alarm_active>:
 *
 * @notapi
 */
static inline bool st_lld_is_alarm_active(void) {

  return (bool)((STM32_ST_TIM->DIER & STM32_TIM_DIER_CC1IE) != 0);
 8000e30:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8000e34:	68db      	ldr	r3, [r3, #12]
 8000e36:	f003 0302 	and.w	r3, r3, #2
 8000e3a:	2b00      	cmp	r3, #0
 8000e3c:	bf14      	ite	ne
 8000e3e:	2301      	movne	r3, #1
 8000e40:	2300      	moveq	r3, #0
 8000e42:	b2db      	uxtb	r3, r3
}
 8000e44:	4618      	mov	r0, r3
 8000e46:	4770      	bx	lr
	...

08000e50 <stInit>:
 * @note    This function is implicitly invoked by @p halInit(), there is
 *          no need to explicitly initialize the driver.
 *
 * @init
 */
void stInit(void) {
 8000e50:	b508      	push	{r3, lr}

  st_lld_init();
 8000e52:	f004 fd6d 	bl	8005930 <st_lld_init>
}
 8000e56:	bd08      	pop	{r3, pc}
	...

08000e60 <stStartAlarm>:
 *
 * @param[in] abstime   the time to be set for the first alarm
 *
 * @api
 */
void stStartAlarm(systime_t abstime) {
 8000e60:	b500      	push	{lr}
 8000e62:	b083      	sub	sp, #12
 8000e64:	9001      	str	r0, [sp, #4]

  osalDbgAssert(stIsAlarmActive() == false, "already active");
 8000e66:	f7ff ffe3 	bl	8000e30 <st_lld_is_alarm_active>
 8000e6a:	4603      	mov	r3, r0
 8000e6c:	2b00      	cmp	r3, #0
 8000e6e:	d002      	beq.n	8000e76 <stStartAlarm+0x16>
 8000e70:	4804      	ldr	r0, [pc, #16]	; (8000e84 <stStartAlarm+0x24>)
 8000e72:	f005 fa5d 	bl	8006330 <chSysHalt>

  st_lld_start_alarm(abstime);
 8000e76:	9801      	ldr	r0, [sp, #4]
 8000e78:	f7ff ffba 	bl	8000df0 <st_lld_start_alarm>
}
 8000e7c:	b003      	add	sp, #12
 8000e7e:	f85d fb04 	ldr.w	pc, [sp], #4
 8000e82:	bf00      	nop
 8000e84:	0800869c 	.word	0x0800869c
	...

08000e90 <stStopAlarm>:
 * @note    This functionality is only available in free running mode, the
 *          behavior in periodic mode is undefined.
 *
 * @api
 */
void stStopAlarm(void) {
 8000e90:	b508      	push	{r3, lr}

  st_lld_stop_alarm();
 8000e92:	f7ff ffbd 	bl	8000e10 <st_lld_stop_alarm>
}
 8000e96:	bd08      	pop	{r3, pc}
	...

08000ea0 <stSetAlarm>:
 *
 * @param[in] abstime   the time to be set for the next alarm
 *
 * @api
 */
void stSetAlarm(systime_t abstime) {
 8000ea0:	b500      	push	{lr}
 8000ea2:	b083      	sub	sp, #12
 8000ea4:	9001      	str	r0, [sp, #4]

  osalDbgAssert(stIsAlarmActive() != false, "not active");
 8000ea6:	f7ff ffc3 	bl	8000e30 <st_lld_is_alarm_active>
 8000eaa:	4603      	mov	r3, r0
 8000eac:	f083 0301 	eor.w	r3, r3, #1
 8000eb0:	b2db      	uxtb	r3, r3
 8000eb2:	2b00      	cmp	r3, #0
 8000eb4:	d002      	beq.n	8000ebc <stSetAlarm+0x1c>
 8000eb6:	4804      	ldr	r0, [pc, #16]	; (8000ec8 <stSetAlarm+0x28>)
 8000eb8:	f005 fa3a 	bl	8006330 <chSysHalt>

  st_lld_set_alarm(abstime);
 8000ebc:	9801      	ldr	r0, [sp, #4]
 8000ebe:	f7ff ffaf 	bl	8000e20 <st_lld_set_alarm>
}
 8000ec2:	b003      	add	sp, #12
 8000ec4:	f85d fb04 	ldr.w	pc, [sp], #4
 8000ec8:	080086ac 	.word	0x080086ac
 8000ecc:	00000000 	.word	0x00000000

08000ed0 <port_lock.lto_priv.286>:
static inline void port_lock(void) {
 8000ed0:	b082      	sub	sp, #8
 8000ed2:	2320      	movs	r3, #32
 8000ed4:	9301      	str	r3, [sp, #4]
 8000ed6:	9b01      	ldr	r3, [sp, #4]
 8000ed8:	f383 8811 	msr	BASEPRI, r3
}
 8000edc:	b002      	add	sp, #8
 8000ede:	4770      	bx	lr

08000ee0 <port_unlock.lto_priv.245>:
static inline void port_unlock(void) {
 8000ee0:	b082      	sub	sp, #8
 8000ee2:	2300      	movs	r3, #0
 8000ee4:	9301      	str	r3, [sp, #4]
 8000ee6:	9b01      	ldr	r3, [sp, #4]
 8000ee8:	f383 8811 	msr	BASEPRI, r3
}
 8000eec:	b002      	add	sp, #8
 8000eee:	4770      	bx	lr

08000ef0 <queue_init.lto_priv.590>:
 *
 * @param[in] tqp       pointer to the threads queue object
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {
 8000ef0:	b082      	sub	sp, #8
 8000ef2:	9001      	str	r0, [sp, #4]

  tqp->next = (thread_t *)tqp;
 8000ef4:	9b01      	ldr	r3, [sp, #4]
 8000ef6:	9a01      	ldr	r2, [sp, #4]
 8000ef8:	601a      	str	r2, [r3, #0]
  tqp->prev = (thread_t *)tqp;
 8000efa:	9b01      	ldr	r3, [sp, #4]
 8000efc:	9a01      	ldr	r2, [sp, #4]
 8000efe:	605a      	str	r2, [r3, #4]
}
 8000f00:	b002      	add	sp, #8
 8000f02:	4770      	bx	lr
	...

08000f10 <chSysLock.lto_priv.400>:
static inline void chSysLock(void) {
 8000f10:	b508      	push	{r3, lr}
  port_lock();
 8000f12:	f7ff ffdd 	bl	8000ed0 <port_lock.lto_priv.286>
  _dbg_check_lock();
 8000f16:	f005 fa8b 	bl	8006430 <_dbg_check_lock>
}
 8000f1a:	bd08      	pop	{r3, pc}
 8000f1c:	0000      	movs	r0, r0
	...

08000f20 <chSysUnlock.lto_priv.367>:
static inline void chSysUnlock(void) {
 8000f20:	b508      	push	{r3, lr}
  _dbg_check_unlock();
 8000f22:	f005 fa9d 	bl	8006460 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8000f26:	4b09      	ldr	r3, [pc, #36]	; (8000f4c <chSysUnlock.lto_priv.367+0x2c>)
 8000f28:	681b      	ldr	r3, [r3, #0]
 8000f2a:	4a08      	ldr	r2, [pc, #32]	; (8000f4c <chSysUnlock.lto_priv.367+0x2c>)
 8000f2c:	4293      	cmp	r3, r2
 8000f2e:	d00a      	beq.n	8000f46 <chSysUnlock.lto_priv.367+0x26>
 8000f30:	4b06      	ldr	r3, [pc, #24]	; (8000f4c <chSysUnlock.lto_priv.367+0x2c>)
 8000f32:	699b      	ldr	r3, [r3, #24]
 8000f34:	689a      	ldr	r2, [r3, #8]
 8000f36:	4b05      	ldr	r3, [pc, #20]	; (8000f4c <chSysUnlock.lto_priv.367+0x2c>)
 8000f38:	681b      	ldr	r3, [r3, #0]
 8000f3a:	689b      	ldr	r3, [r3, #8]
 8000f3c:	429a      	cmp	r2, r3
 8000f3e:	d202      	bcs.n	8000f46 <chSysUnlock.lto_priv.367+0x26>
 8000f40:	4803      	ldr	r0, [pc, #12]	; (8000f50 <chSysUnlock.lto_priv.367+0x30>)
 8000f42:	f005 f9f5 	bl	8006330 <chSysHalt>
  port_unlock();
 8000f46:	f7ff ffcb 	bl	8000ee0 <port_unlock.lto_priv.245>
}
 8000f4a:	bd08      	pop	{r3, pc}
 8000f4c:	20000b38 	.word	0x20000b38
 8000f50:	080086dc 	.word	0x080086dc
	...

08000f60 <chThdQueueObjectInit.lto_priv.587>:
 *
 * @param[out] tqp      pointer to the threads queue object
 *
 * @init
 */
static inline void chThdQueueObjectInit(threads_queue_t *tqp) {
 8000f60:	b500      	push	{lr}
 8000f62:	b083      	sub	sp, #12
 8000f64:	9001      	str	r0, [sp, #4]

  queue_init(tqp);
 8000f66:	9801      	ldr	r0, [sp, #4]
 8000f68:	f7ff ffc2 	bl	8000ef0 <queue_init.lto_priv.590>
}
 8000f6c:	b003      	add	sp, #12
 8000f6e:	f85d fb04 	ldr.w	pc, [sp], #4
 8000f72:	bf00      	nop
	...

08000f80 <osalSysLock.lto_priv.483>:
static inline void osalSysLock(void) {
 8000f80:	b508      	push	{r3, lr}
  chSysLock();
 8000f82:	f7ff ffc5 	bl	8000f10 <chSysLock.lto_priv.400>
}
 8000f86:	bd08      	pop	{r3, pc}
	...

08000f90 <osalSysUnlock.lto_priv.472>:
static inline void osalSysUnlock(void) {
 8000f90:	b508      	push	{r3, lr}
  chSysUnlock();
 8000f92:	f7ff ffc5 	bl	8000f20 <chSysUnlock.lto_priv.367>
}
 8000f96:	bd08      	pop	{r3, pc}
	...

08000fa0 <osalThreadQueueObjectInit.lto_priv.744>:
 *
 * @param[out] tqp      pointer to the threads queue object
 *
 * @init
 */
static inline void osalThreadQueueObjectInit(threads_queue_t *tqp) {
 8000fa0:	b500      	push	{lr}
 8000fa2:	b083      	sub	sp, #12
 8000fa4:	9001      	str	r0, [sp, #4]

  chThdQueueObjectInit(tqp);
 8000fa6:	9801      	ldr	r0, [sp, #4]
 8000fa8:	f7ff ffda 	bl	8000f60 <chThdQueueObjectInit.lto_priv.587>
}
 8000fac:	b003      	add	sp, #12
 8000fae:	f85d fb04 	ldr.w	pc, [sp], #4
 8000fb2:	bf00      	nop
	...

08000fc0 <osalThreadEnqueueTimeoutS.lto_priv.742>:
 *                      specification.
 *
 * @sclass
 */
static inline msg_t osalThreadEnqueueTimeoutS(threads_queue_t *tqp,
                                              sysinterval_t timeout) {
 8000fc0:	b500      	push	{lr}
 8000fc2:	b083      	sub	sp, #12
 8000fc4:	9001      	str	r0, [sp, #4]
 8000fc6:	9100      	str	r1, [sp, #0]

  return chThdEnqueueTimeoutS(tqp, timeout);
 8000fc8:	9900      	ldr	r1, [sp, #0]
 8000fca:	9801      	ldr	r0, [sp, #4]
 8000fcc:	f006 fbb8 	bl	8007740 <chThdEnqueueTimeoutS>
 8000fd0:	4603      	mov	r3, r0
}
 8000fd2:	4618      	mov	r0, r3
 8000fd4:	b003      	add	sp, #12
 8000fd6:	f85d fb04 	ldr.w	pc, [sp], #4
 8000fda:	bf00      	nop
 8000fdc:	0000      	movs	r0, r0
	...

08000fe0 <osalThreadDequeueNextI.lto_priv.740>:
 * @param[in] tqp       pointer to the threads queue object
 * @param[in] msg       the message code
 *
 * @iclass
 */
static inline void osalThreadDequeueNextI(threads_queue_t *tqp, msg_t msg) {
 8000fe0:	b500      	push	{lr}
 8000fe2:	b083      	sub	sp, #12
 8000fe4:	9001      	str	r0, [sp, #4]
 8000fe6:	9100      	str	r1, [sp, #0]

  chThdDequeueNextI(tqp, msg);
 8000fe8:	9900      	ldr	r1, [sp, #0]
 8000fea:	9801      	ldr	r0, [sp, #4]
 8000fec:	f006 fbc8 	bl	8007780 <chThdDequeueNextI>
}
 8000ff0:	b003      	add	sp, #12
 8000ff2:	f85d fb04 	ldr.w	pc, [sp], #4
 8000ff6:	bf00      	nop
	...

08001000 <osalThreadDequeueAllI.lto_priv.726>:
 * @param[in] tqp       pointer to the threads queue object
 * @param[in] msg       the message code
 *
 * @iclass
 */
static inline void osalThreadDequeueAllI(threads_queue_t *tqp, msg_t msg) {
 8001000:	b500      	push	{lr}
 8001002:	b083      	sub	sp, #12
 8001004:	9001      	str	r0, [sp, #4]
 8001006:	9100      	str	r1, [sp, #0]

  chThdDequeueAllI(tqp, msg);
 8001008:	9900      	ldr	r1, [sp, #0]
 800100a:	9801      	ldr	r0, [sp, #4]
 800100c:	f006 fbd0 	bl	80077b0 <chThdDequeueAllI>
}
 8001010:	b003      	add	sp, #12
 8001012:	f85d fb04 	ldr.w	pc, [sp], #4
 8001016:	bf00      	nop
	...

08001020 <ibqObjectInit>:
 * @param[in] link      application defined pointer
 *
 * @init
 */
void ibqObjectInit(input_buffers_queue_t *ibqp, bool suspended, uint8_t *bp,
                   size_t size, size_t n, bqnotify_t infy, void *link) {
 8001020:	b500      	push	{lr}
 8001022:	b085      	sub	sp, #20
 8001024:	9003      	str	r0, [sp, #12]
 8001026:	9201      	str	r2, [sp, #4]
 8001028:	9300      	str	r3, [sp, #0]
 800102a:	460b      	mov	r3, r1
 800102c:	f88d 300b 	strb.w	r3, [sp, #11]

  osalDbgCheck((ibqp != NULL) && (bp != NULL) && (size >= 2U));
 8001030:	9b03      	ldr	r3, [sp, #12]
 8001032:	2b00      	cmp	r3, #0
 8001034:	d005      	beq.n	8001042 <ibqObjectInit+0x22>
 8001036:	9b01      	ldr	r3, [sp, #4]
 8001038:	2b00      	cmp	r3, #0
 800103a:	d002      	beq.n	8001042 <ibqObjectInit+0x22>
 800103c:	9b00      	ldr	r3, [sp, #0]
 800103e:	2b01      	cmp	r3, #1
 8001040:	d802      	bhi.n	8001048 <ibqObjectInit+0x28>
 8001042:	481b      	ldr	r0, [pc, #108]	; (80010b0 <ibqObjectInit+0x90>)
 8001044:	f005 f974 	bl	8006330 <chSysHalt>

  osalThreadQueueObjectInit(&ibqp->waiting);
 8001048:	9b03      	ldr	r3, [sp, #12]
 800104a:	4618      	mov	r0, r3
 800104c:	f7ff ffa8 	bl	8000fa0 <osalThreadQueueObjectInit.lto_priv.744>
  ibqp->suspended = suspended;
 8001050:	9b03      	ldr	r3, [sp, #12]
 8001052:	f89d 200b 	ldrb.w	r2, [sp, #11]
 8001056:	721a      	strb	r2, [r3, #8]
  ibqp->bcounter  = 0;
 8001058:	9b03      	ldr	r3, [sp, #12]
 800105a:	2200      	movs	r2, #0
 800105c:	60da      	str	r2, [r3, #12]
  ibqp->brdptr    = bp;
 800105e:	9b03      	ldr	r3, [sp, #12]
 8001060:	9a01      	ldr	r2, [sp, #4]
 8001062:	615a      	str	r2, [r3, #20]
  ibqp->bwrptr    = bp;
 8001064:	9b03      	ldr	r3, [sp, #12]
 8001066:	9a01      	ldr	r2, [sp, #4]
 8001068:	611a      	str	r2, [r3, #16]
  ibqp->btop      = bp + ((size + sizeof (size_t)) * n);
 800106a:	9b00      	ldr	r3, [sp, #0]
 800106c:	3304      	adds	r3, #4
 800106e:	9a06      	ldr	r2, [sp, #24]
 8001070:	fb02 f303 	mul.w	r3, r2, r3
 8001074:	9a01      	ldr	r2, [sp, #4]
 8001076:	441a      	add	r2, r3
 8001078:	9b03      	ldr	r3, [sp, #12]
 800107a:	619a      	str	r2, [r3, #24]
  ibqp->bsize     = size + sizeof (size_t);
 800107c:	9b00      	ldr	r3, [sp, #0]
 800107e:	1d1a      	adds	r2, r3, #4
 8001080:	9b03      	ldr	r3, [sp, #12]
 8001082:	61da      	str	r2, [r3, #28]
  ibqp->bn        = n;
 8001084:	9b03      	ldr	r3, [sp, #12]
 8001086:	9a06      	ldr	r2, [sp, #24]
 8001088:	621a      	str	r2, [r3, #32]
  ibqp->buffers   = bp;
 800108a:	9b03      	ldr	r3, [sp, #12]
 800108c:	9a01      	ldr	r2, [sp, #4]
 800108e:	625a      	str	r2, [r3, #36]	; 0x24
  ibqp->ptr       = NULL;
 8001090:	9b03      	ldr	r3, [sp, #12]
 8001092:	2200      	movs	r2, #0
 8001094:	629a      	str	r2, [r3, #40]	; 0x28
  ibqp->top       = NULL;
 8001096:	9b03      	ldr	r3, [sp, #12]
 8001098:	2200      	movs	r2, #0
 800109a:	62da      	str	r2, [r3, #44]	; 0x2c
  ibqp->notify    = infy;
 800109c:	9b03      	ldr	r3, [sp, #12]
 800109e:	9a07      	ldr	r2, [sp, #28]
 80010a0:	631a      	str	r2, [r3, #48]	; 0x30
  ibqp->link      = link;
 80010a2:	9b03      	ldr	r3, [sp, #12]
 80010a4:	9a08      	ldr	r2, [sp, #32]
 80010a6:	635a      	str	r2, [r3, #52]	; 0x34
}
 80010a8:	b005      	add	sp, #20
 80010aa:	f85d fb04 	ldr.w	pc, [sp], #4
 80010ae:	bf00      	nop
 80010b0:	080086b8 	.word	0x080086b8
	...

080010c0 <ibqResetI>:
 *
 * @param[in] ibqp      pointer to the @p input_buffers_queue_t object
 *
 * @iclass
 */
void ibqResetI(input_buffers_queue_t *ibqp) {
 80010c0:	b500      	push	{lr}
 80010c2:	b083      	sub	sp, #12
 80010c4:	9001      	str	r0, [sp, #4]

  osalDbgCheckClassI();
 80010c6:	f005 fa53 	bl	8006570 <chDbgCheckClassI>

  ibqp->bcounter  = 0;
 80010ca:	9b01      	ldr	r3, [sp, #4]
 80010cc:	2200      	movs	r2, #0
 80010ce:	60da      	str	r2, [r3, #12]
  ibqp->brdptr    = ibqp->buffers;
 80010d0:	9b01      	ldr	r3, [sp, #4]
 80010d2:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 80010d4:	9b01      	ldr	r3, [sp, #4]
 80010d6:	615a      	str	r2, [r3, #20]
  ibqp->bwrptr    = ibqp->buffers;
 80010d8:	9b01      	ldr	r3, [sp, #4]
 80010da:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 80010dc:	9b01      	ldr	r3, [sp, #4]
 80010de:	611a      	str	r2, [r3, #16]
  ibqp->ptr       = NULL;
 80010e0:	9b01      	ldr	r3, [sp, #4]
 80010e2:	2200      	movs	r2, #0
 80010e4:	629a      	str	r2, [r3, #40]	; 0x28
  ibqp->top       = NULL;
 80010e6:	9b01      	ldr	r3, [sp, #4]
 80010e8:	2200      	movs	r2, #0
 80010ea:	62da      	str	r2, [r3, #44]	; 0x2c
  osalThreadDequeueAllI(&ibqp->waiting, MSG_RESET);
 80010ec:	9b01      	ldr	r3, [sp, #4]
 80010ee:	f06f 0101 	mvn.w	r1, #1
 80010f2:	4618      	mov	r0, r3
 80010f4:	f7ff ff84 	bl	8001000 <osalThreadDequeueAllI.lto_priv.726>
}
 80010f8:	b003      	add	sp, #12
 80010fa:	f85d fb04 	ldr.w	pc, [sp], #4
 80010fe:	bf00      	nop

08001100 <ibqGetEmptyBufferI>:
 * @return              A pointer to the next buffer to be filled.
 * @retval NULL         if the queue is full.
 *
 * @iclass
 */
uint8_t *ibqGetEmptyBufferI(input_buffers_queue_t *ibqp) {
 8001100:	b500      	push	{lr}
 8001102:	b083      	sub	sp, #12
 8001104:	9001      	str	r0, [sp, #4]

  osalDbgCheckClassI();
 8001106:	f005 fa33 	bl	8006570 <chDbgCheckClassI>

  if (ibqIsFullI(ibqp)) {
 800110a:	9b01      	ldr	r3, [sp, #4]
 800110c:	691a      	ldr	r2, [r3, #16]
 800110e:	9b01      	ldr	r3, [sp, #4]
 8001110:	695b      	ldr	r3, [r3, #20]
 8001112:	429a      	cmp	r2, r3
 8001114:	d105      	bne.n	8001122 <ibqGetEmptyBufferI+0x22>
 8001116:	9b01      	ldr	r3, [sp, #4]
 8001118:	68db      	ldr	r3, [r3, #12]
 800111a:	2b00      	cmp	r3, #0
 800111c:	d001      	beq.n	8001122 <ibqGetEmptyBufferI+0x22>
 800111e:	2301      	movs	r3, #1
 8001120:	e000      	b.n	8001124 <ibqGetEmptyBufferI+0x24>
 8001122:	2300      	movs	r3, #0
 8001124:	f003 0301 	and.w	r3, r3, #1
 8001128:	b2db      	uxtb	r3, r3
 800112a:	2b00      	cmp	r3, #0
 800112c:	d001      	beq.n	8001132 <ibqGetEmptyBufferI+0x32>
    return NULL;
 800112e:	2300      	movs	r3, #0
 8001130:	e002      	b.n	8001138 <ibqGetEmptyBufferI+0x38>
  }

  return ibqp->bwrptr + sizeof (size_t);
 8001132:	9b01      	ldr	r3, [sp, #4]
 8001134:	691b      	ldr	r3, [r3, #16]
 8001136:	3304      	adds	r3, #4
}
 8001138:	4618      	mov	r0, r3
 800113a:	b003      	add	sp, #12
 800113c:	f85d fb04 	ldr.w	pc, [sp], #4

08001140 <ibqPostFullBufferI>:
 * @param[in] ibqp      pointer to the @p input_buffers_queue_t object
 * @param[in] size      used size of the buffer, cannot be zero
 *
 * @iclass
 */
void ibqPostFullBufferI(input_buffers_queue_t *ibqp, size_t size) {
 8001140:	b500      	push	{lr}
 8001142:	b083      	sub	sp, #12
 8001144:	9001      	str	r0, [sp, #4]
 8001146:	9100      	str	r1, [sp, #0]

  osalDbgCheckClassI();
 8001148:	f005 fa12 	bl	8006570 <chDbgCheckClassI>

  osalDbgCheck((size > 0U) && (size <= (ibqp->bsize - sizeof (size_t))));
 800114c:	9b00      	ldr	r3, [sp, #0]
 800114e:	2b00      	cmp	r3, #0
 8001150:	d005      	beq.n	800115e <ibqPostFullBufferI+0x1e>
 8001152:	9b01      	ldr	r3, [sp, #4]
 8001154:	69db      	ldr	r3, [r3, #28]
 8001156:	3b04      	subs	r3, #4
 8001158:	9a00      	ldr	r2, [sp, #0]
 800115a:	429a      	cmp	r2, r3
 800115c:	d902      	bls.n	8001164 <ibqPostFullBufferI+0x24>
 800115e:	481d      	ldr	r0, [pc, #116]	; (80011d4 <ibqPostFullBufferI+0x94>)
 8001160:	f005 f8e6 	bl	8006330 <chSysHalt>
  osalDbgAssert(!ibqIsFullI(ibqp), "buffers queue full");
 8001164:	9b01      	ldr	r3, [sp, #4]
 8001166:	691a      	ldr	r2, [r3, #16]
 8001168:	9b01      	ldr	r3, [sp, #4]
 800116a:	695b      	ldr	r3, [r3, #20]
 800116c:	429a      	cmp	r2, r3
 800116e:	d105      	bne.n	800117c <ibqPostFullBufferI+0x3c>
 8001170:	9b01      	ldr	r3, [sp, #4]
 8001172:	68db      	ldr	r3, [r3, #12]
 8001174:	2b00      	cmp	r3, #0
 8001176:	d001      	beq.n	800117c <ibqPostFullBufferI+0x3c>
 8001178:	2301      	movs	r3, #1
 800117a:	e000      	b.n	800117e <ibqPostFullBufferI+0x3e>
 800117c:	2300      	movs	r3, #0
 800117e:	f003 0301 	and.w	r3, r3, #1
 8001182:	b2db      	uxtb	r3, r3
 8001184:	2b00      	cmp	r3, #0
 8001186:	d002      	beq.n	800118e <ibqPostFullBufferI+0x4e>
 8001188:	4812      	ldr	r0, [pc, #72]	; (80011d4 <ibqPostFullBufferI+0x94>)
 800118a:	f005 f8d1 	bl	8006330 <chSysHalt>

  /* Writing size field in the buffer.*/
  *((size_t *)ibqp->bwrptr) = size;
 800118e:	9b01      	ldr	r3, [sp, #4]
 8001190:	691b      	ldr	r3, [r3, #16]
 8001192:	9a00      	ldr	r2, [sp, #0]
 8001194:	601a      	str	r2, [r3, #0]

  /* Posting the buffer in the queue.*/
  ibqp->bcounter++;
 8001196:	9b01      	ldr	r3, [sp, #4]
 8001198:	68db      	ldr	r3, [r3, #12]
 800119a:	1c5a      	adds	r2, r3, #1
 800119c:	9b01      	ldr	r3, [sp, #4]
 800119e:	60da      	str	r2, [r3, #12]
  ibqp->bwrptr += ibqp->bsize;
 80011a0:	9b01      	ldr	r3, [sp, #4]
 80011a2:	691a      	ldr	r2, [r3, #16]
 80011a4:	9b01      	ldr	r3, [sp, #4]
 80011a6:	69db      	ldr	r3, [r3, #28]
 80011a8:	441a      	add	r2, r3
 80011aa:	9b01      	ldr	r3, [sp, #4]
 80011ac:	611a      	str	r2, [r3, #16]
  if (ibqp->bwrptr >= ibqp->btop) {
 80011ae:	9b01      	ldr	r3, [sp, #4]
 80011b0:	691a      	ldr	r2, [r3, #16]
 80011b2:	9b01      	ldr	r3, [sp, #4]
 80011b4:	699b      	ldr	r3, [r3, #24]
 80011b6:	429a      	cmp	r2, r3
 80011b8:	d303      	bcc.n	80011c2 <ibqPostFullBufferI+0x82>
    ibqp->bwrptr = ibqp->buffers;
 80011ba:	9b01      	ldr	r3, [sp, #4]
 80011bc:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 80011be:	9b01      	ldr	r3, [sp, #4]
 80011c0:	611a      	str	r2, [r3, #16]
  }

  /* Waking up one waiting thread, if any.*/
  osalThreadDequeueNextI(&ibqp->waiting, MSG_OK);
 80011c2:	9b01      	ldr	r3, [sp, #4]
 80011c4:	2100      	movs	r1, #0
 80011c6:	4618      	mov	r0, r3
 80011c8:	f7ff ff0a 	bl	8000fe0 <osalThreadDequeueNextI.lto_priv.740>
}
 80011cc:	b003      	add	sp, #12
 80011ce:	f85d fb04 	ldr.w	pc, [sp], #4
 80011d2:	bf00      	nop
 80011d4:	080086c8 	.word	0x080086c8
	...

080011e0 <ibqGetFullBufferTimeoutS>:
   *                      suspended state.
   *
   * @sclass
   */
  msg_t ibqGetFullBufferTimeoutS(input_buffers_queue_t *ibqp,
                                 sysinterval_t timeout) {
 80011e0:	b500      	push	{lr}
 80011e2:	b085      	sub	sp, #20
 80011e4:	9001      	str	r0, [sp, #4]
 80011e6:	9100      	str	r1, [sp, #0]

  osalDbgCheckClassS();
 80011e8:	f005 f9da 	bl	80065a0 <chDbgCheckClassS>
 80011ec:	e011      	b.n	8001212 <ibqGetFullBufferTimeoutS+0x32>

  while (ibqIsEmptyI(ibqp)) {
    if (ibqp->suspended) {
 80011ee:	9b01      	ldr	r3, [sp, #4]
 80011f0:	7a1b      	ldrb	r3, [r3, #8]
 80011f2:	2b00      	cmp	r3, #0
 80011f4:	d002      	beq.n	80011fc <ibqGetFullBufferTimeoutS+0x1c>
      return MSG_RESET;
 80011f6:	f06f 0301 	mvn.w	r3, #1
 80011fa:	e023      	b.n	8001244 <ibqGetFullBufferTimeoutS+0x64>
    }
    msg_t msg = osalThreadEnqueueTimeoutS(&ibqp->waiting, timeout);
 80011fc:	9b01      	ldr	r3, [sp, #4]
 80011fe:	9900      	ldr	r1, [sp, #0]
 8001200:	4618      	mov	r0, r3
 8001202:	f7ff fedd 	bl	8000fc0 <osalThreadEnqueueTimeoutS.lto_priv.742>
 8001206:	9003      	str	r0, [sp, #12]
    if (msg < MSG_OK) {
 8001208:	9b03      	ldr	r3, [sp, #12]
 800120a:	2b00      	cmp	r3, #0
 800120c:	da01      	bge.n	8001212 <ibqGetFullBufferTimeoutS+0x32>
       return msg;
 800120e:	9b03      	ldr	r3, [sp, #12]
 8001210:	e018      	b.n	8001244 <ibqGetFullBufferTimeoutS+0x64>
  while (ibqIsEmptyI(ibqp)) {
 8001212:	9b01      	ldr	r3, [sp, #4]
 8001214:	68db      	ldr	r3, [r3, #12]
 8001216:	2b00      	cmp	r3, #0
 8001218:	d0e9      	beq.n	80011ee <ibqGetFullBufferTimeoutS+0xe>
    }
  }

  osalDbgAssert(!ibqIsEmptyI(ibqp), "still empty");
 800121a:	9b01      	ldr	r3, [sp, #4]
 800121c:	68db      	ldr	r3, [r3, #12]
 800121e:	2b00      	cmp	r3, #0
 8001220:	d102      	bne.n	8001228 <ibqGetFullBufferTimeoutS+0x48>
 8001222:	480a      	ldr	r0, [pc, #40]	; (800124c <ibqGetFullBufferTimeoutS+0x6c>)
 8001224:	f005 f884 	bl	8006330 <chSysHalt>

  /* Setting up the "current" buffer and its boundary.*/
  ibqp->ptr = ibqp->brdptr + sizeof (size_t);
 8001228:	9b01      	ldr	r3, [sp, #4]
 800122a:	695b      	ldr	r3, [r3, #20]
 800122c:	1d1a      	adds	r2, r3, #4
 800122e:	9b01      	ldr	r3, [sp, #4]
 8001230:	629a      	str	r2, [r3, #40]	; 0x28
  ibqp->top = ibqp->ptr + *((size_t *)ibqp->brdptr);
 8001232:	9b01      	ldr	r3, [sp, #4]
 8001234:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 8001236:	9b01      	ldr	r3, [sp, #4]
 8001238:	695b      	ldr	r3, [r3, #20]
 800123a:	681b      	ldr	r3, [r3, #0]
 800123c:	441a      	add	r2, r3
 800123e:	9b01      	ldr	r3, [sp, #4]
 8001240:	62da      	str	r2, [r3, #44]	; 0x2c

  return MSG_OK;
 8001242:	2300      	movs	r3, #0
}
 8001244:	4618      	mov	r0, r3
 8001246:	b005      	add	sp, #20
 8001248:	f85d fb04 	ldr.w	pc, [sp], #4
 800124c:	080086e8 	.word	0x080086e8

08001250 <ibqReleaseEmptyBufferS>:
   *
   * @param[in] ibqp      pointer to the @p input_buffers_queue_t object
   *
   * @sclass
   */
  void ibqReleaseEmptyBufferS(input_buffers_queue_t *ibqp) {
 8001250:	b500      	push	{lr}
 8001252:	b083      	sub	sp, #12
 8001254:	9001      	str	r0, [sp, #4]

  osalDbgCheckClassS();
 8001256:	f005 f9a3 	bl	80065a0 <chDbgCheckClassS>
  osalDbgAssert(!ibqIsEmptyI(ibqp), "buffers queue empty");
 800125a:	9b01      	ldr	r3, [sp, #4]
 800125c:	68db      	ldr	r3, [r3, #12]
 800125e:	2b00      	cmp	r3, #0
 8001260:	d102      	bne.n	8001268 <ibqReleaseEmptyBufferS+0x18>
 8001262:	4813      	ldr	r0, [pc, #76]	; (80012b0 <ibqReleaseEmptyBufferS+0x60>)
 8001264:	f005 f864 	bl	8006330 <chSysHalt>

  /* Freeing a buffer slot in the queue.*/
  ibqp->bcounter--;
 8001268:	9b01      	ldr	r3, [sp, #4]
 800126a:	68db      	ldr	r3, [r3, #12]
 800126c:	1e5a      	subs	r2, r3, #1
 800126e:	9b01      	ldr	r3, [sp, #4]
 8001270:	60da      	str	r2, [r3, #12]
  ibqp->brdptr += ibqp->bsize;
 8001272:	9b01      	ldr	r3, [sp, #4]
 8001274:	695a      	ldr	r2, [r3, #20]
 8001276:	9b01      	ldr	r3, [sp, #4]
 8001278:	69db      	ldr	r3, [r3, #28]
 800127a:	441a      	add	r2, r3
 800127c:	9b01      	ldr	r3, [sp, #4]
 800127e:	615a      	str	r2, [r3, #20]
  if (ibqp->brdptr >= ibqp->btop) {
 8001280:	9b01      	ldr	r3, [sp, #4]
 8001282:	695a      	ldr	r2, [r3, #20]
 8001284:	9b01      	ldr	r3, [sp, #4]
 8001286:	699b      	ldr	r3, [r3, #24]
 8001288:	429a      	cmp	r2, r3
 800128a:	d303      	bcc.n	8001294 <ibqReleaseEmptyBufferS+0x44>
    ibqp->brdptr = ibqp->buffers;
 800128c:	9b01      	ldr	r3, [sp, #4]
 800128e:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8001290:	9b01      	ldr	r3, [sp, #4]
 8001292:	615a      	str	r2, [r3, #20]
  }

  /* No "current" buffer.*/
  ibqp->ptr = NULL;
 8001294:	9b01      	ldr	r3, [sp, #4]
 8001296:	2200      	movs	r2, #0
 8001298:	629a      	str	r2, [r3, #40]	; 0x28

  /* Notifying the buffer release.*/
  if (ibqp->notify != NULL) {
 800129a:	9b01      	ldr	r3, [sp, #4]
 800129c:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800129e:	2b00      	cmp	r3, #0
 80012a0:	d003      	beq.n	80012aa <ibqReleaseEmptyBufferS+0x5a>
    ibqp->notify(ibqp);
 80012a2:	9b01      	ldr	r3, [sp, #4]
 80012a4:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80012a6:	9801      	ldr	r0, [sp, #4]
 80012a8:	4798      	blx	r3
  }
}
 80012aa:	b003      	add	sp, #12
 80012ac:	f85d fb04 	ldr.w	pc, [sp], #4
 80012b0:	08008704 	.word	0x08008704
	...

080012c0 <ibqGetTimeout>:
 * @retval MSG_RESET    if the queue has been reset or has been put in
 *                      suspended state.
 *
 * @api
 */
msg_t ibqGetTimeout(input_buffers_queue_t *ibqp, sysinterval_t timeout) {
 80012c0:	b500      	push	{lr}
 80012c2:	b085      	sub	sp, #20
 80012c4:	9001      	str	r0, [sp, #4]
 80012c6:	9100      	str	r1, [sp, #0]
  msg_t msg;

  osalSysLock();
 80012c8:	f7ff fe5a 	bl	8000f80 <osalSysLock.lto_priv.483>

  /* This condition indicates that a new buffer must be acquired.*/
  if (ibqp->ptr == NULL) {
 80012cc:	9b01      	ldr	r3, [sp, #4]
 80012ce:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 80012d0:	2b00      	cmp	r3, #0
 80012d2:	d10b      	bne.n	80012ec <ibqGetTimeout+0x2c>
    msg = ibqGetFullBufferTimeoutS(ibqp, timeout);
 80012d4:	9900      	ldr	r1, [sp, #0]
 80012d6:	9801      	ldr	r0, [sp, #4]
 80012d8:	f7ff ff82 	bl	80011e0 <ibqGetFullBufferTimeoutS>
 80012dc:	9003      	str	r0, [sp, #12]
    if (msg != MSG_OK) {
 80012de:	9b03      	ldr	r3, [sp, #12]
 80012e0:	2b00      	cmp	r3, #0
 80012e2:	d003      	beq.n	80012ec <ibqGetTimeout+0x2c>
      osalSysUnlock();
 80012e4:	f7ff fe54 	bl	8000f90 <osalSysUnlock.lto_priv.472>
      return msg;
 80012e8:	9b03      	ldr	r3, [sp, #12]
 80012ea:	e014      	b.n	8001316 <ibqGetTimeout+0x56>
    }
  }

  /* Next byte from the buffer.*/
  msg = (msg_t)*ibqp->ptr;
 80012ec:	9b01      	ldr	r3, [sp, #4]
 80012ee:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 80012f0:	781b      	ldrb	r3, [r3, #0]
 80012f2:	9303      	str	r3, [sp, #12]
  ibqp->ptr++;
 80012f4:	9b01      	ldr	r3, [sp, #4]
 80012f6:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 80012f8:	1c5a      	adds	r2, r3, #1
 80012fa:	9b01      	ldr	r3, [sp, #4]
 80012fc:	629a      	str	r2, [r3, #40]	; 0x28

  /* If the current buffer has been fully read then it is returned as
     empty in the queue.*/
  if (ibqp->ptr >= ibqp->top) {
 80012fe:	9b01      	ldr	r3, [sp, #4]
 8001300:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 8001302:	9b01      	ldr	r3, [sp, #4]
 8001304:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8001306:	429a      	cmp	r2, r3
 8001308:	d302      	bcc.n	8001310 <ibqGetTimeout+0x50>
    ibqReleaseEmptyBufferS(ibqp);
 800130a:	9801      	ldr	r0, [sp, #4]
 800130c:	f7ff ffa0 	bl	8001250 <ibqReleaseEmptyBufferS>
  }

  osalSysUnlock();
 8001310:	f7ff fe3e 	bl	8000f90 <osalSysUnlock.lto_priv.472>
  return msg;
 8001314:	9b03      	ldr	r3, [sp, #12]
}
 8001316:	4618      	mov	r0, r3
 8001318:	b005      	add	sp, #20
 800131a:	f85d fb04 	ldr.w	pc, [sp], #4
 800131e:	bf00      	nop

08001320 <ibqReadTimeout>:
 * @retval 0            if a timeout occurred.
 *
 * @api
 */
size_t ibqReadTimeout(input_buffers_queue_t *ibqp, uint8_t *bp,
                      size_t n, sysinterval_t timeout) {
 8001320:	b500      	push	{lr}
 8001322:	b089      	sub	sp, #36	; 0x24
 8001324:	9003      	str	r0, [sp, #12]
 8001326:	9102      	str	r1, [sp, #8]
 8001328:	9201      	str	r2, [sp, #4]
 800132a:	9300      	str	r3, [sp, #0]
  size_t r = 0;
 800132c:	2300      	movs	r3, #0
 800132e:	9307      	str	r3, [sp, #28]

  osalDbgCheck(n > 0U);
 8001330:	9b01      	ldr	r3, [sp, #4]
 8001332:	2b00      	cmp	r3, #0
 8001334:	d102      	bne.n	800133c <ibqReadTimeout+0x1c>
 8001336:	4835      	ldr	r0, [pc, #212]	; (800140c <ibqReadTimeout+0xec>)
 8001338:	f004 fffa 	bl	8006330 <chSysHalt>

  osalSysLock();
 800133c:	f7ff fe20 	bl	8000f80 <osalSysLock.lto_priv.483>

  while (true) {
    size_t size;

    /* This condition indicates that a new buffer must be acquired.*/
    if (ibqp->ptr == NULL) {
 8001340:	9b03      	ldr	r3, [sp, #12]
 8001342:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8001344:	2b00      	cmp	r3, #0
 8001346:	d10b      	bne.n	8001360 <ibqReadTimeout+0x40>
      msg_t msg;

      /* Getting a data buffer using the specified timeout.*/
      msg = ibqGetFullBufferTimeoutS(ibqp, timeout);
 8001348:	9900      	ldr	r1, [sp, #0]
 800134a:	9803      	ldr	r0, [sp, #12]
 800134c:	f7ff ff48 	bl	80011e0 <ibqGetFullBufferTimeoutS>
 8001350:	9005      	str	r0, [sp, #20]

      /* Anything except MSG_OK interrupts the operation.*/
      if (msg != MSG_OK) {
 8001352:	9b05      	ldr	r3, [sp, #20]
 8001354:	2b00      	cmp	r3, #0
 8001356:	d003      	beq.n	8001360 <ibqReadTimeout+0x40>
        osalSysUnlock();
 8001358:	f7ff fe1a 	bl	8000f90 <osalSysUnlock.lto_priv.472>
        return r;
 800135c:	9b07      	ldr	r3, [sp, #28]
 800135e:	e050      	b.n	8001402 <ibqReadTimeout+0xe2>
      }
    }

    /* Size of the data chunk present in the current buffer.*/
    size = (size_t)ibqp->top - (size_t)ibqp->ptr;
 8001360:	9b03      	ldr	r3, [sp, #12]
 8001362:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8001364:	461a      	mov	r2, r3
 8001366:	9b03      	ldr	r3, [sp, #12]
 8001368:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800136a:	1ad3      	subs	r3, r2, r3
 800136c:	9306      	str	r3, [sp, #24]
    if (size > (n - r)) {
 800136e:	9a01      	ldr	r2, [sp, #4]
 8001370:	9b07      	ldr	r3, [sp, #28]
 8001372:	1ad3      	subs	r3, r2, r3
 8001374:	9a06      	ldr	r2, [sp, #24]
 8001376:	429a      	cmp	r2, r3
 8001378:	d903      	bls.n	8001382 <ibqReadTimeout+0x62>
      size = n - r;
 800137a:	9a01      	ldr	r2, [sp, #4]
 800137c:	9b07      	ldr	r3, [sp, #28]
 800137e:	1ad3      	subs	r3, r2, r3
 8001380:	9306      	str	r3, [sp, #24]
    }

    /* Smaller chunks in order to not make the critical zone too long,
       this impacts throughput however.*/
    if (size > (size_t)BUFFERS_CHUNKS_SIZE) {
 8001382:	9b06      	ldr	r3, [sp, #24]
 8001384:	2b40      	cmp	r3, #64	; 0x40
 8001386:	d913      	bls.n	80013b0 <ibqReadTimeout+0x90>
      /* Giving the compiler a chance to optimize for a fixed size move.*/
      memcpy(bp, ibqp->ptr, BUFFERS_CHUNKS_SIZE);
 8001388:	9b03      	ldr	r3, [sp, #12]
 800138a:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800138c:	2240      	movs	r2, #64	; 0x40
 800138e:	4619      	mov	r1, r3
 8001390:	9802      	ldr	r0, [sp, #8]
 8001392:	f7fe ffb7 	bl	8000304 <memcpy>
      bp        += (size_t)BUFFERS_CHUNKS_SIZE;
 8001396:	9b02      	ldr	r3, [sp, #8]
 8001398:	3340      	adds	r3, #64	; 0x40
 800139a:	9302      	str	r3, [sp, #8]
      ibqp->ptr += (size_t)BUFFERS_CHUNKS_SIZE;
 800139c:	9b03      	ldr	r3, [sp, #12]
 800139e:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 80013a0:	f103 0240 	add.w	r2, r3, #64	; 0x40
 80013a4:	9b03      	ldr	r3, [sp, #12]
 80013a6:	629a      	str	r2, [r3, #40]	; 0x28
      r         += (size_t)BUFFERS_CHUNKS_SIZE;
 80013a8:	9b07      	ldr	r3, [sp, #28]
 80013aa:	3340      	adds	r3, #64	; 0x40
 80013ac:	9307      	str	r3, [sp, #28]
 80013ae:	e014      	b.n	80013da <ibqReadTimeout+0xba>
    }
    else {
      memcpy(bp, ibqp->ptr, size);
 80013b0:	9b03      	ldr	r3, [sp, #12]
 80013b2:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 80013b4:	9a06      	ldr	r2, [sp, #24]
 80013b6:	4619      	mov	r1, r3
 80013b8:	9802      	ldr	r0, [sp, #8]
 80013ba:	f7fe ffa3 	bl	8000304 <memcpy>
      bp        += size;
 80013be:	9a02      	ldr	r2, [sp, #8]
 80013c0:	9b06      	ldr	r3, [sp, #24]
 80013c2:	4413      	add	r3, r2
 80013c4:	9302      	str	r3, [sp, #8]
      ibqp->ptr += size;
 80013c6:	9b03      	ldr	r3, [sp, #12]
 80013c8:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 80013ca:	9b06      	ldr	r3, [sp, #24]
 80013cc:	441a      	add	r2, r3
 80013ce:	9b03      	ldr	r3, [sp, #12]
 80013d0:	629a      	str	r2, [r3, #40]	; 0x28
      r         += size;
 80013d2:	9a07      	ldr	r2, [sp, #28]
 80013d4:	9b06      	ldr	r3, [sp, #24]
 80013d6:	4413      	add	r3, r2
 80013d8:	9307      	str	r3, [sp, #28]
    }

    /* Has the current data buffer been finished? if so then release it.*/
    if (ibqp->ptr >= ibqp->top) {
 80013da:	9b03      	ldr	r3, [sp, #12]
 80013dc:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 80013de:	9b03      	ldr	r3, [sp, #12]
 80013e0:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80013e2:	429a      	cmp	r2, r3
 80013e4:	d302      	bcc.n	80013ec <ibqReadTimeout+0xcc>
      ibqReleaseEmptyBufferS(ibqp);
 80013e6:	9803      	ldr	r0, [sp, #12]
 80013e8:	f7ff ff32 	bl	8001250 <ibqReleaseEmptyBufferS>
    }

    /* Giving a preemption chance.*/
    osalSysUnlock();
 80013ec:	f7ff fdd0 	bl	8000f90 <osalSysUnlock.lto_priv.472>
    if (r >= n) {
 80013f0:	9a07      	ldr	r2, [sp, #28]
 80013f2:	9b01      	ldr	r3, [sp, #4]
 80013f4:	429a      	cmp	r2, r3
 80013f6:	d301      	bcc.n	80013fc <ibqReadTimeout+0xdc>
      return r;
 80013f8:	9b07      	ldr	r3, [sp, #28]
 80013fa:	e002      	b.n	8001402 <ibqReadTimeout+0xe2>
    }
    osalSysLock();
 80013fc:	f7ff fdc0 	bl	8000f80 <osalSysLock.lto_priv.483>
 8001400:	e79e      	b.n	8001340 <ibqReadTimeout+0x20>
  }
}
 8001402:	4618      	mov	r0, r3
 8001404:	b009      	add	sp, #36	; 0x24
 8001406:	f85d fb04 	ldr.w	pc, [sp], #4
 800140a:	bf00      	nop
 800140c:	0800871c 	.word	0x0800871c

08001410 <obqObjectInit>:
 * @param[in] link      application defined pointer
 *
 * @init
 */
void obqObjectInit(output_buffers_queue_t *obqp, bool suspended, uint8_t *bp,
                   size_t size, size_t n, bqnotify_t onfy, void *link) {
 8001410:	b500      	push	{lr}
 8001412:	b085      	sub	sp, #20
 8001414:	9003      	str	r0, [sp, #12]
 8001416:	9201      	str	r2, [sp, #4]
 8001418:	9300      	str	r3, [sp, #0]
 800141a:	460b      	mov	r3, r1
 800141c:	f88d 300b 	strb.w	r3, [sp, #11]

  osalDbgCheck((obqp != NULL) && (bp != NULL) && (size >= 2U));
 8001420:	9b03      	ldr	r3, [sp, #12]
 8001422:	2b00      	cmp	r3, #0
 8001424:	d005      	beq.n	8001432 <obqObjectInit+0x22>
 8001426:	9b01      	ldr	r3, [sp, #4]
 8001428:	2b00      	cmp	r3, #0
 800142a:	d002      	beq.n	8001432 <obqObjectInit+0x22>
 800142c:	9b00      	ldr	r3, [sp, #0]
 800142e:	2b01      	cmp	r3, #1
 8001430:	d802      	bhi.n	8001438 <obqObjectInit+0x28>
 8001432:	481b      	ldr	r0, [pc, #108]	; (80014a0 <obqObjectInit+0x90>)
 8001434:	f004 ff7c 	bl	8006330 <chSysHalt>

  osalThreadQueueObjectInit(&obqp->waiting);
 8001438:	9b03      	ldr	r3, [sp, #12]
 800143a:	4618      	mov	r0, r3
 800143c:	f7ff fdb0 	bl	8000fa0 <osalThreadQueueObjectInit.lto_priv.744>
  obqp->suspended = suspended;
 8001440:	9b03      	ldr	r3, [sp, #12]
 8001442:	f89d 200b 	ldrb.w	r2, [sp, #11]
 8001446:	721a      	strb	r2, [r3, #8]
  obqp->bcounter  = n;
 8001448:	9b03      	ldr	r3, [sp, #12]
 800144a:	9a06      	ldr	r2, [sp, #24]
 800144c:	60da      	str	r2, [r3, #12]
  obqp->brdptr    = bp;
 800144e:	9b03      	ldr	r3, [sp, #12]
 8001450:	9a01      	ldr	r2, [sp, #4]
 8001452:	615a      	str	r2, [r3, #20]
  obqp->bwrptr    = bp;
 8001454:	9b03      	ldr	r3, [sp, #12]
 8001456:	9a01      	ldr	r2, [sp, #4]
 8001458:	611a      	str	r2, [r3, #16]
  obqp->btop      = bp + ((size + sizeof (size_t)) * n);
 800145a:	9b00      	ldr	r3, [sp, #0]
 800145c:	3304      	adds	r3, #4
 800145e:	9a06      	ldr	r2, [sp, #24]
 8001460:	fb02 f303 	mul.w	r3, r2, r3
 8001464:	9a01      	ldr	r2, [sp, #4]
 8001466:	441a      	add	r2, r3
 8001468:	9b03      	ldr	r3, [sp, #12]
 800146a:	619a      	str	r2, [r3, #24]
  obqp->bsize     = size + sizeof (size_t);
 800146c:	9b00      	ldr	r3, [sp, #0]
 800146e:	1d1a      	adds	r2, r3, #4
 8001470:	9b03      	ldr	r3, [sp, #12]
 8001472:	61da      	str	r2, [r3, #28]
  obqp->bn        = n;
 8001474:	9b03      	ldr	r3, [sp, #12]
 8001476:	9a06      	ldr	r2, [sp, #24]
 8001478:	621a      	str	r2, [r3, #32]
  obqp->buffers   = bp;
 800147a:	9b03      	ldr	r3, [sp, #12]
 800147c:	9a01      	ldr	r2, [sp, #4]
 800147e:	625a      	str	r2, [r3, #36]	; 0x24
  obqp->ptr       = NULL;
 8001480:	9b03      	ldr	r3, [sp, #12]
 8001482:	2200      	movs	r2, #0
 8001484:	629a      	str	r2, [r3, #40]	; 0x28
  obqp->top       = NULL;
 8001486:	9b03      	ldr	r3, [sp, #12]
 8001488:	2200      	movs	r2, #0
 800148a:	62da      	str	r2, [r3, #44]	; 0x2c
  obqp->notify    = onfy;
 800148c:	9b03      	ldr	r3, [sp, #12]
 800148e:	9a07      	ldr	r2, [sp, #28]
 8001490:	631a      	str	r2, [r3, #48]	; 0x30
  obqp->link      = link;
 8001492:	9b03      	ldr	r3, [sp, #12]
 8001494:	9a08      	ldr	r2, [sp, #32]
 8001496:	635a      	str	r2, [r3, #52]	; 0x34
}
 8001498:	b005      	add	sp, #20
 800149a:	f85d fb04 	ldr.w	pc, [sp], #4
 800149e:	bf00      	nop
 80014a0:	0800872c 	.word	0x0800872c
	...

080014b0 <obqResetI>:
 *
 * @param[in] obqp      pointer to the @p output_buffers_queue_t object
 *
 * @iclass
 */
void obqResetI(output_buffers_queue_t *obqp) {
 80014b0:	b500      	push	{lr}
 80014b2:	b083      	sub	sp, #12
 80014b4:	9001      	str	r0, [sp, #4]

  osalDbgCheckClassI();
 80014b6:	f005 f85b 	bl	8006570 <chDbgCheckClassI>

  obqp->bcounter  = bqSizeX(obqp);
 80014ba:	9b01      	ldr	r3, [sp, #4]
 80014bc:	6a1a      	ldr	r2, [r3, #32]
 80014be:	9b01      	ldr	r3, [sp, #4]
 80014c0:	60da      	str	r2, [r3, #12]
  obqp->brdptr    = obqp->buffers;
 80014c2:	9b01      	ldr	r3, [sp, #4]
 80014c4:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 80014c6:	9b01      	ldr	r3, [sp, #4]
 80014c8:	615a      	str	r2, [r3, #20]
  obqp->bwrptr    = obqp->buffers;
 80014ca:	9b01      	ldr	r3, [sp, #4]
 80014cc:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 80014ce:	9b01      	ldr	r3, [sp, #4]
 80014d0:	611a      	str	r2, [r3, #16]
  obqp->ptr       = NULL;
 80014d2:	9b01      	ldr	r3, [sp, #4]
 80014d4:	2200      	movs	r2, #0
 80014d6:	629a      	str	r2, [r3, #40]	; 0x28
  obqp->top       = NULL;
 80014d8:	9b01      	ldr	r3, [sp, #4]
 80014da:	2200      	movs	r2, #0
 80014dc:	62da      	str	r2, [r3, #44]	; 0x2c
  osalThreadDequeueAllI(&obqp->waiting, MSG_RESET);
 80014de:	9b01      	ldr	r3, [sp, #4]
 80014e0:	f06f 0101 	mvn.w	r1, #1
 80014e4:	4618      	mov	r0, r3
 80014e6:	f7ff fd8b 	bl	8001000 <osalThreadDequeueAllI.lto_priv.726>
}
 80014ea:	b003      	add	sp, #12
 80014ec:	f85d fb04 	ldr.w	pc, [sp], #4

080014f0 <obqGetFullBufferI>:
 * @retval NULL         if the queue is empty.
 *
 * @iclass
 */
uint8_t *obqGetFullBufferI(output_buffers_queue_t *obqp,
                           size_t *sizep) {
 80014f0:	b500      	push	{lr}
 80014f2:	b083      	sub	sp, #12
 80014f4:	9001      	str	r0, [sp, #4]
 80014f6:	9100      	str	r1, [sp, #0]

  osalDbgCheckClassI();
 80014f8:	f005 f83a 	bl	8006570 <chDbgCheckClassI>

  if (obqIsEmptyI(obqp)) {
 80014fc:	9b01      	ldr	r3, [sp, #4]
 80014fe:	691a      	ldr	r2, [r3, #16]
 8001500:	9b01      	ldr	r3, [sp, #4]
 8001502:	695b      	ldr	r3, [r3, #20]
 8001504:	429a      	cmp	r2, r3
 8001506:	d105      	bne.n	8001514 <obqGetFullBufferI+0x24>
 8001508:	9b01      	ldr	r3, [sp, #4]
 800150a:	68db      	ldr	r3, [r3, #12]
 800150c:	2b00      	cmp	r3, #0
 800150e:	d001      	beq.n	8001514 <obqGetFullBufferI+0x24>
 8001510:	2301      	movs	r3, #1
 8001512:	e000      	b.n	8001516 <obqGetFullBufferI+0x26>
 8001514:	2300      	movs	r3, #0
 8001516:	f003 0301 	and.w	r3, r3, #1
 800151a:	b2db      	uxtb	r3, r3
 800151c:	2b00      	cmp	r3, #0
 800151e:	d001      	beq.n	8001524 <obqGetFullBufferI+0x34>
    return NULL;
 8001520:	2300      	movs	r3, #0
 8001522:	e007      	b.n	8001534 <obqGetFullBufferI+0x44>
  }

  /* Buffer size.*/
  *sizep = *((size_t *)obqp->brdptr);
 8001524:	9b01      	ldr	r3, [sp, #4]
 8001526:	695b      	ldr	r3, [r3, #20]
 8001528:	681a      	ldr	r2, [r3, #0]
 800152a:	9b00      	ldr	r3, [sp, #0]
 800152c:	601a      	str	r2, [r3, #0]

  return obqp->brdptr + sizeof (size_t);
 800152e:	9b01      	ldr	r3, [sp, #4]
 8001530:	695b      	ldr	r3, [r3, #20]
 8001532:	3304      	adds	r3, #4
}
 8001534:	4618      	mov	r0, r3
 8001536:	b003      	add	sp, #12
 8001538:	f85d fb04 	ldr.w	pc, [sp], #4
 800153c:	0000      	movs	r0, r0
	...

08001540 <obqReleaseEmptyBufferI>:
 *
 * @param[in] obqp      pointer to the @p output_buffers_queue_t object
 *
 * @iclass
 */
void obqReleaseEmptyBufferI(output_buffers_queue_t *obqp) {
 8001540:	b500      	push	{lr}
 8001542:	b083      	sub	sp, #12
 8001544:	9001      	str	r0, [sp, #4]

  osalDbgCheckClassI();
 8001546:	f005 f813 	bl	8006570 <chDbgCheckClassI>
  osalDbgAssert(!obqIsEmptyI(obqp), "buffers queue empty");
 800154a:	9b01      	ldr	r3, [sp, #4]
 800154c:	691a      	ldr	r2, [r3, #16]
 800154e:	9b01      	ldr	r3, [sp, #4]
 8001550:	695b      	ldr	r3, [r3, #20]
 8001552:	429a      	cmp	r2, r3
 8001554:	d105      	bne.n	8001562 <obqReleaseEmptyBufferI+0x22>
 8001556:	9b01      	ldr	r3, [sp, #4]
 8001558:	68db      	ldr	r3, [r3, #12]
 800155a:	2b00      	cmp	r3, #0
 800155c:	d001      	beq.n	8001562 <obqReleaseEmptyBufferI+0x22>
 800155e:	2301      	movs	r3, #1
 8001560:	e000      	b.n	8001564 <obqReleaseEmptyBufferI+0x24>
 8001562:	2300      	movs	r3, #0
 8001564:	f003 0301 	and.w	r3, r3, #1
 8001568:	b2db      	uxtb	r3, r3
 800156a:	2b00      	cmp	r3, #0
 800156c:	d002      	beq.n	8001574 <obqReleaseEmptyBufferI+0x34>
 800156e:	4810      	ldr	r0, [pc, #64]	; (80015b0 <obqReleaseEmptyBufferI+0x70>)
 8001570:	f004 fede 	bl	8006330 <chSysHalt>

  /* Freeing a buffer slot in the queue.*/
  obqp->bcounter++;
 8001574:	9b01      	ldr	r3, [sp, #4]
 8001576:	68db      	ldr	r3, [r3, #12]
 8001578:	1c5a      	adds	r2, r3, #1
 800157a:	9b01      	ldr	r3, [sp, #4]
 800157c:	60da      	str	r2, [r3, #12]
  obqp->brdptr += obqp->bsize;
 800157e:	9b01      	ldr	r3, [sp, #4]
 8001580:	695a      	ldr	r2, [r3, #20]
 8001582:	9b01      	ldr	r3, [sp, #4]
 8001584:	69db      	ldr	r3, [r3, #28]
 8001586:	441a      	add	r2, r3
 8001588:	9b01      	ldr	r3, [sp, #4]
 800158a:	615a      	str	r2, [r3, #20]
  if (obqp->brdptr >= obqp->btop) {
 800158c:	9b01      	ldr	r3, [sp, #4]
 800158e:	695a      	ldr	r2, [r3, #20]
 8001590:	9b01      	ldr	r3, [sp, #4]
 8001592:	699b      	ldr	r3, [r3, #24]
 8001594:	429a      	cmp	r2, r3
 8001596:	d303      	bcc.n	80015a0 <obqReleaseEmptyBufferI+0x60>
    obqp->brdptr = obqp->buffers;
 8001598:	9b01      	ldr	r3, [sp, #4]
 800159a:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 800159c:	9b01      	ldr	r3, [sp, #4]
 800159e:	615a      	str	r2, [r3, #20]
  }

  /* Waking up one waiting thread, if any.*/
  osalThreadDequeueNextI(&obqp->waiting, MSG_OK);
 80015a0:	9b01      	ldr	r3, [sp, #4]
 80015a2:	2100      	movs	r1, #0
 80015a4:	4618      	mov	r0, r3
 80015a6:	f7ff fd1b 	bl	8000fe0 <osalThreadDequeueNextI.lto_priv.740>
}
 80015aa:	b003      	add	sp, #12
 80015ac:	f85d fb04 	ldr.w	pc, [sp], #4
 80015b0:	0800873c 	.word	0x0800873c
	...

080015c0 <obqGetEmptyBufferTimeoutS>:
 *                      suspended state.
 *
 * @sclass
 */
msg_t obqGetEmptyBufferTimeoutS(output_buffers_queue_t *obqp,
                                sysinterval_t timeout) {
 80015c0:	b500      	push	{lr}
 80015c2:	b085      	sub	sp, #20
 80015c4:	9001      	str	r0, [sp, #4]
 80015c6:	9100      	str	r1, [sp, #0]

  osalDbgCheckClassS();
 80015c8:	f004 ffea 	bl	80065a0 <chDbgCheckClassS>
 80015cc:	e011      	b.n	80015f2 <obqGetEmptyBufferTimeoutS+0x32>

  while (obqIsFullI(obqp)) {
    if (obqp->suspended) {
 80015ce:	9b01      	ldr	r3, [sp, #4]
 80015d0:	7a1b      	ldrb	r3, [r3, #8]
 80015d2:	2b00      	cmp	r3, #0
 80015d4:	d002      	beq.n	80015dc <obqGetEmptyBufferTimeoutS+0x1c>
      return MSG_RESET;
 80015d6:	f06f 0301 	mvn.w	r3, #1
 80015da:	e022      	b.n	8001622 <obqGetEmptyBufferTimeoutS+0x62>
    }
    msg_t msg = osalThreadEnqueueTimeoutS(&obqp->waiting, timeout);
 80015dc:	9b01      	ldr	r3, [sp, #4]
 80015de:	9900      	ldr	r1, [sp, #0]
 80015e0:	4618      	mov	r0, r3
 80015e2:	f7ff fced 	bl	8000fc0 <osalThreadEnqueueTimeoutS.lto_priv.742>
 80015e6:	9003      	str	r0, [sp, #12]
    if (msg < MSG_OK) {
 80015e8:	9b03      	ldr	r3, [sp, #12]
 80015ea:	2b00      	cmp	r3, #0
 80015ec:	da01      	bge.n	80015f2 <obqGetEmptyBufferTimeoutS+0x32>
      return msg;
 80015ee:	9b03      	ldr	r3, [sp, #12]
 80015f0:	e017      	b.n	8001622 <obqGetEmptyBufferTimeoutS+0x62>
  while (obqIsFullI(obqp)) {
 80015f2:	9b01      	ldr	r3, [sp, #4]
 80015f4:	68db      	ldr	r3, [r3, #12]
 80015f6:	2b00      	cmp	r3, #0
 80015f8:	d0e9      	beq.n	80015ce <obqGetEmptyBufferTimeoutS+0xe>
    }
  }

  osalDbgAssert(!obqIsFullI(obqp), "still full");
 80015fa:	9b01      	ldr	r3, [sp, #4]
 80015fc:	68db      	ldr	r3, [r3, #12]
 80015fe:	2b00      	cmp	r3, #0
 8001600:	d102      	bne.n	8001608 <obqGetEmptyBufferTimeoutS+0x48>
 8001602:	480a      	ldr	r0, [pc, #40]	; (800162c <obqGetEmptyBufferTimeoutS+0x6c>)
 8001604:	f004 fe94 	bl	8006330 <chSysHalt>

  /* Setting up the "current" buffer and its boundary.*/
  obqp->ptr = obqp->bwrptr + sizeof (size_t);
 8001608:	9b01      	ldr	r3, [sp, #4]
 800160a:	691b      	ldr	r3, [r3, #16]
 800160c:	1d1a      	adds	r2, r3, #4
 800160e:	9b01      	ldr	r3, [sp, #4]
 8001610:	629a      	str	r2, [r3, #40]	; 0x28
  obqp->top = obqp->bwrptr + obqp->bsize;
 8001612:	9b01      	ldr	r3, [sp, #4]
 8001614:	691a      	ldr	r2, [r3, #16]
 8001616:	9b01      	ldr	r3, [sp, #4]
 8001618:	69db      	ldr	r3, [r3, #28]
 800161a:	441a      	add	r2, r3
 800161c:	9b01      	ldr	r3, [sp, #4]
 800161e:	62da      	str	r2, [r3, #44]	; 0x2c

  return MSG_OK;
 8001620:	2300      	movs	r3, #0
}
 8001622:	4618      	mov	r0, r3
 8001624:	b005      	add	sp, #20
 8001626:	f85d fb04 	ldr.w	pc, [sp], #4
 800162a:	bf00      	nop
 800162c:	08008754 	.word	0x08008754

08001630 <obqPostFullBufferS>:
 * @param[in] obqp      pointer to the @p output_buffers_queue_t object
 * @param[in] size      used size of the buffer, cannot be zero
 *
 * @sclass
 */
void obqPostFullBufferS(output_buffers_queue_t *obqp, size_t size) {
 8001630:	b500      	push	{lr}
 8001632:	b083      	sub	sp, #12
 8001634:	9001      	str	r0, [sp, #4]
 8001636:	9100      	str	r1, [sp, #0]

  osalDbgCheckClassS();
 8001638:	f004 ffb2 	bl	80065a0 <chDbgCheckClassS>
  osalDbgCheck((size > 0U) && (size <= (obqp->bsize - sizeof (size_t))));
 800163c:	9b00      	ldr	r3, [sp, #0]
 800163e:	2b00      	cmp	r3, #0
 8001640:	d005      	beq.n	800164e <obqPostFullBufferS+0x1e>
 8001642:	9b01      	ldr	r3, [sp, #4]
 8001644:	69db      	ldr	r3, [r3, #28]
 8001646:	3b04      	subs	r3, #4
 8001648:	9a00      	ldr	r2, [sp, #0]
 800164a:	429a      	cmp	r2, r3
 800164c:	d902      	bls.n	8001654 <obqPostFullBufferS+0x24>
 800164e:	4819      	ldr	r0, [pc, #100]	; (80016b4 <obqPostFullBufferS+0x84>)
 8001650:	f004 fe6e 	bl	8006330 <chSysHalt>
  osalDbgAssert(!obqIsFullI(obqp), "buffers queue full");
 8001654:	9b01      	ldr	r3, [sp, #4]
 8001656:	68db      	ldr	r3, [r3, #12]
 8001658:	2b00      	cmp	r3, #0
 800165a:	d102      	bne.n	8001662 <obqPostFullBufferS+0x32>
 800165c:	4815      	ldr	r0, [pc, #84]	; (80016b4 <obqPostFullBufferS+0x84>)
 800165e:	f004 fe67 	bl	8006330 <chSysHalt>

  /* Writing size field in the buffer.*/
  *((size_t *)obqp->bwrptr) = size;
 8001662:	9b01      	ldr	r3, [sp, #4]
 8001664:	691b      	ldr	r3, [r3, #16]
 8001666:	9a00      	ldr	r2, [sp, #0]
 8001668:	601a      	str	r2, [r3, #0]

  /* Posting the buffer in the queue.*/
  obqp->bcounter--;
 800166a:	9b01      	ldr	r3, [sp, #4]
 800166c:	68db      	ldr	r3, [r3, #12]
 800166e:	1e5a      	subs	r2, r3, #1
 8001670:	9b01      	ldr	r3, [sp, #4]
 8001672:	60da      	str	r2, [r3, #12]
  obqp->bwrptr += obqp->bsize;
 8001674:	9b01      	ldr	r3, [sp, #4]
 8001676:	691a      	ldr	r2, [r3, #16]
 8001678:	9b01      	ldr	r3, [sp, #4]
 800167a:	69db      	ldr	r3, [r3, #28]
 800167c:	441a      	add	r2, r3
 800167e:	9b01      	ldr	r3, [sp, #4]
 8001680:	611a      	str	r2, [r3, #16]
  if (obqp->bwrptr >= obqp->btop) {
 8001682:	9b01      	ldr	r3, [sp, #4]
 8001684:	691a      	ldr	r2, [r3, #16]
 8001686:	9b01      	ldr	r3, [sp, #4]
 8001688:	699b      	ldr	r3, [r3, #24]
 800168a:	429a      	cmp	r2, r3
 800168c:	d303      	bcc.n	8001696 <obqPostFullBufferS+0x66>
    obqp->bwrptr = obqp->buffers;
 800168e:	9b01      	ldr	r3, [sp, #4]
 8001690:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8001692:	9b01      	ldr	r3, [sp, #4]
 8001694:	611a      	str	r2, [r3, #16]
  }

  /* No "current" buffer.*/
  obqp->ptr = NULL;
 8001696:	9b01      	ldr	r3, [sp, #4]
 8001698:	2200      	movs	r2, #0
 800169a:	629a      	str	r2, [r3, #40]	; 0x28

  /* Notifying the buffer release.*/
  if (obqp->notify != NULL) {
 800169c:	9b01      	ldr	r3, [sp, #4]
 800169e:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80016a0:	2b00      	cmp	r3, #0
 80016a2:	d003      	beq.n	80016ac <obqPostFullBufferS+0x7c>
    obqp->notify(obqp);
 80016a4:	9b01      	ldr	r3, [sp, #4]
 80016a6:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80016a8:	9801      	ldr	r0, [sp, #4]
 80016aa:	4798      	blx	r3
  }
}
 80016ac:	b003      	add	sp, #12
 80016ae:	f85d fb04 	ldr.w	pc, [sp], #4
 80016b2:	bf00      	nop
 80016b4:	08008770 	.word	0x08008770
	...

080016c0 <obqPutTimeout>:
 *                      suspended state.
 *
 * @api
 */
msg_t obqPutTimeout(output_buffers_queue_t *obqp, uint8_t b,
                    sysinterval_t timeout) {
 80016c0:	b500      	push	{lr}
 80016c2:	b087      	sub	sp, #28
 80016c4:	9003      	str	r0, [sp, #12]
 80016c6:	460b      	mov	r3, r1
 80016c8:	9201      	str	r2, [sp, #4]
 80016ca:	f88d 300b 	strb.w	r3, [sp, #11]
  msg_t msg;

  osalSysLock();
 80016ce:	f7ff fc57 	bl	8000f80 <osalSysLock.lto_priv.483>

  /* This condition indicates that a new buffer must be acquired.*/
  if (obqp->ptr == NULL) {
 80016d2:	9b03      	ldr	r3, [sp, #12]
 80016d4:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 80016d6:	2b00      	cmp	r3, #0
 80016d8:	d10b      	bne.n	80016f2 <obqPutTimeout+0x32>
    msg = obqGetEmptyBufferTimeoutS(obqp, timeout);
 80016da:	9901      	ldr	r1, [sp, #4]
 80016dc:	9803      	ldr	r0, [sp, #12]
 80016de:	f7ff ff6f 	bl	80015c0 <obqGetEmptyBufferTimeoutS>
 80016e2:	9005      	str	r0, [sp, #20]
    if (msg != MSG_OK) {
 80016e4:	9b05      	ldr	r3, [sp, #20]
 80016e6:	2b00      	cmp	r3, #0
 80016e8:	d003      	beq.n	80016f2 <obqPutTimeout+0x32>
      osalSysUnlock();
 80016ea:	f7ff fc51 	bl	8000f90 <osalSysUnlock.lto_priv.472>
      return msg;
 80016ee:	9b05      	ldr	r3, [sp, #20]
 80016f0:	e019      	b.n	8001726 <obqPutTimeout+0x66>
    }
  }

  /* Writing the byte to the buffer.*/
  *obqp->ptr = b;
 80016f2:	9b03      	ldr	r3, [sp, #12]
 80016f4:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 80016f6:	f89d 200b 	ldrb.w	r2, [sp, #11]
 80016fa:	701a      	strb	r2, [r3, #0]
  obqp->ptr++;
 80016fc:	9b03      	ldr	r3, [sp, #12]
 80016fe:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8001700:	1c5a      	adds	r2, r3, #1
 8001702:	9b03      	ldr	r3, [sp, #12]
 8001704:	629a      	str	r2, [r3, #40]	; 0x28

  /* If the current buffer has been fully written then it is posted as
     full in the queue.*/
  if (obqp->ptr >= obqp->top) {
 8001706:	9b03      	ldr	r3, [sp, #12]
 8001708:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 800170a:	9b03      	ldr	r3, [sp, #12]
 800170c:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800170e:	429a      	cmp	r2, r3
 8001710:	d306      	bcc.n	8001720 <obqPutTimeout+0x60>
    obqPostFullBufferS(obqp, obqp->bsize - sizeof (size_t));
 8001712:	9b03      	ldr	r3, [sp, #12]
 8001714:	69db      	ldr	r3, [r3, #28]
 8001716:	3b04      	subs	r3, #4
 8001718:	4619      	mov	r1, r3
 800171a:	9803      	ldr	r0, [sp, #12]
 800171c:	f7ff ff88 	bl	8001630 <obqPostFullBufferS>
  }

  osalSysUnlock();
 8001720:	f7ff fc36 	bl	8000f90 <osalSysUnlock.lto_priv.472>
  return MSG_OK;
 8001724:	2300      	movs	r3, #0
}
 8001726:	4618      	mov	r0, r3
 8001728:	b007      	add	sp, #28
 800172a:	f85d fb04 	ldr.w	pc, [sp], #4
 800172e:	bf00      	nop

08001730 <obqWriteTimeout>:
 * @retval 0            if a timeout occurred.
 *
 * @api
 */
size_t obqWriteTimeout(output_buffers_queue_t *obqp, const uint8_t *bp,
                       size_t n, sysinterval_t timeout) {
 8001730:	b500      	push	{lr}
 8001732:	b089      	sub	sp, #36	; 0x24
 8001734:	9003      	str	r0, [sp, #12]
 8001736:	9102      	str	r1, [sp, #8]
 8001738:	9201      	str	r2, [sp, #4]
 800173a:	9300      	str	r3, [sp, #0]
  size_t w = 0;
 800173c:	2300      	movs	r3, #0
 800173e:	9307      	str	r3, [sp, #28]

  osalDbgCheck(n > 0U);
 8001740:	9b01      	ldr	r3, [sp, #4]
 8001742:	2b00      	cmp	r3, #0
 8001744:	d102      	bne.n	800174c <obqWriteTimeout+0x1c>
 8001746:	4837      	ldr	r0, [pc, #220]	; (8001824 <obqWriteTimeout+0xf4>)
 8001748:	f004 fdf2 	bl	8006330 <chSysHalt>

  osalSysLock();
 800174c:	f7ff fc18 	bl	8000f80 <osalSysLock.lto_priv.483>

  while (true) {
    size_t size;

    /* This condition indicates that a new buffer must be acquired.*/
    if (obqp->ptr == NULL) {
 8001750:	9b03      	ldr	r3, [sp, #12]
 8001752:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8001754:	2b00      	cmp	r3, #0
 8001756:	d10b      	bne.n	8001770 <obqWriteTimeout+0x40>
      msg_t msg;

      /* Getting an empty buffer using the specified timeout.*/
      msg = obqGetEmptyBufferTimeoutS(obqp, timeout);
 8001758:	9900      	ldr	r1, [sp, #0]
 800175a:	9803      	ldr	r0, [sp, #12]
 800175c:	f7ff ff30 	bl	80015c0 <obqGetEmptyBufferTimeoutS>
 8001760:	9005      	str	r0, [sp, #20]

      /* Anything except MSG_OK interrupts the operation.*/
      if (msg != MSG_OK) {
 8001762:	9b05      	ldr	r3, [sp, #20]
 8001764:	2b00      	cmp	r3, #0
 8001766:	d003      	beq.n	8001770 <obqWriteTimeout+0x40>
        osalSysUnlock();
 8001768:	f7ff fc12 	bl	8000f90 <osalSysUnlock.lto_priv.472>
        return w;
 800176c:	9b07      	ldr	r3, [sp, #28]
 800176e:	e054      	b.n	800181a <obqWriteTimeout+0xea>
      }
    }

    /* Size of the space available in the current buffer.*/
    size = (size_t)obqp->top - (size_t)obqp->ptr;
 8001770:	9b03      	ldr	r3, [sp, #12]
 8001772:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8001774:	461a      	mov	r2, r3
 8001776:	9b03      	ldr	r3, [sp, #12]
 8001778:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800177a:	1ad3      	subs	r3, r2, r3
 800177c:	9306      	str	r3, [sp, #24]
    if (size > (n - w)) {
 800177e:	9a01      	ldr	r2, [sp, #4]
 8001780:	9b07      	ldr	r3, [sp, #28]
 8001782:	1ad3      	subs	r3, r2, r3
 8001784:	9a06      	ldr	r2, [sp, #24]
 8001786:	429a      	cmp	r2, r3
 8001788:	d903      	bls.n	8001792 <obqWriteTimeout+0x62>
      size = n - w;
 800178a:	9a01      	ldr	r2, [sp, #4]
 800178c:	9b07      	ldr	r3, [sp, #28]
 800178e:	1ad3      	subs	r3, r2, r3
 8001790:	9306      	str	r3, [sp, #24]
    }

    /* Smaller chunks in order to not make the critical zone too long,
       this impacts throughput however.*/
    if (size > (size_t)BUFFERS_CHUNKS_SIZE) {
 8001792:	9b06      	ldr	r3, [sp, #24]
 8001794:	2b40      	cmp	r3, #64	; 0x40
 8001796:	d913      	bls.n	80017c0 <obqWriteTimeout+0x90>
      /* Giving the compiler a chance to optimize for a fixed size move.*/
      memcpy(obqp->ptr, bp, (size_t)BUFFERS_CHUNKS_SIZE);
 8001798:	9b03      	ldr	r3, [sp, #12]
 800179a:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800179c:	2240      	movs	r2, #64	; 0x40
 800179e:	9902      	ldr	r1, [sp, #8]
 80017a0:	4618      	mov	r0, r3
 80017a2:	f7fe fdaf 	bl	8000304 <memcpy>
      bp        += (size_t)BUFFERS_CHUNKS_SIZE;
 80017a6:	9b02      	ldr	r3, [sp, #8]
 80017a8:	3340      	adds	r3, #64	; 0x40
 80017aa:	9302      	str	r3, [sp, #8]
      obqp->ptr += (size_t)BUFFERS_CHUNKS_SIZE;
 80017ac:	9b03      	ldr	r3, [sp, #12]
 80017ae:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 80017b0:	f103 0240 	add.w	r2, r3, #64	; 0x40
 80017b4:	9b03      	ldr	r3, [sp, #12]
 80017b6:	629a      	str	r2, [r3, #40]	; 0x28
      w         += (size_t)BUFFERS_CHUNKS_SIZE;
 80017b8:	9b07      	ldr	r3, [sp, #28]
 80017ba:	3340      	adds	r3, #64	; 0x40
 80017bc:	9307      	str	r3, [sp, #28]
 80017be:	e014      	b.n	80017ea <obqWriteTimeout+0xba>
    }
    else {
      memcpy(obqp->ptr, bp, size);
 80017c0:	9b03      	ldr	r3, [sp, #12]
 80017c2:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 80017c4:	9a06      	ldr	r2, [sp, #24]
 80017c6:	9902      	ldr	r1, [sp, #8]
 80017c8:	4618      	mov	r0, r3
 80017ca:	f7fe fd9b 	bl	8000304 <memcpy>
      bp        += size;
 80017ce:	9a02      	ldr	r2, [sp, #8]
 80017d0:	9b06      	ldr	r3, [sp, #24]
 80017d2:	4413      	add	r3, r2
 80017d4:	9302      	str	r3, [sp, #8]
      obqp->ptr += size;
 80017d6:	9b03      	ldr	r3, [sp, #12]
 80017d8:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 80017da:	9b06      	ldr	r3, [sp, #24]
 80017dc:	441a      	add	r2, r3
 80017de:	9b03      	ldr	r3, [sp, #12]
 80017e0:	629a      	str	r2, [r3, #40]	; 0x28
      w         += size;
 80017e2:	9a07      	ldr	r2, [sp, #28]
 80017e4:	9b06      	ldr	r3, [sp, #24]
 80017e6:	4413      	add	r3, r2
 80017e8:	9307      	str	r3, [sp, #28]
    }

    /* Has the current data buffer been finished? if so then release it.*/
    if (obqp->ptr >= obqp->top) {
 80017ea:	9b03      	ldr	r3, [sp, #12]
 80017ec:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 80017ee:	9b03      	ldr	r3, [sp, #12]
 80017f0:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80017f2:	429a      	cmp	r2, r3
 80017f4:	d306      	bcc.n	8001804 <obqWriteTimeout+0xd4>
      obqPostFullBufferS(obqp, obqp->bsize - sizeof (size_t));
 80017f6:	9b03      	ldr	r3, [sp, #12]
 80017f8:	69db      	ldr	r3, [r3, #28]
 80017fa:	3b04      	subs	r3, #4
 80017fc:	4619      	mov	r1, r3
 80017fe:	9803      	ldr	r0, [sp, #12]
 8001800:	f7ff ff16 	bl	8001630 <obqPostFullBufferS>
    }

    /* Giving a preemption chance.*/
    osalSysUnlock();
 8001804:	f7ff fbc4 	bl	8000f90 <osalSysUnlock.lto_priv.472>
    if (w >= n) {
 8001808:	9a07      	ldr	r2, [sp, #28]
 800180a:	9b01      	ldr	r3, [sp, #4]
 800180c:	429a      	cmp	r2, r3
 800180e:	d301      	bcc.n	8001814 <obqWriteTimeout+0xe4>
      return w;
 8001810:	9b07      	ldr	r3, [sp, #28]
 8001812:	e002      	b.n	800181a <obqWriteTimeout+0xea>
    }
    osalSysLock();
 8001814:	f7ff fbb4 	bl	8000f80 <osalSysLock.lto_priv.483>
 8001818:	e79a      	b.n	8001750 <obqWriteTimeout+0x20>
  }
}
 800181a:	4618      	mov	r0, r3
 800181c:	b009      	add	sp, #36	; 0x24
 800181e:	f85d fb04 	ldr.w	pc, [sp], #4
 8001822:	bf00      	nop
 8001824:	08008784 	.word	0x08008784
	...

08001830 <obqTryFlushI>:
 * @retval false        if no new filled buffer has been posted to the queue.
 * @retval true         if a new filled buffer has been posted to the queue.
 *
 * @iclass
 */
bool obqTryFlushI(output_buffers_queue_t *obqp) {
 8001830:	b500      	push	{lr}
 8001832:	b085      	sub	sp, #20
 8001834:	9001      	str	r0, [sp, #4]

  osalDbgCheckClassI();
 8001836:	f004 fe9b 	bl	8006570 <chDbgCheckClassI>

  /* If queue is empty and there is a buffer partially filled and
     it is not being written.*/
  if (obqIsEmptyI(obqp) && (obqp->ptr != NULL)) {
 800183a:	9b01      	ldr	r3, [sp, #4]
 800183c:	691a      	ldr	r2, [r3, #16]
 800183e:	9b01      	ldr	r3, [sp, #4]
 8001840:	695b      	ldr	r3, [r3, #20]
 8001842:	429a      	cmp	r2, r3
 8001844:	d105      	bne.n	8001852 <obqTryFlushI+0x22>
 8001846:	9b01      	ldr	r3, [sp, #4]
 8001848:	68db      	ldr	r3, [r3, #12]
 800184a:	2b00      	cmp	r3, #0
 800184c:	d001      	beq.n	8001852 <obqTryFlushI+0x22>
 800184e:	2301      	movs	r3, #1
 8001850:	e000      	b.n	8001854 <obqTryFlushI+0x24>
 8001852:	2300      	movs	r3, #0
 8001854:	f003 0301 	and.w	r3, r3, #1
 8001858:	b2db      	uxtb	r3, r3
 800185a:	2b00      	cmp	r3, #0
 800185c:	d02d      	beq.n	80018ba <obqTryFlushI+0x8a>
 800185e:	9b01      	ldr	r3, [sp, #4]
 8001860:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8001862:	2b00      	cmp	r3, #0
 8001864:	d029      	beq.n	80018ba <obqTryFlushI+0x8a>
    size_t size = (size_t)obqp->ptr - ((size_t)obqp->bwrptr + sizeof (size_t));
 8001866:	9b01      	ldr	r3, [sp, #4]
 8001868:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800186a:	461a      	mov	r2, r3
 800186c:	9b01      	ldr	r3, [sp, #4]
 800186e:	691b      	ldr	r3, [r3, #16]
 8001870:	1ad3      	subs	r3, r2, r3
 8001872:	3b04      	subs	r3, #4
 8001874:	9303      	str	r3, [sp, #12]

    if (size > 0U) {
 8001876:	9b03      	ldr	r3, [sp, #12]
 8001878:	2b00      	cmp	r3, #0
 800187a:	d01e      	beq.n	80018ba <obqTryFlushI+0x8a>

      /* Writing size field in the buffer.*/
      *((size_t *)obqp->bwrptr) = size;
 800187c:	9b01      	ldr	r3, [sp, #4]
 800187e:	691b      	ldr	r3, [r3, #16]
 8001880:	9a03      	ldr	r2, [sp, #12]
 8001882:	601a      	str	r2, [r3, #0]

      /* Posting the buffer in the queue.*/
      obqp->bcounter--;
 8001884:	9b01      	ldr	r3, [sp, #4]
 8001886:	68db      	ldr	r3, [r3, #12]
 8001888:	1e5a      	subs	r2, r3, #1
 800188a:	9b01      	ldr	r3, [sp, #4]
 800188c:	60da      	str	r2, [r3, #12]
      obqp->bwrptr += obqp->bsize;
 800188e:	9b01      	ldr	r3, [sp, #4]
 8001890:	691a      	ldr	r2, [r3, #16]
 8001892:	9b01      	ldr	r3, [sp, #4]
 8001894:	69db      	ldr	r3, [r3, #28]
 8001896:	441a      	add	r2, r3
 8001898:	9b01      	ldr	r3, [sp, #4]
 800189a:	611a      	str	r2, [r3, #16]
      if (obqp->bwrptr >= obqp->btop) {
 800189c:	9b01      	ldr	r3, [sp, #4]
 800189e:	691a      	ldr	r2, [r3, #16]
 80018a0:	9b01      	ldr	r3, [sp, #4]
 80018a2:	699b      	ldr	r3, [r3, #24]
 80018a4:	429a      	cmp	r2, r3
 80018a6:	d303      	bcc.n	80018b0 <obqTryFlushI+0x80>
        obqp->bwrptr = obqp->buffers;
 80018a8:	9b01      	ldr	r3, [sp, #4]
 80018aa:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 80018ac:	9b01      	ldr	r3, [sp, #4]
 80018ae:	611a      	str	r2, [r3, #16]
      }

      /* No "current" buffer.*/
      obqp->ptr = NULL;
 80018b0:	9b01      	ldr	r3, [sp, #4]
 80018b2:	2200      	movs	r2, #0
 80018b4:	629a      	str	r2, [r3, #40]	; 0x28

      return true;
 80018b6:	2301      	movs	r3, #1
 80018b8:	e000      	b.n	80018bc <obqTryFlushI+0x8c>
    }
  }
  return false;
 80018ba:	2300      	movs	r3, #0
}
 80018bc:	4618      	mov	r0, r3
 80018be:	b005      	add	sp, #20
 80018c0:	f85d fb04 	ldr.w	pc, [sp], #4
	...

080018d0 <port_lock.lto_priv.287>:
static inline void port_lock(void) {
 80018d0:	b082      	sub	sp, #8
 80018d2:	2320      	movs	r3, #32
 80018d4:	9301      	str	r3, [sp, #4]
 80018d6:	9b01      	ldr	r3, [sp, #4]
 80018d8:	f383 8811 	msr	BASEPRI, r3
}
 80018dc:	b002      	add	sp, #8
 80018de:	4770      	bx	lr

080018e0 <port_unlock.lto_priv.246>:
static inline void port_unlock(void) {
 80018e0:	b082      	sub	sp, #8
 80018e2:	2300      	movs	r3, #0
 80018e4:	9301      	str	r3, [sp, #4]
 80018e6:	9b01      	ldr	r3, [sp, #4]
 80018e8:	f383 8811 	msr	BASEPRI, r3
}
 80018ec:	b002      	add	sp, #8
 80018ee:	4770      	bx	lr

080018f0 <queue_init.lto_priv.591>:
static inline void queue_init(threads_queue_t *tqp) {
 80018f0:	b082      	sub	sp, #8
 80018f2:	9001      	str	r0, [sp, #4]
  tqp->next = (thread_t *)tqp;
 80018f4:	9b01      	ldr	r3, [sp, #4]
 80018f6:	9a01      	ldr	r2, [sp, #4]
 80018f8:	601a      	str	r2, [r3, #0]
  tqp->prev = (thread_t *)tqp;
 80018fa:	9b01      	ldr	r3, [sp, #4]
 80018fc:	9a01      	ldr	r2, [sp, #4]
 80018fe:	605a      	str	r2, [r3, #4]
}
 8001900:	b002      	add	sp, #8
 8001902:	4770      	bx	lr
	...

08001910 <chSysLock.lto_priv.401>:
static inline void chSysLock(void) {
 8001910:	b508      	push	{r3, lr}
  port_lock();
 8001912:	f7ff ffdd 	bl	80018d0 <port_lock.lto_priv.287>
  _dbg_check_lock();
 8001916:	f004 fd8b 	bl	8006430 <_dbg_check_lock>
}
 800191a:	bd08      	pop	{r3, pc}
 800191c:	0000      	movs	r0, r0
	...

08001920 <chSysUnlock.lto_priv.368>:
static inline void chSysUnlock(void) {
 8001920:	b508      	push	{r3, lr}
  _dbg_check_unlock();
 8001922:	f004 fd9d 	bl	8006460 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8001926:	4b09      	ldr	r3, [pc, #36]	; (800194c <chSysUnlock.lto_priv.368+0x2c>)
 8001928:	681b      	ldr	r3, [r3, #0]
 800192a:	4a08      	ldr	r2, [pc, #32]	; (800194c <chSysUnlock.lto_priv.368+0x2c>)
 800192c:	4293      	cmp	r3, r2
 800192e:	d00a      	beq.n	8001946 <chSysUnlock.lto_priv.368+0x26>
 8001930:	4b06      	ldr	r3, [pc, #24]	; (800194c <chSysUnlock.lto_priv.368+0x2c>)
 8001932:	699b      	ldr	r3, [r3, #24]
 8001934:	689a      	ldr	r2, [r3, #8]
 8001936:	4b05      	ldr	r3, [pc, #20]	; (800194c <chSysUnlock.lto_priv.368+0x2c>)
 8001938:	681b      	ldr	r3, [r3, #0]
 800193a:	689b      	ldr	r3, [r3, #8]
 800193c:	429a      	cmp	r2, r3
 800193e:	d202      	bcs.n	8001946 <chSysUnlock.lto_priv.368+0x26>
 8001940:	4803      	ldr	r0, [pc, #12]	; (8001950 <chSysUnlock.lto_priv.368+0x30>)
 8001942:	f004 fcf5 	bl	8006330 <chSysHalt>
  port_unlock();
 8001946:	f7ff ffcb 	bl	80018e0 <port_unlock.lto_priv.246>
}
 800194a:	bd08      	pop	{r3, pc}
 800194c:	20000b38 	.word	0x20000b38
 8001950:	080087a8 	.word	0x080087a8
	...

08001960 <chThdQueueObjectInit.lto_priv.588>:
static inline void chThdQueueObjectInit(threads_queue_t *tqp) {
 8001960:	b500      	push	{lr}
 8001962:	b083      	sub	sp, #12
 8001964:	9001      	str	r0, [sp, #4]
  queue_init(tqp);
 8001966:	9801      	ldr	r0, [sp, #4]
 8001968:	f7ff ffc2 	bl	80018f0 <queue_init.lto_priv.591>
}
 800196c:	b003      	add	sp, #12
 800196e:	f85d fb04 	ldr.w	pc, [sp], #4
 8001972:	bf00      	nop
	...

08001980 <osalSysLock.lto_priv.484>:
static inline void osalSysLock(void) {
 8001980:	b508      	push	{r3, lr}
  chSysLock();
 8001982:	f7ff ffc5 	bl	8001910 <chSysLock.lto_priv.401>
}
 8001986:	bd08      	pop	{r3, pc}
	...

08001990 <osalSysUnlock.lto_priv.473>:
static inline void osalSysUnlock(void) {
 8001990:	b508      	push	{r3, lr}
  chSysUnlock();
 8001992:	f7ff ffc5 	bl	8001920 <chSysUnlock.lto_priv.368>
}
 8001996:	bd08      	pop	{r3, pc}
	...

080019a0 <osalThreadQueueObjectInit.lto_priv.745>:
static inline void osalThreadQueueObjectInit(threads_queue_t *tqp) {
 80019a0:	b500      	push	{lr}
 80019a2:	b083      	sub	sp, #12
 80019a4:	9001      	str	r0, [sp, #4]
  chThdQueueObjectInit(tqp);
 80019a6:	9801      	ldr	r0, [sp, #4]
 80019a8:	f7ff ffda 	bl	8001960 <chThdQueueObjectInit.lto_priv.588>
}
 80019ac:	b003      	add	sp, #12
 80019ae:	f85d fb04 	ldr.w	pc, [sp], #4
 80019b2:	bf00      	nop
	...

080019c0 <osalThreadEnqueueTimeoutS.lto_priv.743>:
                                              sysinterval_t timeout) {
 80019c0:	b500      	push	{lr}
 80019c2:	b083      	sub	sp, #12
 80019c4:	9001      	str	r0, [sp, #4]
 80019c6:	9100      	str	r1, [sp, #0]
  return chThdEnqueueTimeoutS(tqp, timeout);
 80019c8:	9900      	ldr	r1, [sp, #0]
 80019ca:	9801      	ldr	r0, [sp, #4]
 80019cc:	f005 feb8 	bl	8007740 <chThdEnqueueTimeoutS>
 80019d0:	4603      	mov	r3, r0
}
 80019d2:	4618      	mov	r0, r3
 80019d4:	b003      	add	sp, #12
 80019d6:	f85d fb04 	ldr.w	pc, [sp], #4
 80019da:	bf00      	nop
 80019dc:	0000      	movs	r0, r0
	...

080019e0 <osalThreadDequeueNextI.lto_priv.741>:
static inline void osalThreadDequeueNextI(threads_queue_t *tqp, msg_t msg) {
 80019e0:	b500      	push	{lr}
 80019e2:	b083      	sub	sp, #12
 80019e4:	9001      	str	r0, [sp, #4]
 80019e6:	9100      	str	r1, [sp, #0]
  chThdDequeueNextI(tqp, msg);
 80019e8:	9900      	ldr	r1, [sp, #0]
 80019ea:	9801      	ldr	r0, [sp, #4]
 80019ec:	f005 fec8 	bl	8007780 <chThdDequeueNextI>
}
 80019f0:	b003      	add	sp, #12
 80019f2:	f85d fb04 	ldr.w	pc, [sp], #4
 80019f6:	bf00      	nop
	...

08001a00 <iq_read>:
 *                      value 0 is reserved
 * @return              The number of bytes effectively transferred.
 *
 * @notapi
 */
static size_t iq_read(input_queue_t *iqp, uint8_t *bp, size_t n) {
 8001a00:	b500      	push	{lr}
 8001a02:	b087      	sub	sp, #28
 8001a04:	9003      	str	r0, [sp, #12]
 8001a06:	9102      	str	r1, [sp, #8]
 8001a08:	9201      	str	r2, [sp, #4]
  size_t s1, s2;

  osalDbgCheck(n > 0U);
 8001a0a:	9b01      	ldr	r3, [sp, #4]
 8001a0c:	2b00      	cmp	r3, #0
 8001a0e:	d102      	bne.n	8001a16 <iq_read+0x16>
 8001a10:	482d      	ldr	r0, [pc, #180]	; (8001ac8 <iq_read+0xc8>)
 8001a12:	f004 fc8d 	bl	8006330 <chSysHalt>

  /* Number of bytes that can be read in a single atomic operation.*/
  if (n > iqGetFullI(iqp)) {
 8001a16:	9b03      	ldr	r3, [sp, #12]
 8001a18:	689b      	ldr	r3, [r3, #8]
 8001a1a:	9a01      	ldr	r2, [sp, #4]
 8001a1c:	429a      	cmp	r2, r3
 8001a1e:	d902      	bls.n	8001a26 <iq_read+0x26>
    n = iqGetFullI(iqp);
 8001a20:	9b03      	ldr	r3, [sp, #12]
 8001a22:	689b      	ldr	r3, [r3, #8]
 8001a24:	9301      	str	r3, [sp, #4]
  }

  /* Number of bytes before buffer limit.*/
  /*lint -save -e9033 [10.8] Checked to be safe.*/
  s1 = (size_t)(iqp->q_top - iqp->q_rdptr);
 8001a26:	9b03      	ldr	r3, [sp, #12]
 8001a28:	691b      	ldr	r3, [r3, #16]
 8001a2a:	461a      	mov	r2, r3
 8001a2c:	9b03      	ldr	r3, [sp, #12]
 8001a2e:	699b      	ldr	r3, [r3, #24]
 8001a30:	1ad3      	subs	r3, r2, r3
 8001a32:	9305      	str	r3, [sp, #20]
  /*lint -restore*/
  if (n < s1) {
 8001a34:	9a01      	ldr	r2, [sp, #4]
 8001a36:	9b05      	ldr	r3, [sp, #20]
 8001a38:	429a      	cmp	r2, r3
 8001a3a:	d20d      	bcs.n	8001a58 <iq_read+0x58>
    memcpy((void *)bp, (void *)iqp->q_rdptr, n);
 8001a3c:	9b03      	ldr	r3, [sp, #12]
 8001a3e:	699b      	ldr	r3, [r3, #24]
 8001a40:	9a01      	ldr	r2, [sp, #4]
 8001a42:	4619      	mov	r1, r3
 8001a44:	9802      	ldr	r0, [sp, #8]
 8001a46:	f7fe fc5d 	bl	8000304 <memcpy>
    iqp->q_rdptr += n;
 8001a4a:	9b03      	ldr	r3, [sp, #12]
 8001a4c:	699a      	ldr	r2, [r3, #24]
 8001a4e:	9b01      	ldr	r3, [sp, #4]
 8001a50:	441a      	add	r2, r3
 8001a52:	9b03      	ldr	r3, [sp, #12]
 8001a54:	619a      	str	r2, [r3, #24]
 8001a56:	e02b      	b.n	8001ab0 <iq_read+0xb0>
  }
  else if (n > s1) {
 8001a58:	9a01      	ldr	r2, [sp, #4]
 8001a5a:	9b05      	ldr	r3, [sp, #20]
 8001a5c:	429a      	cmp	r2, r3
 8001a5e:	d91c      	bls.n	8001a9a <iq_read+0x9a>
    memcpy((void *)bp, (void *)iqp->q_rdptr, s1);
 8001a60:	9b03      	ldr	r3, [sp, #12]
 8001a62:	699b      	ldr	r3, [r3, #24]
 8001a64:	9a05      	ldr	r2, [sp, #20]
 8001a66:	4619      	mov	r1, r3
 8001a68:	9802      	ldr	r0, [sp, #8]
 8001a6a:	f7fe fc4b 	bl	8000304 <memcpy>
    bp += s1;
 8001a6e:	9a02      	ldr	r2, [sp, #8]
 8001a70:	9b05      	ldr	r3, [sp, #20]
 8001a72:	4413      	add	r3, r2
 8001a74:	9302      	str	r3, [sp, #8]
    s2 = n - s1;
 8001a76:	9a01      	ldr	r2, [sp, #4]
 8001a78:	9b05      	ldr	r3, [sp, #20]
 8001a7a:	1ad3      	subs	r3, r2, r3
 8001a7c:	9304      	str	r3, [sp, #16]
    memcpy((void *)bp, (void *)iqp->q_buffer, s2);
 8001a7e:	9b03      	ldr	r3, [sp, #12]
 8001a80:	68db      	ldr	r3, [r3, #12]
 8001a82:	9a04      	ldr	r2, [sp, #16]
 8001a84:	4619      	mov	r1, r3
 8001a86:	9802      	ldr	r0, [sp, #8]
 8001a88:	f7fe fc3c 	bl	8000304 <memcpy>
    iqp->q_rdptr = iqp->q_buffer + s2;
 8001a8c:	9b03      	ldr	r3, [sp, #12]
 8001a8e:	68da      	ldr	r2, [r3, #12]
 8001a90:	9b04      	ldr	r3, [sp, #16]
 8001a92:	441a      	add	r2, r3
 8001a94:	9b03      	ldr	r3, [sp, #12]
 8001a96:	619a      	str	r2, [r3, #24]
 8001a98:	e00a      	b.n	8001ab0 <iq_read+0xb0>
  }
  else { /* n == s1 */
    memcpy((void *)bp, (void *)iqp->q_rdptr, n);
 8001a9a:	9b03      	ldr	r3, [sp, #12]
 8001a9c:	699b      	ldr	r3, [r3, #24]
 8001a9e:	9a01      	ldr	r2, [sp, #4]
 8001aa0:	4619      	mov	r1, r3
 8001aa2:	9802      	ldr	r0, [sp, #8]
 8001aa4:	f7fe fc2e 	bl	8000304 <memcpy>
    iqp->q_rdptr = iqp->q_buffer;
 8001aa8:	9b03      	ldr	r3, [sp, #12]
 8001aaa:	68da      	ldr	r2, [r3, #12]
 8001aac:	9b03      	ldr	r3, [sp, #12]
 8001aae:	619a      	str	r2, [r3, #24]
  }

  iqp->q_counter -= n;
 8001ab0:	9b03      	ldr	r3, [sp, #12]
 8001ab2:	689a      	ldr	r2, [r3, #8]
 8001ab4:	9b01      	ldr	r3, [sp, #4]
 8001ab6:	1ad2      	subs	r2, r2, r3
 8001ab8:	9b03      	ldr	r3, [sp, #12]
 8001aba:	609a      	str	r2, [r3, #8]
  return n;
 8001abc:	9b01      	ldr	r3, [sp, #4]
}
 8001abe:	4618      	mov	r0, r3
 8001ac0:	b007      	add	sp, #28
 8001ac2:	f85d fb04 	ldr.w	pc, [sp], #4
 8001ac6:	bf00      	nop
 8001ac8:	08008794 	.word	0x08008794
 8001acc:	00000000 	.word	0x00000000

08001ad0 <oq_write>:
 *                      value 0 is reserved
 * @return              The number of bytes effectively transferred.
 *
 * @notapi
 */
static size_t oq_write(output_queue_t *oqp, const uint8_t *bp, size_t n) {
 8001ad0:	b500      	push	{lr}
 8001ad2:	b087      	sub	sp, #28
 8001ad4:	9003      	str	r0, [sp, #12]
 8001ad6:	9102      	str	r1, [sp, #8]
 8001ad8:	9201      	str	r2, [sp, #4]
  size_t s1, s2;

  osalDbgCheck(n > 0U);
 8001ada:	9b01      	ldr	r3, [sp, #4]
 8001adc:	2b00      	cmp	r3, #0
 8001ade:	d102      	bne.n	8001ae6 <oq_write+0x16>
 8001ae0:	482d      	ldr	r0, [pc, #180]	; (8001b98 <oq_write+0xc8>)
 8001ae2:	f004 fc25 	bl	8006330 <chSysHalt>

  /* Number of bytes that can be written in a single atomic operation.*/
  if (n > oqGetEmptyI(oqp)) {
 8001ae6:	9b03      	ldr	r3, [sp, #12]
 8001ae8:	689b      	ldr	r3, [r3, #8]
 8001aea:	9a01      	ldr	r2, [sp, #4]
 8001aec:	429a      	cmp	r2, r3
 8001aee:	d902      	bls.n	8001af6 <oq_write+0x26>
    n = oqGetEmptyI(oqp);
 8001af0:	9b03      	ldr	r3, [sp, #12]
 8001af2:	689b      	ldr	r3, [r3, #8]
 8001af4:	9301      	str	r3, [sp, #4]
  }

  /* Number of bytes before buffer limit.*/
  /*lint -save -e9033 [10.8] Checked to be safe.*/
  s1 = (size_t)(oqp->q_top - oqp->q_wrptr);
 8001af6:	9b03      	ldr	r3, [sp, #12]
 8001af8:	691b      	ldr	r3, [r3, #16]
 8001afa:	461a      	mov	r2, r3
 8001afc:	9b03      	ldr	r3, [sp, #12]
 8001afe:	695b      	ldr	r3, [r3, #20]
 8001b00:	1ad3      	subs	r3, r2, r3
 8001b02:	9305      	str	r3, [sp, #20]
  /*lint -restore*/
  if (n < s1) {
 8001b04:	9a01      	ldr	r2, [sp, #4]
 8001b06:	9b05      	ldr	r3, [sp, #20]
 8001b08:	429a      	cmp	r2, r3
 8001b0a:	d20d      	bcs.n	8001b28 <oq_write+0x58>
    memcpy((void *)oqp->q_wrptr, (const void *)bp, n);
 8001b0c:	9b03      	ldr	r3, [sp, #12]
 8001b0e:	695b      	ldr	r3, [r3, #20]
 8001b10:	9a01      	ldr	r2, [sp, #4]
 8001b12:	9902      	ldr	r1, [sp, #8]
 8001b14:	4618      	mov	r0, r3
 8001b16:	f7fe fbf5 	bl	8000304 <memcpy>
    oqp->q_wrptr += n;
 8001b1a:	9b03      	ldr	r3, [sp, #12]
 8001b1c:	695a      	ldr	r2, [r3, #20]
 8001b1e:	9b01      	ldr	r3, [sp, #4]
 8001b20:	441a      	add	r2, r3
 8001b22:	9b03      	ldr	r3, [sp, #12]
 8001b24:	615a      	str	r2, [r3, #20]
 8001b26:	e02b      	b.n	8001b80 <oq_write+0xb0>
  }
  else if (n > s1) {
 8001b28:	9a01      	ldr	r2, [sp, #4]
 8001b2a:	9b05      	ldr	r3, [sp, #20]
 8001b2c:	429a      	cmp	r2, r3
 8001b2e:	d91c      	bls.n	8001b6a <oq_write+0x9a>
    memcpy((void *)oqp->q_wrptr, (const void *)bp, s1);
 8001b30:	9b03      	ldr	r3, [sp, #12]
 8001b32:	695b      	ldr	r3, [r3, #20]
 8001b34:	9a05      	ldr	r2, [sp, #20]
 8001b36:	9902      	ldr	r1, [sp, #8]
 8001b38:	4618      	mov	r0, r3
 8001b3a:	f7fe fbe3 	bl	8000304 <memcpy>
    bp += s1;
 8001b3e:	9a02      	ldr	r2, [sp, #8]
 8001b40:	9b05      	ldr	r3, [sp, #20]
 8001b42:	4413      	add	r3, r2
 8001b44:	9302      	str	r3, [sp, #8]
    s2 = n - s1;
 8001b46:	9a01      	ldr	r2, [sp, #4]
 8001b48:	9b05      	ldr	r3, [sp, #20]
 8001b4a:	1ad3      	subs	r3, r2, r3
 8001b4c:	9304      	str	r3, [sp, #16]
    memcpy((void *)oqp->q_buffer, (const void *)bp, s2);
 8001b4e:	9b03      	ldr	r3, [sp, #12]
 8001b50:	68db      	ldr	r3, [r3, #12]
 8001b52:	9a04      	ldr	r2, [sp, #16]
 8001b54:	9902      	ldr	r1, [sp, #8]
 8001b56:	4618      	mov	r0, r3
 8001b58:	f7fe fbd4 	bl	8000304 <memcpy>
    oqp->q_wrptr = oqp->q_buffer + s2;
 8001b5c:	9b03      	ldr	r3, [sp, #12]
 8001b5e:	68da      	ldr	r2, [r3, #12]
 8001b60:	9b04      	ldr	r3, [sp, #16]
 8001b62:	441a      	add	r2, r3
 8001b64:	9b03      	ldr	r3, [sp, #12]
 8001b66:	615a      	str	r2, [r3, #20]
 8001b68:	e00a      	b.n	8001b80 <oq_write+0xb0>
  }
  else { /* n == s1 */
    memcpy((void *)oqp->q_wrptr, (const void *)bp, n);
 8001b6a:	9b03      	ldr	r3, [sp, #12]
 8001b6c:	695b      	ldr	r3, [r3, #20]
 8001b6e:	9a01      	ldr	r2, [sp, #4]
 8001b70:	9902      	ldr	r1, [sp, #8]
 8001b72:	4618      	mov	r0, r3
 8001b74:	f7fe fbc6 	bl	8000304 <memcpy>
    oqp->q_wrptr = oqp->q_buffer;
 8001b78:	9b03      	ldr	r3, [sp, #12]
 8001b7a:	68da      	ldr	r2, [r3, #12]
 8001b7c:	9b03      	ldr	r3, [sp, #12]
 8001b7e:	615a      	str	r2, [r3, #20]
  }

  oqp->q_counter -= n;
 8001b80:	9b03      	ldr	r3, [sp, #12]
 8001b82:	689a      	ldr	r2, [r3, #8]
 8001b84:	9b01      	ldr	r3, [sp, #4]
 8001b86:	1ad2      	subs	r2, r2, r3
 8001b88:	9b03      	ldr	r3, [sp, #12]
 8001b8a:	609a      	str	r2, [r3, #8]
  return n;
 8001b8c:	9b01      	ldr	r3, [sp, #4]
}
 8001b8e:	4618      	mov	r0, r3
 8001b90:	b007      	add	sp, #28
 8001b92:	f85d fb04 	ldr.w	pc, [sp], #4
 8001b96:	bf00      	nop
 8001b98:	0800879c 	.word	0x0800879c
 8001b9c:	00000000 	.word	0x00000000

08001ba0 <iqObjectInit>:
 * @param[in] link      application defined pointer
 *
 * @init
 */
void iqObjectInit(input_queue_t *iqp, uint8_t *bp, size_t size,
                  qnotify_t infy, void *link) {
 8001ba0:	b500      	push	{lr}
 8001ba2:	b085      	sub	sp, #20
 8001ba4:	9003      	str	r0, [sp, #12]
 8001ba6:	9102      	str	r1, [sp, #8]
 8001ba8:	9201      	str	r2, [sp, #4]
 8001baa:	9300      	str	r3, [sp, #0]

  osalThreadQueueObjectInit(&iqp->q_waiting);
 8001bac:	9b03      	ldr	r3, [sp, #12]
 8001bae:	4618      	mov	r0, r3
 8001bb0:	f7ff fef6 	bl	80019a0 <osalThreadQueueObjectInit.lto_priv.745>
  iqp->q_counter = 0;
 8001bb4:	9b03      	ldr	r3, [sp, #12]
 8001bb6:	2200      	movs	r2, #0
 8001bb8:	609a      	str	r2, [r3, #8]
  iqp->q_buffer  = bp;
 8001bba:	9b03      	ldr	r3, [sp, #12]
 8001bbc:	9a02      	ldr	r2, [sp, #8]
 8001bbe:	60da      	str	r2, [r3, #12]
  iqp->q_rdptr   = bp;
 8001bc0:	9b03      	ldr	r3, [sp, #12]
 8001bc2:	9a02      	ldr	r2, [sp, #8]
 8001bc4:	619a      	str	r2, [r3, #24]
  iqp->q_wrptr   = bp;
 8001bc6:	9b03      	ldr	r3, [sp, #12]
 8001bc8:	9a02      	ldr	r2, [sp, #8]
 8001bca:	615a      	str	r2, [r3, #20]
  iqp->q_top     = bp + size;
 8001bcc:	9a02      	ldr	r2, [sp, #8]
 8001bce:	9b01      	ldr	r3, [sp, #4]
 8001bd0:	441a      	add	r2, r3
 8001bd2:	9b03      	ldr	r3, [sp, #12]
 8001bd4:	611a      	str	r2, [r3, #16]
  iqp->q_notify  = infy;
 8001bd6:	9b03      	ldr	r3, [sp, #12]
 8001bd8:	9a00      	ldr	r2, [sp, #0]
 8001bda:	61da      	str	r2, [r3, #28]
  iqp->q_link    = link;
 8001bdc:	9b03      	ldr	r3, [sp, #12]
 8001bde:	9a06      	ldr	r2, [sp, #24]
 8001be0:	621a      	str	r2, [r3, #32]
}
 8001be2:	b005      	add	sp, #20
 8001be4:	f85d fb04 	ldr.w	pc, [sp], #4
	...

08001bf0 <iqPutI>:
 * @retval MSG_OK       if the operation has been completed with success.
 * @retval MSG_TIMEOUT  if the queue is full.
 *
 * @iclass
 */
msg_t iqPutI(input_queue_t *iqp, uint8_t b) {
 8001bf0:	b500      	push	{lr}
 8001bf2:	b083      	sub	sp, #12
 8001bf4:	9001      	str	r0, [sp, #4]
 8001bf6:	460b      	mov	r3, r1
 8001bf8:	f88d 3003 	strb.w	r3, [sp, #3]

  osalDbgCheckClassI();
 8001bfc:	f004 fcb8 	bl	8006570 <chDbgCheckClassI>

  /* Queue space check.*/
  if (!iqIsFullI(iqp)) {
 8001c00:	9b01      	ldr	r3, [sp, #4]
 8001c02:	695a      	ldr	r2, [r3, #20]
 8001c04:	9b01      	ldr	r3, [sp, #4]
 8001c06:	699b      	ldr	r3, [r3, #24]
 8001c08:	429a      	cmp	r2, r3
 8001c0a:	d105      	bne.n	8001c18 <iqPutI+0x28>
 8001c0c:	9b01      	ldr	r3, [sp, #4]
 8001c0e:	689b      	ldr	r3, [r3, #8]
 8001c10:	2b00      	cmp	r3, #0
 8001c12:	d001      	beq.n	8001c18 <iqPutI+0x28>
 8001c14:	2301      	movs	r3, #1
 8001c16:	e000      	b.n	8001c1a <iqPutI+0x2a>
 8001c18:	2300      	movs	r3, #0
 8001c1a:	f003 0301 	and.w	r3, r3, #1
 8001c1e:	b2db      	uxtb	r3, r3
 8001c20:	f083 0301 	eor.w	r3, r3, #1
 8001c24:	b2db      	uxtb	r3, r3
 8001c26:	2b00      	cmp	r3, #0
 8001c28:	d01d      	beq.n	8001c66 <iqPutI+0x76>
    iqp->q_counter++;
 8001c2a:	9b01      	ldr	r3, [sp, #4]
 8001c2c:	689b      	ldr	r3, [r3, #8]
 8001c2e:	1c5a      	adds	r2, r3, #1
 8001c30:	9b01      	ldr	r3, [sp, #4]
 8001c32:	609a      	str	r2, [r3, #8]
    *iqp->q_wrptr++ = b;
 8001c34:	9b01      	ldr	r3, [sp, #4]
 8001c36:	695b      	ldr	r3, [r3, #20]
 8001c38:	1c59      	adds	r1, r3, #1
 8001c3a:	9a01      	ldr	r2, [sp, #4]
 8001c3c:	6151      	str	r1, [r2, #20]
 8001c3e:	f89d 2003 	ldrb.w	r2, [sp, #3]
 8001c42:	701a      	strb	r2, [r3, #0]
    if (iqp->q_wrptr >= iqp->q_top) {
 8001c44:	9b01      	ldr	r3, [sp, #4]
 8001c46:	695a      	ldr	r2, [r3, #20]
 8001c48:	9b01      	ldr	r3, [sp, #4]
 8001c4a:	691b      	ldr	r3, [r3, #16]
 8001c4c:	429a      	cmp	r2, r3
 8001c4e:	d303      	bcc.n	8001c58 <iqPutI+0x68>
      iqp->q_wrptr = iqp->q_buffer;
 8001c50:	9b01      	ldr	r3, [sp, #4]
 8001c52:	68da      	ldr	r2, [r3, #12]
 8001c54:	9b01      	ldr	r3, [sp, #4]
 8001c56:	615a      	str	r2, [r3, #20]
    }

    osalThreadDequeueNextI(&iqp->q_waiting, MSG_OK);
 8001c58:	9b01      	ldr	r3, [sp, #4]
 8001c5a:	2100      	movs	r1, #0
 8001c5c:	4618      	mov	r0, r3
 8001c5e:	f7ff febf 	bl	80019e0 <osalThreadDequeueNextI.lto_priv.741>

    return MSG_OK;
 8001c62:	2300      	movs	r3, #0
 8001c64:	e001      	b.n	8001c6a <iqPutI+0x7a>
  }

  return MSG_TIMEOUT;
 8001c66:	f04f 33ff 	mov.w	r3, #4294967295
}
 8001c6a:	4618      	mov	r0, r3
 8001c6c:	b003      	add	sp, #12
 8001c6e:	f85d fb04 	ldr.w	pc, [sp], #4
 8001c72:	bf00      	nop
	...

08001c80 <iqGetTimeout>:
 * @retval MSG_TIMEOUT  if the specified time expired.
 * @retval MSG_RESET    if the queue has been reset.
 *
 * @api
 */
msg_t iqGetTimeout(input_queue_t *iqp, sysinterval_t timeout) {
 8001c80:	b500      	push	{lr}
 8001c82:	b085      	sub	sp, #20
 8001c84:	9001      	str	r0, [sp, #4]
 8001c86:	9100      	str	r1, [sp, #0]
  uint8_t b;

  osalSysLock();
 8001c88:	f7ff fe7a 	bl	8001980 <osalSysLock.lto_priv.484>
 8001c8c:	e00c      	b.n	8001ca8 <iqGetTimeout+0x28>

  /* Waiting until there is a character available or a timeout occurs.*/
  while (iqIsEmptyI(iqp)) {
    msg_t msg = osalThreadEnqueueTimeoutS(&iqp->q_waiting, timeout);
 8001c8e:	9b01      	ldr	r3, [sp, #4]
 8001c90:	9900      	ldr	r1, [sp, #0]
 8001c92:	4618      	mov	r0, r3
 8001c94:	f7ff fe94 	bl	80019c0 <osalThreadEnqueueTimeoutS.lto_priv.743>
 8001c98:	9002      	str	r0, [sp, #8]
    if (msg < MSG_OK) {
 8001c9a:	9b02      	ldr	r3, [sp, #8]
 8001c9c:	2b00      	cmp	r3, #0
 8001c9e:	da03      	bge.n	8001ca8 <iqGetTimeout+0x28>
      osalSysUnlock();
 8001ca0:	f7ff fe76 	bl	8001990 <osalSysUnlock.lto_priv.473>
      return msg;
 8001ca4:	9b02      	ldr	r3, [sp, #8]
 8001ca6:	e026      	b.n	8001cf6 <iqGetTimeout+0x76>
  while (iqIsEmptyI(iqp)) {
 8001ca8:	9b01      	ldr	r3, [sp, #4]
 8001caa:	689b      	ldr	r3, [r3, #8]
 8001cac:	2b00      	cmp	r3, #0
 8001cae:	d0ee      	beq.n	8001c8e <iqGetTimeout+0xe>
    }
  }

  /* Getting the character from the queue.*/
  iqp->q_counter--;
 8001cb0:	9b01      	ldr	r3, [sp, #4]
 8001cb2:	689b      	ldr	r3, [r3, #8]
 8001cb4:	1e5a      	subs	r2, r3, #1
 8001cb6:	9b01      	ldr	r3, [sp, #4]
 8001cb8:	609a      	str	r2, [r3, #8]
  b = *iqp->q_rdptr++;
 8001cba:	9b01      	ldr	r3, [sp, #4]
 8001cbc:	699b      	ldr	r3, [r3, #24]
 8001cbe:	1c59      	adds	r1, r3, #1
 8001cc0:	9a01      	ldr	r2, [sp, #4]
 8001cc2:	6191      	str	r1, [r2, #24]
 8001cc4:	781b      	ldrb	r3, [r3, #0]
 8001cc6:	f88d 300f 	strb.w	r3, [sp, #15]
  if (iqp->q_rdptr >= iqp->q_top) {
 8001cca:	9b01      	ldr	r3, [sp, #4]
 8001ccc:	699a      	ldr	r2, [r3, #24]
 8001cce:	9b01      	ldr	r3, [sp, #4]
 8001cd0:	691b      	ldr	r3, [r3, #16]
 8001cd2:	429a      	cmp	r2, r3
 8001cd4:	d303      	bcc.n	8001cde <iqGetTimeout+0x5e>
    iqp->q_rdptr = iqp->q_buffer;
 8001cd6:	9b01      	ldr	r3, [sp, #4]
 8001cd8:	68da      	ldr	r2, [r3, #12]
 8001cda:	9b01      	ldr	r3, [sp, #4]
 8001cdc:	619a      	str	r2, [r3, #24]
  }

  /* Inform the low side that the queue has at least one slot available.*/
  if (iqp->q_notify != NULL) {
 8001cde:	9b01      	ldr	r3, [sp, #4]
 8001ce0:	69db      	ldr	r3, [r3, #28]
 8001ce2:	2b00      	cmp	r3, #0
 8001ce4:	d003      	beq.n	8001cee <iqGetTimeout+0x6e>
    iqp->q_notify(iqp);
 8001ce6:	9b01      	ldr	r3, [sp, #4]
 8001ce8:	69db      	ldr	r3, [r3, #28]
 8001cea:	9801      	ldr	r0, [sp, #4]
 8001cec:	4798      	blx	r3
  }

  osalSysUnlock();
 8001cee:	f7ff fe4f 	bl	8001990 <osalSysUnlock.lto_priv.473>

  return (msg_t)b;
 8001cf2:	f89d 300f 	ldrb.w	r3, [sp, #15]
}
 8001cf6:	4618      	mov	r0, r3
 8001cf8:	b005      	add	sp, #20
 8001cfa:	f85d fb04 	ldr.w	pc, [sp], #4
 8001cfe:	bf00      	nop

08001d00 <iqReadTimeout>:
 * @return              The number of bytes effectively transferred.
 *
 * @api
 */
size_t iqReadTimeout(input_queue_t *iqp, uint8_t *bp,
                     size_t n, sysinterval_t timeout) {
 8001d00:	b500      	push	{lr}
 8001d02:	b089      	sub	sp, #36	; 0x24
 8001d04:	9003      	str	r0, [sp, #12]
 8001d06:	9102      	str	r1, [sp, #8]
 8001d08:	9201      	str	r2, [sp, #4]
 8001d0a:	9300      	str	r3, [sp, #0]
  qnotify_t nfy = iqp->q_notify;
 8001d0c:	9b03      	ldr	r3, [sp, #12]
 8001d0e:	69db      	ldr	r3, [r3, #28]
 8001d10:	9307      	str	r3, [sp, #28]
  size_t max = n;
 8001d12:	9b01      	ldr	r3, [sp, #4]
 8001d14:	9306      	str	r3, [sp, #24]

  osalDbgCheck(n > 0U);
 8001d16:	9b01      	ldr	r3, [sp, #4]
 8001d18:	2b00      	cmp	r3, #0
 8001d1a:	d102      	bne.n	8001d22 <iqReadTimeout+0x22>
 8001d1c:	481b      	ldr	r0, [pc, #108]	; (8001d8c <iqReadTimeout+0x8c>)
 8001d1e:	f004 fb07 	bl	8006330 <chSysHalt>

  osalSysLock();
 8001d22:	f7ff fe2d 	bl	8001980 <osalSysLock.lto_priv.484>
 8001d26:	e024      	b.n	8001d72 <iqReadTimeout+0x72>

  while (n > 0U) {
    size_t done;

    done = iq_read(iqp, bp, n);
 8001d28:	9a01      	ldr	r2, [sp, #4]
 8001d2a:	9902      	ldr	r1, [sp, #8]
 8001d2c:	9803      	ldr	r0, [sp, #12]
 8001d2e:	f7ff fe67 	bl	8001a00 <iq_read>
 8001d32:	9005      	str	r0, [sp, #20]
    if (done == (size_t)0) {
 8001d34:	9b05      	ldr	r3, [sp, #20]
 8001d36:	2b00      	cmp	r3, #0
 8001d38:	d109      	bne.n	8001d4e <iqReadTimeout+0x4e>
      msg_t msg = osalThreadEnqueueTimeoutS(&iqp->q_waiting, timeout);
 8001d3a:	9b03      	ldr	r3, [sp, #12]
 8001d3c:	9900      	ldr	r1, [sp, #0]
 8001d3e:	4618      	mov	r0, r3
 8001d40:	f7ff fe3e 	bl	80019c0 <osalThreadEnqueueTimeoutS.lto_priv.743>
 8001d44:	9004      	str	r0, [sp, #16]

      /* Anything except MSG_OK causes the operation to stop.*/
      if (msg != MSG_OK) {
 8001d46:	9b04      	ldr	r3, [sp, #16]
 8001d48:	2b00      	cmp	r3, #0
 8001d4a:	d115      	bne.n	8001d78 <iqReadTimeout+0x78>
 8001d4c:	e011      	b.n	8001d72 <iqReadTimeout+0x72>
      }
    }
    else {
      /* Inform the low side that the queue has at least one empty slot
         available.*/
      if (nfy != NULL) {
 8001d4e:	9b07      	ldr	r3, [sp, #28]
 8001d50:	2b00      	cmp	r3, #0
 8001d52:	d002      	beq.n	8001d5a <iqReadTimeout+0x5a>
        nfy(iqp);
 8001d54:	9b07      	ldr	r3, [sp, #28]
 8001d56:	9803      	ldr	r0, [sp, #12]
 8001d58:	4798      	blx	r3
      }

      /* Giving a preemption chance in a controlled point.*/
      osalSysUnlock();
 8001d5a:	f7ff fe19 	bl	8001990 <osalSysUnlock.lto_priv.473>

      n  -= done;
 8001d5e:	9a01      	ldr	r2, [sp, #4]
 8001d60:	9b05      	ldr	r3, [sp, #20]
 8001d62:	1ad3      	subs	r3, r2, r3
 8001d64:	9301      	str	r3, [sp, #4]
      bp += done;
 8001d66:	9a02      	ldr	r2, [sp, #8]
 8001d68:	9b05      	ldr	r3, [sp, #20]
 8001d6a:	4413      	add	r3, r2
 8001d6c:	9302      	str	r3, [sp, #8]

      osalSysLock();
 8001d6e:	f7ff fe07 	bl	8001980 <osalSysLock.lto_priv.484>
  while (n > 0U) {
 8001d72:	9b01      	ldr	r3, [sp, #4]
 8001d74:	2b00      	cmp	r3, #0
 8001d76:	d1d7      	bne.n	8001d28 <iqReadTimeout+0x28>
    }
  }

  osalSysUnlock();
 8001d78:	f7ff fe0a 	bl	8001990 <osalSysUnlock.lto_priv.473>
  return max - n;
 8001d7c:	9a06      	ldr	r2, [sp, #24]
 8001d7e:	9b01      	ldr	r3, [sp, #4]
 8001d80:	1ad3      	subs	r3, r2, r3
}
 8001d82:	4618      	mov	r0, r3
 8001d84:	b009      	add	sp, #36	; 0x24
 8001d86:	f85d fb04 	ldr.w	pc, [sp], #4
 8001d8a:	bf00      	nop
 8001d8c:	080087b4 	.word	0x080087b4

08001d90 <oqObjectInit>:
 * @param[in] link      application defined pointer
 *
 * @init
 */
void oqObjectInit(output_queue_t *oqp, uint8_t *bp, size_t size,
                  qnotify_t onfy, void *link) {
 8001d90:	b500      	push	{lr}
 8001d92:	b085      	sub	sp, #20
 8001d94:	9003      	str	r0, [sp, #12]
 8001d96:	9102      	str	r1, [sp, #8]
 8001d98:	9201      	str	r2, [sp, #4]
 8001d9a:	9300      	str	r3, [sp, #0]

  osalThreadQueueObjectInit(&oqp->q_waiting);
 8001d9c:	9b03      	ldr	r3, [sp, #12]
 8001d9e:	4618      	mov	r0, r3
 8001da0:	f7ff fdfe 	bl	80019a0 <osalThreadQueueObjectInit.lto_priv.745>
  oqp->q_counter = size;
 8001da4:	9b03      	ldr	r3, [sp, #12]
 8001da6:	9a01      	ldr	r2, [sp, #4]
 8001da8:	609a      	str	r2, [r3, #8]
  oqp->q_buffer  = bp;
 8001daa:	9b03      	ldr	r3, [sp, #12]
 8001dac:	9a02      	ldr	r2, [sp, #8]
 8001dae:	60da      	str	r2, [r3, #12]
  oqp->q_rdptr   = bp;
 8001db0:	9b03      	ldr	r3, [sp, #12]
 8001db2:	9a02      	ldr	r2, [sp, #8]
 8001db4:	619a      	str	r2, [r3, #24]
  oqp->q_wrptr   = bp;
 8001db6:	9b03      	ldr	r3, [sp, #12]
 8001db8:	9a02      	ldr	r2, [sp, #8]
 8001dba:	615a      	str	r2, [r3, #20]
  oqp->q_top     = bp + size;
 8001dbc:	9a02      	ldr	r2, [sp, #8]
 8001dbe:	9b01      	ldr	r3, [sp, #4]
 8001dc0:	441a      	add	r2, r3
 8001dc2:	9b03      	ldr	r3, [sp, #12]
 8001dc4:	611a      	str	r2, [r3, #16]
  oqp->q_notify  = onfy;
 8001dc6:	9b03      	ldr	r3, [sp, #12]
 8001dc8:	9a00      	ldr	r2, [sp, #0]
 8001dca:	61da      	str	r2, [r3, #28]
  oqp->q_link    = link;
 8001dcc:	9b03      	ldr	r3, [sp, #12]
 8001dce:	9a06      	ldr	r2, [sp, #24]
 8001dd0:	621a      	str	r2, [r3, #32]
}
 8001dd2:	b005      	add	sp, #20
 8001dd4:	f85d fb04 	ldr.w	pc, [sp], #4
	...

08001de0 <oqPutTimeout>:
 * @retval MSG_TIMEOUT  if the specified time expired.
 * @retval MSG_RESET    if the queue has been reset.
 *
 * @api
 */
msg_t oqPutTimeout(output_queue_t *oqp, uint8_t b, sysinterval_t timeout) {
 8001de0:	b500      	push	{lr}
 8001de2:	b087      	sub	sp, #28
 8001de4:	9003      	str	r0, [sp, #12]
 8001de6:	460b      	mov	r3, r1
 8001de8:	9201      	str	r2, [sp, #4]
 8001dea:	f88d 300b 	strb.w	r3, [sp, #11]

  osalSysLock();
 8001dee:	f7ff fdc7 	bl	8001980 <osalSysLock.lto_priv.484>
 8001df2:	e00c      	b.n	8001e0e <oqPutTimeout+0x2e>

  /* Waiting until there is a slot available or a timeout occurs.*/
  while (oqIsFullI(oqp)) {
    msg_t msg = osalThreadEnqueueTimeoutS(&oqp->q_waiting, timeout);
 8001df4:	9b03      	ldr	r3, [sp, #12]
 8001df6:	9901      	ldr	r1, [sp, #4]
 8001df8:	4618      	mov	r0, r3
 8001dfa:	f7ff fde1 	bl	80019c0 <osalThreadEnqueueTimeoutS.lto_priv.743>
 8001dfe:	9005      	str	r0, [sp, #20]
    if (msg < MSG_OK) {
 8001e00:	9b05      	ldr	r3, [sp, #20]
 8001e02:	2b00      	cmp	r3, #0
 8001e04:	da03      	bge.n	8001e0e <oqPutTimeout+0x2e>
      osalSysUnlock();
 8001e06:	f7ff fdc3 	bl	8001990 <osalSysUnlock.lto_priv.473>
      return msg;
 8001e0a:	9b05      	ldr	r3, [sp, #20]
 8001e0c:	e025      	b.n	8001e5a <oqPutTimeout+0x7a>
  while (oqIsFullI(oqp)) {
 8001e0e:	9b03      	ldr	r3, [sp, #12]
 8001e10:	689b      	ldr	r3, [r3, #8]
 8001e12:	2b00      	cmp	r3, #0
 8001e14:	d0ee      	beq.n	8001df4 <oqPutTimeout+0x14>
    }
  }

  /* Putting the character into the queue.*/
  oqp->q_counter--;
 8001e16:	9b03      	ldr	r3, [sp, #12]
 8001e18:	689b      	ldr	r3, [r3, #8]
 8001e1a:	1e5a      	subs	r2, r3, #1
 8001e1c:	9b03      	ldr	r3, [sp, #12]
 8001e1e:	609a      	str	r2, [r3, #8]
  *oqp->q_wrptr++ = b;
 8001e20:	9b03      	ldr	r3, [sp, #12]
 8001e22:	695b      	ldr	r3, [r3, #20]
 8001e24:	1c59      	adds	r1, r3, #1
 8001e26:	9a03      	ldr	r2, [sp, #12]
 8001e28:	6151      	str	r1, [r2, #20]
 8001e2a:	f89d 200b 	ldrb.w	r2, [sp, #11]
 8001e2e:	701a      	strb	r2, [r3, #0]
  if (oqp->q_wrptr >= oqp->q_top) {
 8001e30:	9b03      	ldr	r3, [sp, #12]
 8001e32:	695a      	ldr	r2, [r3, #20]
 8001e34:	9b03      	ldr	r3, [sp, #12]
 8001e36:	691b      	ldr	r3, [r3, #16]
 8001e38:	429a      	cmp	r2, r3
 8001e3a:	d303      	bcc.n	8001e44 <oqPutTimeout+0x64>
    oqp->q_wrptr = oqp->q_buffer;
 8001e3c:	9b03      	ldr	r3, [sp, #12]
 8001e3e:	68da      	ldr	r2, [r3, #12]
 8001e40:	9b03      	ldr	r3, [sp, #12]
 8001e42:	615a      	str	r2, [r3, #20]
  }

  /* Inform the low side that the queue has at least one character available.*/
  if (oqp->q_notify != NULL) {
 8001e44:	9b03      	ldr	r3, [sp, #12]
 8001e46:	69db      	ldr	r3, [r3, #28]
 8001e48:	2b00      	cmp	r3, #0
 8001e4a:	d003      	beq.n	8001e54 <oqPutTimeout+0x74>
    oqp->q_notify(oqp);
 8001e4c:	9b03      	ldr	r3, [sp, #12]
 8001e4e:	69db      	ldr	r3, [r3, #28]
 8001e50:	9803      	ldr	r0, [sp, #12]
 8001e52:	4798      	blx	r3
  }

  osalSysUnlock();
 8001e54:	f7ff fd9c 	bl	8001990 <osalSysUnlock.lto_priv.473>

  return MSG_OK;
 8001e58:	2300      	movs	r3, #0
}
 8001e5a:	4618      	mov	r0, r3
 8001e5c:	b007      	add	sp, #28
 8001e5e:	f85d fb04 	ldr.w	pc, [sp], #4
 8001e62:	bf00      	nop
	...

08001e70 <oqGetI>:
 * @return              The byte value from the queue.
 * @retval MSG_TIMEOUT  if the queue is empty.
 *
 * @iclass
 */
msg_t oqGetI(output_queue_t *oqp) {
 8001e70:	b500      	push	{lr}
 8001e72:	b085      	sub	sp, #20
 8001e74:	9001      	str	r0, [sp, #4]

  osalDbgCheckClassI();
 8001e76:	f004 fb7b 	bl	8006570 <chDbgCheckClassI>

  /* Queue data check.*/
  if (!oqIsEmptyI(oqp)) {
 8001e7a:	9b01      	ldr	r3, [sp, #4]
 8001e7c:	695a      	ldr	r2, [r3, #20]
 8001e7e:	9b01      	ldr	r3, [sp, #4]
 8001e80:	699b      	ldr	r3, [r3, #24]
 8001e82:	429a      	cmp	r2, r3
 8001e84:	d105      	bne.n	8001e92 <oqGetI+0x22>
 8001e86:	9b01      	ldr	r3, [sp, #4]
 8001e88:	689b      	ldr	r3, [r3, #8]
 8001e8a:	2b00      	cmp	r3, #0
 8001e8c:	d001      	beq.n	8001e92 <oqGetI+0x22>
 8001e8e:	2301      	movs	r3, #1
 8001e90:	e000      	b.n	8001e94 <oqGetI+0x24>
 8001e92:	2300      	movs	r3, #0
 8001e94:	f003 0301 	and.w	r3, r3, #1
 8001e98:	b2db      	uxtb	r3, r3
 8001e9a:	f083 0301 	eor.w	r3, r3, #1
 8001e9e:	b2db      	uxtb	r3, r3
 8001ea0:	2b00      	cmp	r3, #0
 8001ea2:	d01e      	beq.n	8001ee2 <oqGetI+0x72>
    uint8_t b;

    oqp->q_counter++;
 8001ea4:	9b01      	ldr	r3, [sp, #4]
 8001ea6:	689b      	ldr	r3, [r3, #8]
 8001ea8:	1c5a      	adds	r2, r3, #1
 8001eaa:	9b01      	ldr	r3, [sp, #4]
 8001eac:	609a      	str	r2, [r3, #8]
    b = *oqp->q_rdptr++;
 8001eae:	9b01      	ldr	r3, [sp, #4]
 8001eb0:	699b      	ldr	r3, [r3, #24]
 8001eb2:	1c59      	adds	r1, r3, #1
 8001eb4:	9a01      	ldr	r2, [sp, #4]
 8001eb6:	6191      	str	r1, [r2, #24]
 8001eb8:	781b      	ldrb	r3, [r3, #0]
 8001eba:	f88d 300f 	strb.w	r3, [sp, #15]
    if (oqp->q_rdptr >= oqp->q_top) {
 8001ebe:	9b01      	ldr	r3, [sp, #4]
 8001ec0:	699a      	ldr	r2, [r3, #24]
 8001ec2:	9b01      	ldr	r3, [sp, #4]
 8001ec4:	691b      	ldr	r3, [r3, #16]
 8001ec6:	429a      	cmp	r2, r3
 8001ec8:	d303      	bcc.n	8001ed2 <oqGetI+0x62>
      oqp->q_rdptr = oqp->q_buffer;
 8001eca:	9b01      	ldr	r3, [sp, #4]
 8001ecc:	68da      	ldr	r2, [r3, #12]
 8001ece:	9b01      	ldr	r3, [sp, #4]
 8001ed0:	619a      	str	r2, [r3, #24]
    }

    osalThreadDequeueNextI(&oqp->q_waiting, MSG_OK);
 8001ed2:	9b01      	ldr	r3, [sp, #4]
 8001ed4:	2100      	movs	r1, #0
 8001ed6:	4618      	mov	r0, r3
 8001ed8:	f7ff fd82 	bl	80019e0 <osalThreadDequeueNextI.lto_priv.741>

    return (msg_t)b;
 8001edc:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8001ee0:	e001      	b.n	8001ee6 <oqGetI+0x76>
  }

  return MSG_TIMEOUT;
 8001ee2:	f04f 33ff 	mov.w	r3, #4294967295
}
 8001ee6:	4618      	mov	r0, r3
 8001ee8:	b005      	add	sp, #20
 8001eea:	f85d fb04 	ldr.w	pc, [sp], #4
 8001eee:	bf00      	nop

08001ef0 <oqWriteTimeout>:
 * @return              The number of bytes effectively transferred.
 *
 * @api
 */
size_t oqWriteTimeout(output_queue_t *oqp, const uint8_t *bp,
                      size_t n, sysinterval_t timeout) {
 8001ef0:	b500      	push	{lr}
 8001ef2:	b089      	sub	sp, #36	; 0x24
 8001ef4:	9003      	str	r0, [sp, #12]
 8001ef6:	9102      	str	r1, [sp, #8]
 8001ef8:	9201      	str	r2, [sp, #4]
 8001efa:	9300      	str	r3, [sp, #0]
  qnotify_t nfy = oqp->q_notify;
 8001efc:	9b03      	ldr	r3, [sp, #12]
 8001efe:	69db      	ldr	r3, [r3, #28]
 8001f00:	9307      	str	r3, [sp, #28]
  size_t max = n;
 8001f02:	9b01      	ldr	r3, [sp, #4]
 8001f04:	9306      	str	r3, [sp, #24]

  osalDbgCheck(n > 0U);
 8001f06:	9b01      	ldr	r3, [sp, #4]
 8001f08:	2b00      	cmp	r3, #0
 8001f0a:	d102      	bne.n	8001f12 <oqWriteTimeout+0x22>
 8001f0c:	481b      	ldr	r0, [pc, #108]	; (8001f7c <oqWriteTimeout+0x8c>)
 8001f0e:	f004 fa0f 	bl	8006330 <chSysHalt>

  osalSysLock();
 8001f12:	f7ff fd35 	bl	8001980 <osalSysLock.lto_priv.484>
 8001f16:	e024      	b.n	8001f62 <oqWriteTimeout+0x72>

  while (n > 0U) {
    size_t done;

    done = oq_write(oqp, bp, n);
 8001f18:	9a01      	ldr	r2, [sp, #4]
 8001f1a:	9902      	ldr	r1, [sp, #8]
 8001f1c:	9803      	ldr	r0, [sp, #12]
 8001f1e:	f7ff fdd7 	bl	8001ad0 <oq_write>
 8001f22:	9005      	str	r0, [sp, #20]
    if (done == (size_t)0) {
 8001f24:	9b05      	ldr	r3, [sp, #20]
 8001f26:	2b00      	cmp	r3, #0
 8001f28:	d109      	bne.n	8001f3e <oqWriteTimeout+0x4e>
      msg_t msg = osalThreadEnqueueTimeoutS(&oqp->q_waiting, timeout);
 8001f2a:	9b03      	ldr	r3, [sp, #12]
 8001f2c:	9900      	ldr	r1, [sp, #0]
 8001f2e:	4618      	mov	r0, r3
 8001f30:	f7ff fd46 	bl	80019c0 <osalThreadEnqueueTimeoutS.lto_priv.743>
 8001f34:	9004      	str	r0, [sp, #16]

      /* Anything except MSG_OK causes the operation to stop.*/
      if (msg != MSG_OK) {
 8001f36:	9b04      	ldr	r3, [sp, #16]
 8001f38:	2b00      	cmp	r3, #0
 8001f3a:	d115      	bne.n	8001f68 <oqWriteTimeout+0x78>
 8001f3c:	e011      	b.n	8001f62 <oqWriteTimeout+0x72>
      }
    }
    else {
      /* Inform the low side that the queue has at least one character
         available.*/
      if (nfy != NULL) {
 8001f3e:	9b07      	ldr	r3, [sp, #28]
 8001f40:	2b00      	cmp	r3, #0
 8001f42:	d002      	beq.n	8001f4a <oqWriteTimeout+0x5a>
        nfy(oqp);
 8001f44:	9b07      	ldr	r3, [sp, #28]
 8001f46:	9803      	ldr	r0, [sp, #12]
 8001f48:	4798      	blx	r3
      }

      /* Giving a preemption chance in a controlled point.*/
      osalSysUnlock();
 8001f4a:	f7ff fd21 	bl	8001990 <osalSysUnlock.lto_priv.473>

      n  -= done;
 8001f4e:	9a01      	ldr	r2, [sp, #4]
 8001f50:	9b05      	ldr	r3, [sp, #20]
 8001f52:	1ad3      	subs	r3, r2, r3
 8001f54:	9301      	str	r3, [sp, #4]
      bp += done;
 8001f56:	9a02      	ldr	r2, [sp, #8]
 8001f58:	9b05      	ldr	r3, [sp, #20]
 8001f5a:	4413      	add	r3, r2
 8001f5c:	9302      	str	r3, [sp, #8]

      osalSysLock();
 8001f5e:	f7ff fd0f 	bl	8001980 <osalSysLock.lto_priv.484>
  while (n > 0U) {
 8001f62:	9b01      	ldr	r3, [sp, #4]
 8001f64:	2b00      	cmp	r3, #0
 8001f66:	d1d7      	bne.n	8001f18 <oqWriteTimeout+0x28>
    }
  }

  osalSysUnlock();
 8001f68:	f7ff fd12 	bl	8001990 <osalSysUnlock.lto_priv.473>
  return max - n;
 8001f6c:	9a06      	ldr	r2, [sp, #24]
 8001f6e:	9b01      	ldr	r3, [sp, #4]
 8001f70:	1ad3      	subs	r3, r2, r3
}
 8001f72:	4618      	mov	r0, r3
 8001f74:	b009      	add	sp, #36	; 0x24
 8001f76:	f85d fb04 	ldr.w	pc, [sp], #4
 8001f7a:	bf00      	nop
 8001f7c:	080087c4 	.word	0x080087c4

08001f80 <pwmInit>:
 * @note    This function is implicitly invoked by @p halInit(), there is
 *          no need to explicitly initialize the driver.
 *
 * @init
 */
void pwmInit(void) {
 8001f80:	b508      	push	{r3, lr}

  pwm_lld_init();
 8001f82:	f003 fd45 	bl	8005a10 <pwm_lld_init>
}
 8001f86:	bd08      	pop	{r3, pc}
	...

08001f90 <pwmObjectInit>:
 *
 * @param[out] pwmp     pointer to a @p PWMDriver object
 *
 * @init
 */
void pwmObjectInit(PWMDriver *pwmp) {
 8001f90:	b082      	sub	sp, #8
 8001f92:	9001      	str	r0, [sp, #4]

  pwmp->state    = PWM_STOP;
 8001f94:	9b01      	ldr	r3, [sp, #4]
 8001f96:	2201      	movs	r2, #1
 8001f98:	701a      	strb	r2, [r3, #0]
  pwmp->config   = NULL;
 8001f9a:	9b01      	ldr	r3, [sp, #4]
 8001f9c:	2200      	movs	r2, #0
 8001f9e:	605a      	str	r2, [r3, #4]
  pwmp->enabled  = 0;
 8001fa0:	9b01      	ldr	r3, [sp, #4]
 8001fa2:	2200      	movs	r2, #0
 8001fa4:	60da      	str	r2, [r3, #12]
  pwmp->channels = 0;
 8001fa6:	9b01      	ldr	r3, [sp, #4]
 8001fa8:	2200      	movs	r2, #0
 8001faa:	741a      	strb	r2, [r3, #16]
#if defined(PWM_DRIVER_EXT_INIT_HOOK)
  PWM_DRIVER_EXT_INIT_HOOK(pwmp);
#endif
}
 8001fac:	b002      	add	sp, #8
 8001fae:	4770      	bx	lr

08001fb0 <chEvtObjectInit.lto_priv.494>:
 *
 * @param[in] esp       pointer to the @p event_source_t structure
 *
 * @init
 */
static inline void chEvtObjectInit(event_source_t *esp) {
 8001fb0:	b082      	sub	sp, #8
 8001fb2:	9001      	str	r0, [sp, #4]

  esp->next = (event_listener_t *)esp;
 8001fb4:	9b01      	ldr	r3, [sp, #4]
 8001fb6:	9a01      	ldr	r2, [sp, #4]
 8001fb8:	601a      	str	r2, [r3, #0]
}
 8001fba:	b002      	add	sp, #8
 8001fbc:	4770      	bx	lr
 8001fbe:	bf00      	nop

08001fc0 <osalEventObjectInit.lto_priv.724>:
 *
 * @param[out] esp      pointer to the event source object
 *
 * @init
 */
static inline void osalEventObjectInit(event_source_t *esp) {
 8001fc0:	b500      	push	{lr}
 8001fc2:	b083      	sub	sp, #12
 8001fc4:	9001      	str	r0, [sp, #4]

  chEvtObjectInit(esp);
 8001fc6:	9801      	ldr	r0, [sp, #4]
 8001fc8:	f7ff fff2 	bl	8001fb0 <chEvtObjectInit.lto_priv.494>
}
 8001fcc:	b003      	add	sp, #12
 8001fce:	f85d fb04 	ldr.w	pc, [sp], #4
 8001fd2:	bf00      	nop
	...

08001fe0 <osalEventBroadcastFlagsI.lto_priv.658>:
 * @param[in] flags     flags to be ORed to the flags mask
 *
 * @iclass
 */
static inline void osalEventBroadcastFlagsI(event_source_t *esp,
                                            eventflags_t flags) {
 8001fe0:	b500      	push	{lr}
 8001fe2:	b083      	sub	sp, #12
 8001fe4:	9001      	str	r0, [sp, #4]
 8001fe6:	9100      	str	r1, [sp, #0]

  chEvtBroadcastFlagsI(esp, flags);
 8001fe8:	9900      	ldr	r1, [sp, #0]
 8001fea:	9801      	ldr	r0, [sp, #4]
 8001fec:	f005 ff28 	bl	8007e40 <chEvtBroadcastFlagsI>
}
 8001ff0:	b003      	add	sp, #12
 8001ff2:	f85d fb04 	ldr.w	pc, [sp], #4
 8001ff6:	bf00      	nop
	...

08002000 <_write.lto_priv.222>:
/*
 * Interface implementation, the following functions just invoke the equivalent
 * queue-level function or macro.
 */

static size_t _write(void *ip, const uint8_t *bp, size_t n) {
 8002000:	b500      	push	{lr}
 8002002:	b085      	sub	sp, #20
 8002004:	9003      	str	r0, [sp, #12]
 8002006:	9102      	str	r1, [sp, #8]
 8002008:	9201      	str	r2, [sp, #4]

  return oqWriteTimeout(&((SerialDriver *)ip)->oqueue, bp,
 800200a:	9b03      	ldr	r3, [sp, #12]
 800200c:	f103 0030 	add.w	r0, r3, #48	; 0x30
 8002010:	f04f 33ff 	mov.w	r3, #4294967295
 8002014:	9a01      	ldr	r2, [sp, #4]
 8002016:	9902      	ldr	r1, [sp, #8]
 8002018:	f7ff ff6a 	bl	8001ef0 <oqWriteTimeout>
 800201c:	4603      	mov	r3, r0
                        n, TIME_INFINITE);
}
 800201e:	4618      	mov	r0, r3
 8002020:	b005      	add	sp, #20
 8002022:	f85d fb04 	ldr.w	pc, [sp], #4
 8002026:	bf00      	nop
	...

08002030 <_read.lto_priv.224>:

static size_t _read(void *ip, uint8_t *bp, size_t n) {
 8002030:	b500      	push	{lr}
 8002032:	b085      	sub	sp, #20
 8002034:	9003      	str	r0, [sp, #12]
 8002036:	9102      	str	r1, [sp, #8]
 8002038:	9201      	str	r2, [sp, #4]

  return iqReadTimeout(&((SerialDriver *)ip)->iqueue, bp,
 800203a:	9b03      	ldr	r3, [sp, #12]
 800203c:	f103 000c 	add.w	r0, r3, #12
 8002040:	f04f 33ff 	mov.w	r3, #4294967295
 8002044:	9a01      	ldr	r2, [sp, #4]
 8002046:	9902      	ldr	r1, [sp, #8]
 8002048:	f7ff fe5a 	bl	8001d00 <iqReadTimeout>
 800204c:	4603      	mov	r3, r0
                       n, TIME_INFINITE);
}
 800204e:	4618      	mov	r0, r3
 8002050:	b005      	add	sp, #20
 8002052:	f85d fb04 	ldr.w	pc, [sp], #4
 8002056:	bf00      	nop
	...

08002060 <_put.lto_priv.132>:

static msg_t _put(void *ip, uint8_t b) {
 8002060:	b500      	push	{lr}
 8002062:	b083      	sub	sp, #12
 8002064:	9001      	str	r0, [sp, #4]
 8002066:	460b      	mov	r3, r1
 8002068:	f88d 3003 	strb.w	r3, [sp, #3]

  return oqPutTimeout(&((SerialDriver *)ip)->oqueue, b, TIME_INFINITE);
 800206c:	9b01      	ldr	r3, [sp, #4]
 800206e:	3330      	adds	r3, #48	; 0x30
 8002070:	f89d 1003 	ldrb.w	r1, [sp, #3]
 8002074:	f04f 32ff 	mov.w	r2, #4294967295
 8002078:	4618      	mov	r0, r3
 800207a:	f7ff feb1 	bl	8001de0 <oqPutTimeout>
 800207e:	4603      	mov	r3, r0
}
 8002080:	4618      	mov	r0, r3
 8002082:	b003      	add	sp, #12
 8002084:	f85d fb04 	ldr.w	pc, [sp], #4
	...

08002090 <_get.lto_priv.135>:

static msg_t _get(void *ip) {
 8002090:	b500      	push	{lr}
 8002092:	b083      	sub	sp, #12
 8002094:	9001      	str	r0, [sp, #4]

  return iqGetTimeout(&((SerialDriver *)ip)->iqueue, TIME_INFINITE);
 8002096:	9b01      	ldr	r3, [sp, #4]
 8002098:	330c      	adds	r3, #12
 800209a:	f04f 31ff 	mov.w	r1, #4294967295
 800209e:	4618      	mov	r0, r3
 80020a0:	f7ff fdee 	bl	8001c80 <iqGetTimeout>
 80020a4:	4603      	mov	r3, r0
}
 80020a6:	4618      	mov	r0, r3
 80020a8:	b003      	add	sp, #12
 80020aa:	f85d fb04 	ldr.w	pc, [sp], #4
 80020ae:	bf00      	nop

080020b0 <_putt.lto_priv.226>:

static msg_t _putt(void *ip, uint8_t b, sysinterval_t timeout) {
 80020b0:	b500      	push	{lr}
 80020b2:	b085      	sub	sp, #20
 80020b4:	9003      	str	r0, [sp, #12]
 80020b6:	460b      	mov	r3, r1
 80020b8:	9201      	str	r2, [sp, #4]
 80020ba:	f88d 300b 	strb.w	r3, [sp, #11]

  return oqPutTimeout(&((SerialDriver *)ip)->oqueue, b, timeout);
 80020be:	9b03      	ldr	r3, [sp, #12]
 80020c0:	3330      	adds	r3, #48	; 0x30
 80020c2:	f89d 100b 	ldrb.w	r1, [sp, #11]
 80020c6:	9a01      	ldr	r2, [sp, #4]
 80020c8:	4618      	mov	r0, r3
 80020ca:	f7ff fe89 	bl	8001de0 <oqPutTimeout>
 80020ce:	4603      	mov	r3, r0
}
 80020d0:	4618      	mov	r0, r3
 80020d2:	b005      	add	sp, #20
 80020d4:	f85d fb04 	ldr.w	pc, [sp], #4
	...

080020e0 <_gett.lto_priv.228>:

static msg_t _gett(void *ip, sysinterval_t timeout) {
 80020e0:	b500      	push	{lr}
 80020e2:	b083      	sub	sp, #12
 80020e4:	9001      	str	r0, [sp, #4]
 80020e6:	9100      	str	r1, [sp, #0]

  return iqGetTimeout(&((SerialDriver *)ip)->iqueue, timeout);
 80020e8:	9b01      	ldr	r3, [sp, #4]
 80020ea:	330c      	adds	r3, #12
 80020ec:	9900      	ldr	r1, [sp, #0]
 80020ee:	4618      	mov	r0, r3
 80020f0:	f7ff fdc6 	bl	8001c80 <iqGetTimeout>
 80020f4:	4603      	mov	r3, r0
}
 80020f6:	4618      	mov	r0, r3
 80020f8:	b003      	add	sp, #12
 80020fa:	f85d fb04 	ldr.w	pc, [sp], #4
 80020fe:	bf00      	nop

08002100 <_writet.lto_priv.230>:

static size_t _writet(void *ip, const uint8_t *bp, size_t n,
                      sysinterval_t timeout) {
 8002100:	b500      	push	{lr}
 8002102:	b085      	sub	sp, #20
 8002104:	9003      	str	r0, [sp, #12]
 8002106:	9102      	str	r1, [sp, #8]
 8002108:	9201      	str	r2, [sp, #4]
 800210a:	9300      	str	r3, [sp, #0]

  return oqWriteTimeout(&((SerialDriver *)ip)->oqueue, bp, n, timeout);
 800210c:	9b03      	ldr	r3, [sp, #12]
 800210e:	f103 0030 	add.w	r0, r3, #48	; 0x30
 8002112:	9b00      	ldr	r3, [sp, #0]
 8002114:	9a01      	ldr	r2, [sp, #4]
 8002116:	9902      	ldr	r1, [sp, #8]
 8002118:	f7ff feea 	bl	8001ef0 <oqWriteTimeout>
 800211c:	4603      	mov	r3, r0
}
 800211e:	4618      	mov	r0, r3
 8002120:	b005      	add	sp, #20
 8002122:	f85d fb04 	ldr.w	pc, [sp], #4
 8002126:	bf00      	nop
	...

08002130 <_readt.lto_priv.232>:

static size_t _readt(void *ip, uint8_t *bp, size_t n,
                     sysinterval_t timeout) {
 8002130:	b500      	push	{lr}
 8002132:	b085      	sub	sp, #20
 8002134:	9003      	str	r0, [sp, #12]
 8002136:	9102      	str	r1, [sp, #8]
 8002138:	9201      	str	r2, [sp, #4]
 800213a:	9300      	str	r3, [sp, #0]

  return iqReadTimeout(&((SerialDriver *)ip)->iqueue, bp, n, timeout);
 800213c:	9b03      	ldr	r3, [sp, #12]
 800213e:	f103 000c 	add.w	r0, r3, #12
 8002142:	9b00      	ldr	r3, [sp, #0]
 8002144:	9a01      	ldr	r2, [sp, #4]
 8002146:	9902      	ldr	r1, [sp, #8]
 8002148:	f7ff fdda 	bl	8001d00 <iqReadTimeout>
 800214c:	4603      	mov	r3, r0
}
 800214e:	4618      	mov	r0, r3
 8002150:	b005      	add	sp, #20
 8002152:	f85d fb04 	ldr.w	pc, [sp], #4
 8002156:	bf00      	nop
	...

08002160 <_ctl.lto_priv.234>:

static msg_t _ctl(void *ip, unsigned int operation, void *arg) {
 8002160:	b500      	push	{lr}
 8002162:	b087      	sub	sp, #28
 8002164:	9003      	str	r0, [sp, #12]
 8002166:	9102      	str	r1, [sp, #8]
 8002168:	9201      	str	r2, [sp, #4]
  SerialDriver *sdp = (SerialDriver *)ip;
 800216a:	9b03      	ldr	r3, [sp, #12]
 800216c:	9305      	str	r3, [sp, #20]

  osalDbgCheck(sdp != NULL);
 800216e:	9b05      	ldr	r3, [sp, #20]
 8002170:	2b00      	cmp	r3, #0
 8002172:	d102      	bne.n	800217a <_ctl.lto_priv.234+0x1a>
 8002174:	480b      	ldr	r0, [pc, #44]	; (80021a4 <_ctl.lto_priv.234+0x44>)
 8002176:	f004 f8db 	bl	8006330 <chSysHalt>

  switch (operation) {
 800217a:	9b02      	ldr	r3, [sp, #8]
 800217c:	2b00      	cmp	r3, #0
 800217e:	d008      	beq.n	8002192 <_ctl.lto_priv.234+0x32>
 8002180:	2b01      	cmp	r3, #1
 8002182:	d109      	bne.n	8002198 <_ctl.lto_priv.234+0x38>
  case CHN_CTL_NOP:
    osalDbgCheck(arg == NULL);
 8002184:	9b01      	ldr	r3, [sp, #4]
 8002186:	2b00      	cmp	r3, #0
 8002188:	d006      	beq.n	8002198 <_ctl.lto_priv.234+0x38>
 800218a:	4806      	ldr	r0, [pc, #24]	; (80021a4 <_ctl.lto_priv.234+0x44>)
 800218c:	f004 f8d0 	bl	8006330 <chSysHalt>
 8002190:	e002      	b.n	8002198 <_ctl.lto_priv.234+0x38>
    break;
  case CHN_CTL_INVALID:
    osalDbgAssert(false, "invalid CTL operation");
 8002192:	4804      	ldr	r0, [pc, #16]	; (80021a4 <_ctl.lto_priv.234+0x44>)
 8002194:	f004 f8cc 	bl	8006330 <chSysHalt>
    return sd_lld_control(sdp, operation, arg);
#else
    break;
#endif
  }
  return MSG_OK;
 8002198:	2300      	movs	r3, #0
}
 800219a:	4618      	mov	r0, r3
 800219c:	b007      	add	sp, #28
 800219e:	f85d fb04 	ldr.w	pc, [sp], #4
 80021a2:	bf00      	nop
 80021a4:	080087fc 	.word	0x080087fc
	...

080021b0 <sdInit>:
 * @note    This function is implicitly invoked by @p halInit(), there is
 *          no need to explicitly initialize the driver.
 *
 * @init
 */
void sdInit(void) {
 80021b0:	b508      	push	{r3, lr}

  sd_lld_init();
 80021b2:	f003 fe0d 	bl	8005dd0 <sd_lld_init>
}
 80021b6:	bd08      	pop	{r3, pc}
	...

080021c0 <sdObjectInit>:
 * @init
 */
#if !defined(SERIAL_ADVANCED_BUFFERING_SUPPORT) ||                          \
    (SERIAL_ADVANCED_BUFFERING_SUPPORT == FALSE) ||                         \
    defined(__DOXYGEN__)
void sdObjectInit(SerialDriver *sdp, qnotify_t inotify, qnotify_t onotify) {
 80021c0:	b500      	push	{lr}
 80021c2:	b087      	sub	sp, #28
 80021c4:	9005      	str	r0, [sp, #20]
 80021c6:	9104      	str	r1, [sp, #16]
 80021c8:	9203      	str	r2, [sp, #12]

  sdp->vmt = &vmt;
 80021ca:	9b05      	ldr	r3, [sp, #20]
 80021cc:	4a12      	ldr	r2, [pc, #72]	; (8002218 <sdObjectInit+0x58>)
 80021ce:	601a      	str	r2, [r3, #0]
  osalEventObjectInit(&sdp->event);
 80021d0:	9b05      	ldr	r3, [sp, #20]
 80021d2:	3304      	adds	r3, #4
 80021d4:	4618      	mov	r0, r3
 80021d6:	f7ff fef3 	bl	8001fc0 <osalEventObjectInit.lto_priv.724>
  sdp->state = SD_STOP;
 80021da:	9b05      	ldr	r3, [sp, #20]
 80021dc:	2201      	movs	r2, #1
 80021de:	721a      	strb	r2, [r3, #8]
  iqObjectInit(&sdp->iqueue, sdp->ib, SERIAL_BUFFERS_SIZE, inotify, sdp);
 80021e0:	9b05      	ldr	r3, [sp, #20]
 80021e2:	f103 000c 	add.w	r0, r3, #12
 80021e6:	9b05      	ldr	r3, [sp, #20]
 80021e8:	f103 0154 	add.w	r1, r3, #84	; 0x54
 80021ec:	9b05      	ldr	r3, [sp, #20]
 80021ee:	9300      	str	r3, [sp, #0]
 80021f0:	9b04      	ldr	r3, [sp, #16]
 80021f2:	2210      	movs	r2, #16
 80021f4:	f7ff fcd4 	bl	8001ba0 <iqObjectInit>
  oqObjectInit(&sdp->oqueue, sdp->ob, SERIAL_BUFFERS_SIZE, onotify, sdp);
 80021f8:	9b05      	ldr	r3, [sp, #20]
 80021fa:	f103 0030 	add.w	r0, r3, #48	; 0x30
 80021fe:	9b05      	ldr	r3, [sp, #20]
 8002200:	f103 0164 	add.w	r1, r3, #100	; 0x64
 8002204:	9b05      	ldr	r3, [sp, #20]
 8002206:	9300      	str	r3, [sp, #0]
 8002208:	9b03      	ldr	r3, [sp, #12]
 800220a:	2210      	movs	r2, #16
 800220c:	f7ff fdc0 	bl	8001d90 <oqObjectInit>
}
 8002210:	b007      	add	sp, #28
 8002212:	f85d fb04 	ldr.w	pc, [sp], #4
 8002216:	bf00      	nop
 8002218:	080087d4 	.word	0x080087d4
 800221c:	00000000 	.word	0x00000000

08002220 <sdIncomingDataI>:
 * @param[in] sdp       pointer to a @p SerialDriver structure
 * @param[in] b         the byte to be written in the driver's Input Queue
 *
 * @iclass
 */
void sdIncomingDataI(SerialDriver *sdp, uint8_t b) {
 8002220:	b500      	push	{lr}
 8002222:	b083      	sub	sp, #12
 8002224:	9001      	str	r0, [sp, #4]
 8002226:	460b      	mov	r3, r1
 8002228:	f88d 3003 	strb.w	r3, [sp, #3]

  osalDbgCheckClassI();
 800222c:	f004 f9a0 	bl	8006570 <chDbgCheckClassI>
  osalDbgCheck(sdp != NULL);
 8002230:	9b01      	ldr	r3, [sp, #4]
 8002232:	2b00      	cmp	r3, #0
 8002234:	d102      	bne.n	800223c <sdIncomingDataI+0x1c>
 8002236:	4811      	ldr	r0, [pc, #68]	; (800227c <sdIncomingDataI+0x5c>)
 8002238:	f004 f87a 	bl	8006330 <chSysHalt>

  if (iqIsEmptyI(&sdp->iqueue))
 800223c:	9b01      	ldr	r3, [sp, #4]
 800223e:	695b      	ldr	r3, [r3, #20]
 8002240:	2b00      	cmp	r3, #0
 8002242:	d105      	bne.n	8002250 <sdIncomingDataI+0x30>
    chnAddFlagsI(sdp, CHN_INPUT_AVAILABLE);
 8002244:	9b01      	ldr	r3, [sp, #4]
 8002246:	3304      	adds	r3, #4
 8002248:	2104      	movs	r1, #4
 800224a:	4618      	mov	r0, r3
 800224c:	f7ff fec8 	bl	8001fe0 <osalEventBroadcastFlagsI.lto_priv.658>
  if (iqPutI(&sdp->iqueue, b) < MSG_OK)
 8002250:	9b01      	ldr	r3, [sp, #4]
 8002252:	330c      	adds	r3, #12
 8002254:	f89d 2003 	ldrb.w	r2, [sp, #3]
 8002258:	4611      	mov	r1, r2
 800225a:	4618      	mov	r0, r3
 800225c:	f7ff fcc8 	bl	8001bf0 <iqPutI>
 8002260:	4603      	mov	r3, r0
 8002262:	2b00      	cmp	r3, #0
 8002264:	da06      	bge.n	8002274 <sdIncomingDataI+0x54>
    chnAddFlagsI(sdp, SD_QUEUE_FULL_ERROR);
 8002266:	9b01      	ldr	r3, [sp, #4]
 8002268:	3304      	adds	r3, #4
 800226a:	f44f 6180 	mov.w	r1, #1024	; 0x400
 800226e:	4618      	mov	r0, r3
 8002270:	f7ff feb6 	bl	8001fe0 <osalEventBroadcastFlagsI.lto_priv.658>
}
 8002274:	b003      	add	sp, #12
 8002276:	f85d fb04 	ldr.w	pc, [sp], #4
 800227a:	bf00      	nop
 800227c:	08008804 	.word	0x08008804

08002280 <port_lock.lto_priv.290>:
static inline void port_lock(void) {
 8002280:	b082      	sub	sp, #8
 8002282:	2320      	movs	r3, #32
 8002284:	9301      	str	r3, [sp, #4]
 8002286:	9b01      	ldr	r3, [sp, #4]
 8002288:	f383 8811 	msr	BASEPRI, r3
}
 800228c:	b002      	add	sp, #8
 800228e:	4770      	bx	lr

08002290 <port_unlock.lto_priv.249>:
static inline void port_unlock(void) {
 8002290:	b082      	sub	sp, #8
 8002292:	2300      	movs	r3, #0
 8002294:	9301      	str	r3, [sp, #4]
 8002296:	9b01      	ldr	r3, [sp, #4]
 8002298:	f383 8811 	msr	BASEPRI, r3
}
 800229c:	b002      	add	sp, #8
 800229e:	4770      	bx	lr

080022a0 <port_lock_from_isr.lto_priv.546>:
static inline void port_lock_from_isr(void) {
 80022a0:	b508      	push	{r3, lr}
  port_lock();
 80022a2:	f7ff ffed 	bl	8002280 <port_lock.lto_priv.290>
}
 80022a6:	bd08      	pop	{r3, pc}
	...

080022b0 <port_unlock_from_isr.lto_priv.534>:
static inline void port_unlock_from_isr(void) {
 80022b0:	b508      	push	{r3, lr}
  port_unlock();
 80022b2:	f7ff ffed 	bl	8002290 <port_unlock.lto_priv.249>
}
 80022b6:	bd08      	pop	{r3, pc}
	...

080022c0 <chSysLock.lto_priv.404>:
static inline void chSysLock(void) {
 80022c0:	b508      	push	{r3, lr}
  port_lock();
 80022c2:	f7ff ffdd 	bl	8002280 <port_lock.lto_priv.290>
  _dbg_check_lock();
 80022c6:	f004 f8b3 	bl	8006430 <_dbg_check_lock>
}
 80022ca:	bd08      	pop	{r3, pc}
 80022cc:	0000      	movs	r0, r0
	...

080022d0 <chSysUnlock.lto_priv.371>:
static inline void chSysUnlock(void) {
 80022d0:	b508      	push	{r3, lr}
  _dbg_check_unlock();
 80022d2:	f004 f8c5 	bl	8006460 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 80022d6:	4b09      	ldr	r3, [pc, #36]	; (80022fc <chSysUnlock.lto_priv.371+0x2c>)
 80022d8:	681b      	ldr	r3, [r3, #0]
 80022da:	4a08      	ldr	r2, [pc, #32]	; (80022fc <chSysUnlock.lto_priv.371+0x2c>)
 80022dc:	4293      	cmp	r3, r2
 80022de:	d00a      	beq.n	80022f6 <chSysUnlock.lto_priv.371+0x26>
 80022e0:	4b06      	ldr	r3, [pc, #24]	; (80022fc <chSysUnlock.lto_priv.371+0x2c>)
 80022e2:	699b      	ldr	r3, [r3, #24]
 80022e4:	689a      	ldr	r2, [r3, #8]
 80022e6:	4b05      	ldr	r3, [pc, #20]	; (80022fc <chSysUnlock.lto_priv.371+0x2c>)
 80022e8:	681b      	ldr	r3, [r3, #0]
 80022ea:	689b      	ldr	r3, [r3, #8]
 80022ec:	429a      	cmp	r2, r3
 80022ee:	d202      	bcs.n	80022f6 <chSysUnlock.lto_priv.371+0x26>
 80022f0:	4803      	ldr	r0, [pc, #12]	; (8002300 <chSysUnlock.lto_priv.371+0x30>)
 80022f2:	f004 f81d 	bl	8006330 <chSysHalt>
  port_unlock();
 80022f6:	f7ff ffcb 	bl	8002290 <port_unlock.lto_priv.249>
}
 80022fa:	bd08      	pop	{r3, pc}
 80022fc:	20000b38 	.word	0x20000b38
 8002300:	0800885c 	.word	0x0800885c
	...

08002310 <chSysLockFromISR.lto_priv.519>:
static inline void chSysLockFromISR(void) {
 8002310:	b508      	push	{r3, lr}
  port_lock_from_isr();
 8002312:	f7ff ffc5 	bl	80022a0 <port_lock_from_isr.lto_priv.546>
  _dbg_check_lock_from_isr();
 8002316:	f004 f8bb 	bl	8006490 <_dbg_check_lock_from_isr>
}
 800231a:	bd08      	pop	{r3, pc}
 800231c:	0000      	movs	r0, r0
	...

08002320 <chSysUnlockFromISR.lto_priv.510>:
static inline void chSysUnlockFromISR(void) {
 8002320:	b508      	push	{r3, lr}
  _dbg_check_unlock_from_isr();
 8002322:	f004 f8cd 	bl	80064c0 <_dbg_check_unlock_from_isr>
  port_unlock_from_isr();
 8002326:	f7ff ffc3 	bl	80022b0 <port_unlock_from_isr.lto_priv.534>
}
 800232a:	bd08      	pop	{r3, pc}
 800232c:	0000      	movs	r0, r0
	...

08002330 <chEvtObjectInit.lto_priv.495>:
static inline void chEvtObjectInit(event_source_t *esp) {
 8002330:	b082      	sub	sp, #8
 8002332:	9001      	str	r0, [sp, #4]
  esp->next = (event_listener_t *)esp;
 8002334:	9b01      	ldr	r3, [sp, #4]
 8002336:	9a01      	ldr	r2, [sp, #4]
 8002338:	601a      	str	r2, [r3, #0]
}
 800233a:	b002      	add	sp, #8
 800233c:	4770      	bx	lr
 800233e:	bf00      	nop

08002340 <osalSysLock.lto_priv.487>:
static inline void osalSysLock(void) {
 8002340:	b508      	push	{r3, lr}
  chSysLock();
 8002342:	f7ff ffbd 	bl	80022c0 <chSysLock.lto_priv.404>
}
 8002346:	bd08      	pop	{r3, pc}
	...

08002350 <osalSysUnlock.lto_priv.476>:
static inline void osalSysUnlock(void) {
 8002350:	b508      	push	{r3, lr}
  chSysUnlock();
 8002352:	f7ff ffbd 	bl	80022d0 <chSysUnlock.lto_priv.371>
}
 8002356:	bd08      	pop	{r3, pc}
	...

08002360 <osalSysLockFromISR.lto_priv.667>:
static inline void osalSysLockFromISR(void) {
 8002360:	b508      	push	{r3, lr}
  chSysLockFromISR();
 8002362:	f7ff ffd5 	bl	8002310 <chSysLockFromISR.lto_priv.519>
}
 8002366:	bd08      	pop	{r3, pc}
	...

08002370 <osalSysUnlockFromISR.lto_priv.661>:
static inline void osalSysUnlockFromISR(void) {
 8002370:	b508      	push	{r3, lr}
  chSysUnlockFromISR();
 8002372:	f7ff ffd5 	bl	8002320 <chSysUnlockFromISR.lto_priv.510>
}
 8002376:	bd08      	pop	{r3, pc}
	...

08002380 <osalEventObjectInit.lto_priv.725>:
static inline void osalEventObjectInit(event_source_t *esp) {
 8002380:	b500      	push	{lr}
 8002382:	b083      	sub	sp, #12
 8002384:	9001      	str	r0, [sp, #4]
  chEvtObjectInit(esp);
 8002386:	9801      	ldr	r0, [sp, #4]
 8002388:	f7ff ffd2 	bl	8002330 <chEvtObjectInit.lto_priv.495>
}
 800238c:	b003      	add	sp, #12
 800238e:	f85d fb04 	ldr.w	pc, [sp], #4
 8002392:	bf00      	nop
	...

080023a0 <osalEventBroadcastFlagsI.lto_priv.659>:
                                            eventflags_t flags) {
 80023a0:	b500      	push	{lr}
 80023a2:	b083      	sub	sp, #12
 80023a4:	9001      	str	r0, [sp, #4]
 80023a6:	9100      	str	r1, [sp, #0]
  chEvtBroadcastFlagsI(esp, flags);
 80023a8:	9900      	ldr	r1, [sp, #0]
 80023aa:	9801      	ldr	r0, [sp, #4]
 80023ac:	f005 fd48 	bl	8007e40 <chEvtBroadcastFlagsI>
}
 80023b0:	b003      	add	sp, #12
 80023b2:	f85d fb04 	ldr.w	pc, [sp], #4
 80023b6:	bf00      	nop
	...

080023c0 <sdu_start_receive>:

/*===========================================================================*/
/* Driver local functions.                                                   */
/*===========================================================================*/

static bool sdu_start_receive(SerialUSBDriver *sdup) {
 80023c0:	b500      	push	{lr}
 80023c2:	b085      	sub	sp, #20
 80023c4:	9001      	str	r0, [sp, #4]
  uint8_t *buf;

  /* If the USB driver is not in the appropriate state then transactions
     must not be started.*/
  if ((usbGetDriverStateI(sdup->config->usbp) != USB_ACTIVE) ||
 80023c6:	9b01      	ldr	r3, [sp, #4]
 80023c8:	f8d3 348c 	ldr.w	r3, [r3, #1164]	; 0x48c
 80023cc:	681b      	ldr	r3, [r3, #0]
 80023ce:	781b      	ldrb	r3, [r3, #0]
 80023d0:	2b04      	cmp	r3, #4
 80023d2:	d103      	bne.n	80023dc <sdu_start_receive+0x1c>
      (sdup->state != SDU_READY)) {
 80023d4:	9b01      	ldr	r3, [sp, #4]
 80023d6:	7a1b      	ldrb	r3, [r3, #8]
  if ((usbGetDriverStateI(sdup->config->usbp) != USB_ACTIVE) ||
 80023d8:	2b02      	cmp	r3, #2
 80023da:	d001      	beq.n	80023e0 <sdu_start_receive+0x20>
    return true;
 80023dc:	2301      	movs	r3, #1
 80023de:	e02b      	b.n	8002438 <sdu_start_receive+0x78>
  }

  /* Checking if there is already a transaction ongoing on the endpoint.*/
  if (usbGetReceiveStatusI(sdup->config->usbp, sdup->config->bulk_in)) {
 80023e0:	9b01      	ldr	r3, [sp, #4]
 80023e2:	f8d3 348c 	ldr.w	r3, [r3, #1164]	; 0x48c
 80023e6:	681b      	ldr	r3, [r3, #0]
 80023e8:	895a      	ldrh	r2, [r3, #10]
 80023ea:	9b01      	ldr	r3, [sp, #4]
 80023ec:	f8d3 348c 	ldr.w	r3, [r3, #1164]	; 0x48c
 80023f0:	791b      	ldrb	r3, [r3, #4]
 80023f2:	4619      	mov	r1, r3
 80023f4:	2301      	movs	r3, #1
 80023f6:	408b      	lsls	r3, r1
 80023f8:	b29b      	uxth	r3, r3
 80023fa:	4013      	ands	r3, r2
 80023fc:	b29b      	uxth	r3, r3
 80023fe:	2b00      	cmp	r3, #0
 8002400:	d001      	beq.n	8002406 <sdu_start_receive+0x46>
    return true;
 8002402:	2301      	movs	r3, #1
 8002404:	e018      	b.n	8002438 <sdu_start_receive+0x78>
  }

  /* Checking if there is a buffer ready for incoming data.*/
  buf = ibqGetEmptyBufferI(&sdup->ibqueue);
 8002406:	9b01      	ldr	r3, [sp, #4]
 8002408:	330c      	adds	r3, #12
 800240a:	4618      	mov	r0, r3
 800240c:	f7fe fe78 	bl	8001100 <ibqGetEmptyBufferI>
 8002410:	9003      	str	r0, [sp, #12]
  if (buf == NULL) {
 8002412:	9b03      	ldr	r3, [sp, #12]
 8002414:	2b00      	cmp	r3, #0
 8002416:	d101      	bne.n	800241c <sdu_start_receive+0x5c>
    return true;
 8002418:	2301      	movs	r3, #1
 800241a:	e00d      	b.n	8002438 <sdu_start_receive+0x78>
  }

  /* Buffer found, starting a new transaction.*/
  usbStartReceiveI(sdup->config->usbp, sdup->config->bulk_out,
 800241c:	9b01      	ldr	r3, [sp, #4]
 800241e:	f8d3 348c 	ldr.w	r3, [r3, #1164]	; 0x48c
 8002422:	6818      	ldr	r0, [r3, #0]
 8002424:	9b01      	ldr	r3, [sp, #4]
 8002426:	f8d3 348c 	ldr.w	r3, [r3, #1164]	; 0x48c
 800242a:	7959      	ldrb	r1, [r3, #5]
 800242c:	f44f 7380 	mov.w	r3, #256	; 0x100
 8002430:	9a03      	ldr	r2, [sp, #12]
 8002432:	f000 fee5 	bl	8003200 <usbStartReceiveI>
                   buf, SERIAL_USB_BUFFERS_SIZE);

  return false;
 8002436:	2300      	movs	r3, #0
}
 8002438:	4618      	mov	r0, r3
 800243a:	b005      	add	sp, #20
 800243c:	f85d fb04 	ldr.w	pc, [sp], #4

08002440 <_write.lto_priv.223>:

/*
 * Interface implementation.
 */

static size_t _write(void *ip, const uint8_t *bp, size_t n) {
 8002440:	b500      	push	{lr}
 8002442:	b085      	sub	sp, #20
 8002444:	9003      	str	r0, [sp, #12]
 8002446:	9102      	str	r1, [sp, #8]
 8002448:	9201      	str	r2, [sp, #4]

  return obqWriteTimeout(&((SerialUSBDriver *)ip)->obqueue, bp,
 800244a:	9b03      	ldr	r3, [sp, #12]
 800244c:	f103 0044 	add.w	r0, r3, #68	; 0x44
 8002450:	f04f 33ff 	mov.w	r3, #4294967295
 8002454:	9a01      	ldr	r2, [sp, #4]
 8002456:	9902      	ldr	r1, [sp, #8]
 8002458:	f7ff f96a 	bl	8001730 <obqWriteTimeout>
 800245c:	4603      	mov	r3, r0
                         n, TIME_INFINITE);
}
 800245e:	4618      	mov	r0, r3
 8002460:	b005      	add	sp, #20
 8002462:	f85d fb04 	ldr.w	pc, [sp], #4
 8002466:	bf00      	nop
	...

08002470 <_read.lto_priv.225>:

static size_t _read(void *ip, uint8_t *bp, size_t n) {
 8002470:	b500      	push	{lr}
 8002472:	b085      	sub	sp, #20
 8002474:	9003      	str	r0, [sp, #12]
 8002476:	9102      	str	r1, [sp, #8]
 8002478:	9201      	str	r2, [sp, #4]

  return ibqReadTimeout(&((SerialUSBDriver *)ip)->ibqueue, bp,
 800247a:	9b03      	ldr	r3, [sp, #12]
 800247c:	f103 000c 	add.w	r0, r3, #12
 8002480:	f04f 33ff 	mov.w	r3, #4294967295
 8002484:	9a01      	ldr	r2, [sp, #4]
 8002486:	9902      	ldr	r1, [sp, #8]
 8002488:	f7fe ff4a 	bl	8001320 <ibqReadTimeout>
 800248c:	4603      	mov	r3, r0
                        n, TIME_INFINITE);
}
 800248e:	4618      	mov	r0, r3
 8002490:	b005      	add	sp, #20
 8002492:	f85d fb04 	ldr.w	pc, [sp], #4
 8002496:	bf00      	nop
	...

080024a0 <_put.lto_priv.133>:

static msg_t _put(void *ip, uint8_t b) {
 80024a0:	b500      	push	{lr}
 80024a2:	b083      	sub	sp, #12
 80024a4:	9001      	str	r0, [sp, #4]
 80024a6:	460b      	mov	r3, r1
 80024a8:	f88d 3003 	strb.w	r3, [sp, #3]

  return obqPutTimeout(&((SerialUSBDriver *)ip)->obqueue, b, TIME_INFINITE);
 80024ac:	9b01      	ldr	r3, [sp, #4]
 80024ae:	3344      	adds	r3, #68	; 0x44
 80024b0:	f89d 1003 	ldrb.w	r1, [sp, #3]
 80024b4:	f04f 32ff 	mov.w	r2, #4294967295
 80024b8:	4618      	mov	r0, r3
 80024ba:	f7ff f901 	bl	80016c0 <obqPutTimeout>
 80024be:	4603      	mov	r3, r0
}
 80024c0:	4618      	mov	r0, r3
 80024c2:	b003      	add	sp, #12
 80024c4:	f85d fb04 	ldr.w	pc, [sp], #4
	...

080024d0 <_get.lto_priv.136>:

static msg_t _get(void *ip) {
 80024d0:	b500      	push	{lr}
 80024d2:	b083      	sub	sp, #12
 80024d4:	9001      	str	r0, [sp, #4]

  return ibqGetTimeout(&((SerialUSBDriver *)ip)->ibqueue, TIME_INFINITE);
 80024d6:	9b01      	ldr	r3, [sp, #4]
 80024d8:	330c      	adds	r3, #12
 80024da:	f04f 31ff 	mov.w	r1, #4294967295
 80024de:	4618      	mov	r0, r3
 80024e0:	f7fe feee 	bl	80012c0 <ibqGetTimeout>
 80024e4:	4603      	mov	r3, r0
}
 80024e6:	4618      	mov	r0, r3
 80024e8:	b003      	add	sp, #12
 80024ea:	f85d fb04 	ldr.w	pc, [sp], #4
 80024ee:	bf00      	nop

080024f0 <_putt.lto_priv.227>:

static msg_t _putt(void *ip, uint8_t b, sysinterval_t timeout) {
 80024f0:	b500      	push	{lr}
 80024f2:	b085      	sub	sp, #20
 80024f4:	9003      	str	r0, [sp, #12]
 80024f6:	460b      	mov	r3, r1
 80024f8:	9201      	str	r2, [sp, #4]
 80024fa:	f88d 300b 	strb.w	r3, [sp, #11]

  return obqPutTimeout(&((SerialUSBDriver *)ip)->obqueue, b, timeout);
 80024fe:	9b03      	ldr	r3, [sp, #12]
 8002500:	3344      	adds	r3, #68	; 0x44
 8002502:	f89d 100b 	ldrb.w	r1, [sp, #11]
 8002506:	9a01      	ldr	r2, [sp, #4]
 8002508:	4618      	mov	r0, r3
 800250a:	f7ff f8d9 	bl	80016c0 <obqPutTimeout>
 800250e:	4603      	mov	r3, r0
}
 8002510:	4618      	mov	r0, r3
 8002512:	b005      	add	sp, #20
 8002514:	f85d fb04 	ldr.w	pc, [sp], #4
	...

08002520 <_gett.lto_priv.229>:

static msg_t _gett(void *ip, sysinterval_t timeout) {
 8002520:	b500      	push	{lr}
 8002522:	b083      	sub	sp, #12
 8002524:	9001      	str	r0, [sp, #4]
 8002526:	9100      	str	r1, [sp, #0]

  return ibqGetTimeout(&((SerialUSBDriver *)ip)->ibqueue, timeout);
 8002528:	9b01      	ldr	r3, [sp, #4]
 800252a:	330c      	adds	r3, #12
 800252c:	9900      	ldr	r1, [sp, #0]
 800252e:	4618      	mov	r0, r3
 8002530:	f7fe fec6 	bl	80012c0 <ibqGetTimeout>
 8002534:	4603      	mov	r3, r0
}
 8002536:	4618      	mov	r0, r3
 8002538:	b003      	add	sp, #12
 800253a:	f85d fb04 	ldr.w	pc, [sp], #4
 800253e:	bf00      	nop

08002540 <_writet.lto_priv.231>:

static size_t _writet(void *ip, const uint8_t *bp, size_t n,
                      sysinterval_t timeout) {
 8002540:	b500      	push	{lr}
 8002542:	b085      	sub	sp, #20
 8002544:	9003      	str	r0, [sp, #12]
 8002546:	9102      	str	r1, [sp, #8]
 8002548:	9201      	str	r2, [sp, #4]
 800254a:	9300      	str	r3, [sp, #0]

  return obqWriteTimeout(&((SerialUSBDriver *)ip)->obqueue, bp, n, timeout);
 800254c:	9b03      	ldr	r3, [sp, #12]
 800254e:	f103 0044 	add.w	r0, r3, #68	; 0x44
 8002552:	9b00      	ldr	r3, [sp, #0]
 8002554:	9a01      	ldr	r2, [sp, #4]
 8002556:	9902      	ldr	r1, [sp, #8]
 8002558:	f7ff f8ea 	bl	8001730 <obqWriteTimeout>
 800255c:	4603      	mov	r3, r0
}
 800255e:	4618      	mov	r0, r3
 8002560:	b005      	add	sp, #20
 8002562:	f85d fb04 	ldr.w	pc, [sp], #4
 8002566:	bf00      	nop
	...

08002570 <_readt.lto_priv.233>:

static size_t _readt(void *ip, uint8_t *bp, size_t n,
                     sysinterval_t timeout) {
 8002570:	b500      	push	{lr}
 8002572:	b085      	sub	sp, #20
 8002574:	9003      	str	r0, [sp, #12]
 8002576:	9102      	str	r1, [sp, #8]
 8002578:	9201      	str	r2, [sp, #4]
 800257a:	9300      	str	r3, [sp, #0]

  return ibqReadTimeout(&((SerialUSBDriver *)ip)->ibqueue, bp, n, timeout);
 800257c:	9b03      	ldr	r3, [sp, #12]
 800257e:	f103 000c 	add.w	r0, r3, #12
 8002582:	9b00      	ldr	r3, [sp, #0]
 8002584:	9a01      	ldr	r2, [sp, #4]
 8002586:	9902      	ldr	r1, [sp, #8]
 8002588:	f7fe feca 	bl	8001320 <ibqReadTimeout>
 800258c:	4603      	mov	r3, r0
}
 800258e:	4618      	mov	r0, r3
 8002590:	b005      	add	sp, #20
 8002592:	f85d fb04 	ldr.w	pc, [sp], #4
 8002596:	bf00      	nop
	...

080025a0 <_ctl.lto_priv.235>:

static msg_t _ctl(void *ip, unsigned int operation, void *arg) {
 80025a0:	b500      	push	{lr}
 80025a2:	b087      	sub	sp, #28
 80025a4:	9003      	str	r0, [sp, #12]
 80025a6:	9102      	str	r1, [sp, #8]
 80025a8:	9201      	str	r2, [sp, #4]
  SerialUSBDriver *sdup = (SerialUSBDriver *)ip;
 80025aa:	9b03      	ldr	r3, [sp, #12]
 80025ac:	9305      	str	r3, [sp, #20]

  osalDbgCheck(sdup != NULL);
 80025ae:	9b05      	ldr	r3, [sp, #20]
 80025b0:	2b00      	cmp	r3, #0
 80025b2:	d102      	bne.n	80025ba <_ctl.lto_priv.235+0x1a>
 80025b4:	480b      	ldr	r0, [pc, #44]	; (80025e4 <_ctl.lto_priv.235+0x44>)
 80025b6:	f003 febb 	bl	8006330 <chSysHalt>

  switch (operation) {
 80025ba:	9b02      	ldr	r3, [sp, #8]
 80025bc:	2b00      	cmp	r3, #0
 80025be:	d008      	beq.n	80025d2 <_ctl.lto_priv.235+0x32>
 80025c0:	2b01      	cmp	r3, #1
 80025c2:	d109      	bne.n	80025d8 <_ctl.lto_priv.235+0x38>
  case CHN_CTL_NOP:
    osalDbgCheck(arg == NULL);
 80025c4:	9b01      	ldr	r3, [sp, #4]
 80025c6:	2b00      	cmp	r3, #0
 80025c8:	d006      	beq.n	80025d8 <_ctl.lto_priv.235+0x38>
 80025ca:	4806      	ldr	r0, [pc, #24]	; (80025e4 <_ctl.lto_priv.235+0x44>)
 80025cc:	f003 feb0 	bl	8006330 <chSysHalt>
 80025d0:	e002      	b.n	80025d8 <_ctl.lto_priv.235+0x38>
    break;
  case CHN_CTL_INVALID:
    osalDbgAssert(false, "invalid CTL operation");
 80025d2:	4804      	ldr	r0, [pc, #16]	; (80025e4 <_ctl.lto_priv.235+0x44>)
 80025d4:	f003 feac 	bl	8006330 <chSysHalt>
    return sdu_lld_control(sdup, operation, arg);
#else
    break;
#endif
  }
  return MSG_OK;
 80025d8:	2300      	movs	r3, #0
}
 80025da:	4618      	mov	r0, r3
 80025dc:	b007      	add	sp, #28
 80025de:	f85d fb04 	ldr.w	pc, [sp], #4
 80025e2:	bf00      	nop
 80025e4:	0800883c 	.word	0x0800883c
	...

080025f0 <ibnotify>:
/**
 * @brief   Notification of empty buffer released into the input buffers queue.
 *
 * @param[in] bqp       the buffers queue pointer.
 */
static void ibnotify(io_buffers_queue_t *bqp) {
 80025f0:	b500      	push	{lr}
 80025f2:	b085      	sub	sp, #20
 80025f4:	9001      	str	r0, [sp, #4]
  SerialUSBDriver *sdup = bqGetLinkX(bqp);
 80025f6:	9b01      	ldr	r3, [sp, #4]
 80025f8:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 80025fa:	9303      	str	r3, [sp, #12]
  (void) sdu_start_receive(sdup);
 80025fc:	9803      	ldr	r0, [sp, #12]
 80025fe:	f7ff fedf 	bl	80023c0 <sdu_start_receive>
}
 8002602:	b005      	add	sp, #20
 8002604:	f85d fb04 	ldr.w	pc, [sp], #4
	...

08002610 <obnotify>:
/**
 * @brief   Notification of filled buffer inserted into the output buffers queue.
 *
 * @param[in] bqp       the buffers queue pointer.
 */
static void obnotify(io_buffers_queue_t *bqp) {
 8002610:	b500      	push	{lr}
 8002612:	b087      	sub	sp, #28
 8002614:	9001      	str	r0, [sp, #4]
  size_t n;
  SerialUSBDriver *sdup = bqGetLinkX(bqp);
 8002616:	9b01      	ldr	r3, [sp, #4]
 8002618:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 800261a:	9305      	str	r3, [sp, #20]

  /* If the USB driver is not in the appropriate state then transactions
     must not be started.*/
  if ((usbGetDriverStateI(sdup->config->usbp) != USB_ACTIVE) ||
 800261c:	9b05      	ldr	r3, [sp, #20]
 800261e:	f8d3 348c 	ldr.w	r3, [r3, #1164]	; 0x48c
 8002622:	681b      	ldr	r3, [r3, #0]
 8002624:	781b      	ldrb	r3, [r3, #0]
 8002626:	2b04      	cmp	r3, #4
 8002628:	d12f      	bne.n	800268a <obnotify+0x7a>
      (sdup->state != SDU_READY)) {
 800262a:	9b05      	ldr	r3, [sp, #20]
 800262c:	7a1b      	ldrb	r3, [r3, #8]
  if ((usbGetDriverStateI(sdup->config->usbp) != USB_ACTIVE) ||
 800262e:	2b02      	cmp	r3, #2
 8002630:	d12b      	bne.n	800268a <obnotify+0x7a>
    return;
  }

  /* Checking if there is already a transaction ongoing on the endpoint.*/
  if (!usbGetTransmitStatusI(sdup->config->usbp, sdup->config->bulk_in)) {
 8002632:	9b05      	ldr	r3, [sp, #20]
 8002634:	f8d3 348c 	ldr.w	r3, [r3, #1164]	; 0x48c
 8002638:	681b      	ldr	r3, [r3, #0]
 800263a:	891a      	ldrh	r2, [r3, #8]
 800263c:	9b05      	ldr	r3, [sp, #20]
 800263e:	f8d3 348c 	ldr.w	r3, [r3, #1164]	; 0x48c
 8002642:	791b      	ldrb	r3, [r3, #4]
 8002644:	4619      	mov	r1, r3
 8002646:	2301      	movs	r3, #1
 8002648:	408b      	lsls	r3, r1
 800264a:	b29b      	uxth	r3, r3
 800264c:	4013      	ands	r3, r2
 800264e:	b29b      	uxth	r3, r3
 8002650:	2b00      	cmp	r3, #0
 8002652:	d11b      	bne.n	800268c <obnotify+0x7c>
    /* Getting a full buffer, a buffer is available for sure because this
       callback is invoked when one has been inserted.*/
    uint8_t *buf = obqGetFullBufferI(&sdup->obqueue, &n);
 8002654:	9b05      	ldr	r3, [sp, #20]
 8002656:	3344      	adds	r3, #68	; 0x44
 8002658:	aa03      	add	r2, sp, #12
 800265a:	4611      	mov	r1, r2
 800265c:	4618      	mov	r0, r3
 800265e:	f7fe ff47 	bl	80014f0 <obqGetFullBufferI>
 8002662:	9004      	str	r0, [sp, #16]
    osalDbgAssert(buf != NULL, "buffer not found");
 8002664:	9b04      	ldr	r3, [sp, #16]
 8002666:	2b00      	cmp	r3, #0
 8002668:	d102      	bne.n	8002670 <obnotify+0x60>
 800266a:	480a      	ldr	r0, [pc, #40]	; (8002694 <obnotify+0x84>)
 800266c:	f003 fe60 	bl	8006330 <chSysHalt>
    usbStartTransmitI(sdup->config->usbp, sdup->config->bulk_in, buf, n);
 8002670:	9b05      	ldr	r3, [sp, #20]
 8002672:	f8d3 348c 	ldr.w	r3, [r3, #1164]	; 0x48c
 8002676:	6818      	ldr	r0, [r3, #0]
 8002678:	9b05      	ldr	r3, [sp, #20]
 800267a:	f8d3 348c 	ldr.w	r3, [r3, #1164]	; 0x48c
 800267e:	7919      	ldrb	r1, [r3, #4]
 8002680:	9b03      	ldr	r3, [sp, #12]
 8002682:	9a04      	ldr	r2, [sp, #16]
 8002684:	f000 fe0c 	bl	80032a0 <usbStartTransmitI>
 8002688:	e000      	b.n	800268c <obnotify+0x7c>
    return;
 800268a:	bf00      	nop
  }
}
 800268c:	b007      	add	sp, #28
 800268e:	f85d fb04 	ldr.w	pc, [sp], #4
 8002692:	bf00      	nop
 8002694:	08008844 	.word	0x08008844
	...

080026a0 <sduInit>:
 *          no need to explicitly initialize the driver.
 *
 * @init
 */
void sduInit(void) {
}
 80026a0:	4770      	bx	lr
 80026a2:	bf00      	nop
	...

080026b0 <sduObjectInit>:
 *
 * @param[out] sdup     pointer to a @p SerialUSBDriver structure
 *
 * @init
 */
void sduObjectInit(SerialUSBDriver *sdup) {
 80026b0:	b500      	push	{lr}
 80026b2:	b087      	sub	sp, #28
 80026b4:	9005      	str	r0, [sp, #20]

  sdup->vmt = &vmt;
 80026b6:	9b05      	ldr	r3, [sp, #20]
 80026b8:	4a17      	ldr	r2, [pc, #92]	; (8002718 <sduObjectInit+0x68>)
 80026ba:	601a      	str	r2, [r3, #0]
  osalEventObjectInit(&sdup->event);
 80026bc:	9b05      	ldr	r3, [sp, #20]
 80026be:	3304      	adds	r3, #4
 80026c0:	4618      	mov	r0, r3
 80026c2:	f7ff fe5d 	bl	8002380 <osalEventObjectInit.lto_priv.725>
  sdup->state = SDU_STOP;
 80026c6:	9b05      	ldr	r3, [sp, #20]
 80026c8:	2201      	movs	r2, #1
 80026ca:	721a      	strb	r2, [r3, #8]
  ibqObjectInit(&sdup->ibqueue, true, sdup->ib, SERIAL_USB_BUFFERS_SIZE, SERIAL_USB_BUFFERS_NUMBER, ibnotify, sdup);
 80026cc:	9b05      	ldr	r3, [sp, #20]
 80026ce:	f103 000c 	add.w	r0, r3, #12
 80026d2:	9b05      	ldr	r3, [sp, #20]
 80026d4:	f103 027c 	add.w	r2, r3, #124	; 0x7c
 80026d8:	9b05      	ldr	r3, [sp, #20]
 80026da:	9302      	str	r3, [sp, #8]
 80026dc:	4b0f      	ldr	r3, [pc, #60]	; (800271c <sduObjectInit+0x6c>)
 80026de:	9301      	str	r3, [sp, #4]
 80026e0:	2302      	movs	r3, #2
 80026e2:	9300      	str	r3, [sp, #0]
 80026e4:	f44f 7380 	mov.w	r3, #256	; 0x100
 80026e8:	2101      	movs	r1, #1
 80026ea:	f7fe fc99 	bl	8001020 <ibqObjectInit>
  obqObjectInit(&sdup->obqueue, true, sdup->ob, SERIAL_USB_BUFFERS_SIZE, SERIAL_USB_BUFFERS_NUMBER, obnotify, sdup);
 80026ee:	9b05      	ldr	r3, [sp, #20]
 80026f0:	f103 0044 	add.w	r0, r3, #68	; 0x44
 80026f4:	9b05      	ldr	r3, [sp, #20]
 80026f6:	f503 7221 	add.w	r2, r3, #644	; 0x284
 80026fa:	9b05      	ldr	r3, [sp, #20]
 80026fc:	9302      	str	r3, [sp, #8]
 80026fe:	4b08      	ldr	r3, [pc, #32]	; (8002720 <sduObjectInit+0x70>)
 8002700:	9301      	str	r3, [sp, #4]
 8002702:	2302      	movs	r3, #2
 8002704:	9300      	str	r3, [sp, #0]
 8002706:	f44f 7380 	mov.w	r3, #256	; 0x100
 800270a:	2101      	movs	r1, #1
 800270c:	f7fe fe80 	bl	8001410 <obqObjectInit>
}
 8002710:	b007      	add	sp, #28
 8002712:	f85d fb04 	ldr.w	pc, [sp], #4
 8002716:	bf00      	nop
 8002718:	08008814 	.word	0x08008814
 800271c:	080025f1 	.word	0x080025f1
 8002720:	08002611 	.word	0x08002611
	...

08002730 <sduStart>:
 * @param[in] sdup      pointer to a @p SerialUSBDriver object
 * @param[in] config    the serial over USB driver configuration
 *
 * @api
 */
void sduStart(SerialUSBDriver *sdup, const SerialUSBConfig *config) {
 8002730:	b500      	push	{lr}
 8002732:	b085      	sub	sp, #20
 8002734:	9001      	str	r0, [sp, #4]
 8002736:	9100      	str	r1, [sp, #0]
  USBDriver *usbp = config->usbp;
 8002738:	9b00      	ldr	r3, [sp, #0]
 800273a:	681b      	ldr	r3, [r3, #0]
 800273c:	9303      	str	r3, [sp, #12]

  osalDbgCheck(sdup != NULL);
 800273e:	9b01      	ldr	r3, [sp, #4]
 8002740:	2b00      	cmp	r3, #0
 8002742:	d102      	bne.n	800274a <sduStart+0x1a>
 8002744:	481c      	ldr	r0, [pc, #112]	; (80027b8 <sduStart+0x88>)
 8002746:	f003 fdf3 	bl	8006330 <chSysHalt>

  osalSysLock();
 800274a:	f7ff fdf9 	bl	8002340 <osalSysLock.lto_priv.487>
  osalDbgAssert((sdup->state == SDU_STOP) || (sdup->state == SDU_READY),
 800274e:	9b01      	ldr	r3, [sp, #4]
 8002750:	7a1b      	ldrb	r3, [r3, #8]
 8002752:	2b01      	cmp	r3, #1
 8002754:	d006      	beq.n	8002764 <sduStart+0x34>
 8002756:	9b01      	ldr	r3, [sp, #4]
 8002758:	7a1b      	ldrb	r3, [r3, #8]
 800275a:	2b02      	cmp	r3, #2
 800275c:	d002      	beq.n	8002764 <sduStart+0x34>
 800275e:	4816      	ldr	r0, [pc, #88]	; (80027b8 <sduStart+0x88>)
 8002760:	f003 fde6 	bl	8006330 <chSysHalt>
                "invalid state");
  usbp->in_params[config->bulk_in - 1U]   = sdup;
 8002764:	9b00      	ldr	r3, [sp, #0]
 8002766:	791b      	ldrb	r3, [r3, #4]
 8002768:	3b01      	subs	r3, #1
 800276a:	9a03      	ldr	r2, [sp, #12]
 800276c:	3308      	adds	r3, #8
 800276e:	009b      	lsls	r3, r3, #2
 8002770:	4413      	add	r3, r2
 8002772:	9a01      	ldr	r2, [sp, #4]
 8002774:	605a      	str	r2, [r3, #4]
  usbp->out_params[config->bulk_out - 1U] = sdup;
 8002776:	9b00      	ldr	r3, [sp, #0]
 8002778:	795b      	ldrb	r3, [r3, #5]
 800277a:	1e5a      	subs	r2, r3, #1
 800277c:	9b03      	ldr	r3, [sp, #12]
 800277e:	320e      	adds	r2, #14
 8002780:	9901      	ldr	r1, [sp, #4]
 8002782:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
  if (config->int_in > 0U) {
 8002786:	9b00      	ldr	r3, [sp, #0]
 8002788:	799b      	ldrb	r3, [r3, #6]
 800278a:	2b00      	cmp	r3, #0
 800278c:	d008      	beq.n	80027a0 <sduStart+0x70>
    usbp->in_params[config->int_in - 1U]  = sdup;
 800278e:	9b00      	ldr	r3, [sp, #0]
 8002790:	799b      	ldrb	r3, [r3, #6]
 8002792:	3b01      	subs	r3, #1
 8002794:	9a03      	ldr	r2, [sp, #12]
 8002796:	3308      	adds	r3, #8
 8002798:	009b      	lsls	r3, r3, #2
 800279a:	4413      	add	r3, r2
 800279c:	9a01      	ldr	r2, [sp, #4]
 800279e:	605a      	str	r2, [r3, #4]
  }
  sdup->config = config;
 80027a0:	9b01      	ldr	r3, [sp, #4]
 80027a2:	9a00      	ldr	r2, [sp, #0]
 80027a4:	f8c3 248c 	str.w	r2, [r3, #1164]	; 0x48c
  sdup->state = SDU_READY;
 80027a8:	9b01      	ldr	r3, [sp, #4]
 80027aa:	2202      	movs	r2, #2
 80027ac:	721a      	strb	r2, [r3, #8]
  osalSysUnlock();
 80027ae:	f7ff fdcf 	bl	8002350 <osalSysUnlock.lto_priv.476>
}
 80027b2:	b005      	add	sp, #20
 80027b4:	f85d fb04 	ldr.w	pc, [sp], #4
 80027b8:	08008850 	.word	0x08008850
 80027bc:	00000000 	.word	0x00000000

080027c0 <sduConfigureHookI>:
 *
 * @param[in] sdup      pointer to a @p SerialUSBDriver object
 *
 * @iclass
 */
void sduConfigureHookI(SerialUSBDriver *sdup) {
 80027c0:	b500      	push	{lr}
 80027c2:	b083      	sub	sp, #12
 80027c4:	9001      	str	r0, [sp, #4]

  ibqResetI(&sdup->ibqueue);
 80027c6:	9b01      	ldr	r3, [sp, #4]
 80027c8:	330c      	adds	r3, #12
 80027ca:	4618      	mov	r0, r3
 80027cc:	f7fe fc78 	bl	80010c0 <ibqResetI>
  bqResumeX(&sdup->ibqueue);
 80027d0:	9b01      	ldr	r3, [sp, #4]
 80027d2:	2200      	movs	r2, #0
 80027d4:	751a      	strb	r2, [r3, #20]
  obqResetI(&sdup->obqueue);
 80027d6:	9b01      	ldr	r3, [sp, #4]
 80027d8:	3344      	adds	r3, #68	; 0x44
 80027da:	4618      	mov	r0, r3
 80027dc:	f7fe fe68 	bl	80014b0 <obqResetI>
  bqResumeX(&sdup->obqueue);
 80027e0:	9b01      	ldr	r3, [sp, #4]
 80027e2:	2200      	movs	r2, #0
 80027e4:	f883 204c 	strb.w	r2, [r3, #76]	; 0x4c
  chnAddFlagsI(sdup, CHN_CONNECTED);
 80027e8:	9b01      	ldr	r3, [sp, #4]
 80027ea:	3304      	adds	r3, #4
 80027ec:	2101      	movs	r1, #1
 80027ee:	4618      	mov	r0, r3
 80027f0:	f7ff fdd6 	bl	80023a0 <osalEventBroadcastFlagsI.lto_priv.659>
  (void) sdu_start_receive(sdup);
 80027f4:	9801      	ldr	r0, [sp, #4]
 80027f6:	f7ff fde3 	bl	80023c0 <sdu_start_receive>
}
 80027fa:	b003      	add	sp, #12
 80027fc:	f85d fb04 	ldr.w	pc, [sp], #4

08002800 <sduRequestsHook>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @return              The hook status.
 * @retval true         Message handled internally.
 * @retval false        Message not handled.
 */
bool sduRequestsHook(USBDriver *usbp) {
 8002800:	b082      	sub	sp, #8
 8002802:	9001      	str	r0, [sp, #4]

  if ((usbp->setup[0] & USB_RTYPE_TYPE_MASK) == USB_RTYPE_TYPE_CLASS) {
 8002804:	9b01      	ldr	r3, [sp, #4]
 8002806:	f893 305c 	ldrb.w	r3, [r3, #92]	; 0x5c
 800280a:	f003 0360 	and.w	r3, r3, #96	; 0x60
 800280e:	2b20      	cmp	r3, #32
 8002810:	d12c      	bne.n	800286c <sduRequestsHook+0x6c>
    switch (usbp->setup[1]) {
 8002812:	9b01      	ldr	r3, [sp, #4]
 8002814:	f893 305d 	ldrb.w	r3, [r3, #93]	; 0x5d
 8002818:	2b21      	cmp	r3, #33	; 0x21
 800281a:	d004      	beq.n	8002826 <sduRequestsHook+0x26>
 800281c:	2b22      	cmp	r3, #34	; 0x22
 800281e:	d018      	beq.n	8002852 <sduRequestsHook+0x52>
 8002820:	2b20      	cmp	r3, #32
 8002822:	d00b      	beq.n	800283c <sduRequestsHook+0x3c>
 8002824:	e020      	b.n	8002868 <sduRequestsHook+0x68>
    case CDC_GET_LINE_CODING:
      usbSetupTransfer(usbp, (uint8_t *)&linecoding, sizeof(linecoding), NULL);
 8002826:	9b01      	ldr	r3, [sp, #4]
 8002828:	4a12      	ldr	r2, [pc, #72]	; (8002874 <sduRequestsHook+0x74>)
 800282a:	651a      	str	r2, [r3, #80]	; 0x50
 800282c:	9b01      	ldr	r3, [sp, #4]
 800282e:	2207      	movs	r2, #7
 8002830:	655a      	str	r2, [r3, #84]	; 0x54
 8002832:	9b01      	ldr	r3, [sp, #4]
 8002834:	2200      	movs	r2, #0
 8002836:	659a      	str	r2, [r3, #88]	; 0x58
      return true;
 8002838:	2301      	movs	r3, #1
 800283a:	e018      	b.n	800286e <sduRequestsHook+0x6e>
    case CDC_SET_LINE_CODING:
      usbSetupTransfer(usbp, (uint8_t *)&linecoding, sizeof(linecoding), NULL);
 800283c:	9b01      	ldr	r3, [sp, #4]
 800283e:	4a0d      	ldr	r2, [pc, #52]	; (8002874 <sduRequestsHook+0x74>)
 8002840:	651a      	str	r2, [r3, #80]	; 0x50
 8002842:	9b01      	ldr	r3, [sp, #4]
 8002844:	2207      	movs	r2, #7
 8002846:	655a      	str	r2, [r3, #84]	; 0x54
 8002848:	9b01      	ldr	r3, [sp, #4]
 800284a:	2200      	movs	r2, #0
 800284c:	659a      	str	r2, [r3, #88]	; 0x58
      return true;
 800284e:	2301      	movs	r3, #1
 8002850:	e00d      	b.n	800286e <sduRequestsHook+0x6e>
    case CDC_SET_CONTROL_LINE_STATE:
      /* Nothing to do, there are no control lines.*/
      usbSetupTransfer(usbp, NULL, 0, NULL);
 8002852:	9b01      	ldr	r3, [sp, #4]
 8002854:	2200      	movs	r2, #0
 8002856:	651a      	str	r2, [r3, #80]	; 0x50
 8002858:	9b01      	ldr	r3, [sp, #4]
 800285a:	2200      	movs	r2, #0
 800285c:	655a      	str	r2, [r3, #84]	; 0x54
 800285e:	9b01      	ldr	r3, [sp, #4]
 8002860:	2200      	movs	r2, #0
 8002862:	659a      	str	r2, [r3, #88]	; 0x58
      return true;
 8002864:	2301      	movs	r3, #1
 8002866:	e002      	b.n	800286e <sduRequestsHook+0x6e>
    default:
      return false;
 8002868:	2300      	movs	r3, #0
 800286a:	e000      	b.n	800286e <sduRequestsHook+0x6e>
    }
  }
  return false;
 800286c:	2300      	movs	r3, #0
}
 800286e:	4618      	mov	r0, r3
 8002870:	b002      	add	sp, #8
 8002872:	4770      	bx	lr
 8002874:	20000800 	.word	0x20000800
	...

08002880 <sduSOFHookI>:
 *
 * @param[in] sdup      pointer to a @p SerialUSBDriver object
 *
 * @iclass
 */
void sduSOFHookI(SerialUSBDriver *sdup) {
 8002880:	b500      	push	{lr}
 8002882:	b085      	sub	sp, #20
 8002884:	9001      	str	r0, [sp, #4]

  /* If the USB driver is not in the appropriate state then transactions
     must not be started.*/
  if ((usbGetDriverStateI(sdup->config->usbp) != USB_ACTIVE) ||
 8002886:	9b01      	ldr	r3, [sp, #4]
 8002888:	f8d3 348c 	ldr.w	r3, [r3, #1164]	; 0x48c
 800288c:	681b      	ldr	r3, [r3, #0]
 800288e:	781b      	ldrb	r3, [r3, #0]
 8002890:	2b04      	cmp	r3, #4
 8002892:	d136      	bne.n	8002902 <sduSOFHookI+0x82>
      (sdup->state != SDU_READY)) {
 8002894:	9b01      	ldr	r3, [sp, #4]
 8002896:	7a1b      	ldrb	r3, [r3, #8]
  if ((usbGetDriverStateI(sdup->config->usbp) != USB_ACTIVE) ||
 8002898:	2b02      	cmp	r3, #2
 800289a:	d132      	bne.n	8002902 <sduSOFHookI+0x82>
    return;
  }

  /* If there is already a transaction ongoing then another one cannot be
     started.*/
  if (usbGetTransmitStatusI(sdup->config->usbp, sdup->config->bulk_in)) {
 800289c:	9b01      	ldr	r3, [sp, #4]
 800289e:	f8d3 348c 	ldr.w	r3, [r3, #1164]	; 0x48c
 80028a2:	681b      	ldr	r3, [r3, #0]
 80028a4:	891a      	ldrh	r2, [r3, #8]
 80028a6:	9b01      	ldr	r3, [sp, #4]
 80028a8:	f8d3 348c 	ldr.w	r3, [r3, #1164]	; 0x48c
 80028ac:	791b      	ldrb	r3, [r3, #4]
 80028ae:	4619      	mov	r1, r3
 80028b0:	2301      	movs	r3, #1
 80028b2:	408b      	lsls	r3, r1
 80028b4:	b29b      	uxth	r3, r3
 80028b6:	4013      	ands	r3, r2
 80028b8:	b29b      	uxth	r3, r3
 80028ba:	2b00      	cmp	r3, #0
 80028bc:	d121      	bne.n	8002902 <sduSOFHookI+0x82>
    return;
  }

  /* Checking if there only a buffer partially filled, if so then it is
     enforced in the queue and transmitted.*/
  if (obqTryFlushI(&sdup->obqueue)) {
 80028be:	9b01      	ldr	r3, [sp, #4]
 80028c0:	3344      	adds	r3, #68	; 0x44
 80028c2:	4618      	mov	r0, r3
 80028c4:	f7fe ffb4 	bl	8001830 <obqTryFlushI>
 80028c8:	4603      	mov	r3, r0
 80028ca:	2b00      	cmp	r3, #0
 80028cc:	d019      	beq.n	8002902 <sduSOFHookI+0x82>
    size_t n;
    uint8_t *buf = obqGetFullBufferI(&sdup->obqueue, &n);
 80028ce:	9b01      	ldr	r3, [sp, #4]
 80028d0:	3344      	adds	r3, #68	; 0x44
 80028d2:	aa02      	add	r2, sp, #8
 80028d4:	4611      	mov	r1, r2
 80028d6:	4618      	mov	r0, r3
 80028d8:	f7fe fe0a 	bl	80014f0 <obqGetFullBufferI>
 80028dc:	9003      	str	r0, [sp, #12]

    osalDbgAssert(buf != NULL, "queue is empty");
 80028de:	9b03      	ldr	r3, [sp, #12]
 80028e0:	2b00      	cmp	r3, #0
 80028e2:	d102      	bne.n	80028ea <sduSOFHookI+0x6a>
 80028e4:	4808      	ldr	r0, [pc, #32]	; (8002908 <sduSOFHookI+0x88>)
 80028e6:	f003 fd23 	bl	8006330 <chSysHalt>

    usbStartTransmitI(sdup->config->usbp, sdup->config->bulk_in, buf, n);
 80028ea:	9b01      	ldr	r3, [sp, #4]
 80028ec:	f8d3 348c 	ldr.w	r3, [r3, #1164]	; 0x48c
 80028f0:	6818      	ldr	r0, [r3, #0]
 80028f2:	9b01      	ldr	r3, [sp, #4]
 80028f4:	f8d3 348c 	ldr.w	r3, [r3, #1164]	; 0x48c
 80028f8:	7919      	ldrb	r1, [r3, #4]
 80028fa:	9b02      	ldr	r3, [sp, #8]
 80028fc:	9a03      	ldr	r2, [sp, #12]
 80028fe:	f000 fccf 	bl	80032a0 <usbStartTransmitI>
  }
}
 8002902:	b005      	add	sp, #20
 8002904:	f85d fb04 	ldr.w	pc, [sp], #4
 8002908:	08008868 	.word	0x08008868
 800290c:	00000000 	.word	0x00000000

08002910 <sduDataTransmitted>:
 *          data endpoint.
 *
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        IN endpoint number
 */
void sduDataTransmitted(USBDriver *usbp, usbep_t ep) {
 8002910:	b500      	push	{lr}
 8002912:	b087      	sub	sp, #28
 8002914:	9001      	str	r0, [sp, #4]
 8002916:	460b      	mov	r3, r1
 8002918:	f88d 3003 	strb.w	r3, [sp, #3]
  uint8_t *buf;
  size_t n;
  SerialUSBDriver *sdup = usbp->in_params[ep - 1U];
 800291c:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8002920:	3b01      	subs	r3, #1
 8002922:	9a01      	ldr	r2, [sp, #4]
 8002924:	3308      	adds	r3, #8
 8002926:	009b      	lsls	r3, r3, #2
 8002928:	4413      	add	r3, r2
 800292a:	685b      	ldr	r3, [r3, #4]
 800292c:	9305      	str	r3, [sp, #20]

  if (sdup == NULL) {
 800292e:	9b05      	ldr	r3, [sp, #20]
 8002930:	2b00      	cmp	r3, #0
 8002932:	d056      	beq.n	80029e2 <sduDataTransmitted+0xd2>
    return;
  }

  osalSysLockFromISR();
 8002934:	f7ff fd14 	bl	8002360 <osalSysLockFromISR.lto_priv.667>

  /* Signaling that space is available in the output queue.*/
  chnAddFlagsI(sdup, CHN_OUTPUT_EMPTY);
 8002938:	9b05      	ldr	r3, [sp, #20]
 800293a:	3304      	adds	r3, #4
 800293c:	2108      	movs	r1, #8
 800293e:	4618      	mov	r0, r3
 8002940:	f7ff fd2e 	bl	80023a0 <osalEventBroadcastFlagsI.lto_priv.659>

  /* Freeing the buffer just transmitted, if it was not a zero size packet.*/
  if (usbp->epc[ep]->in_state->txsize > 0U) {
 8002944:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8002948:	9a01      	ldr	r2, [sp, #4]
 800294a:	3302      	adds	r3, #2
 800294c:	009b      	lsls	r3, r3, #2
 800294e:	4413      	add	r3, r2
 8002950:	685b      	ldr	r3, [r3, #4]
 8002952:	695b      	ldr	r3, [r3, #20]
 8002954:	681b      	ldr	r3, [r3, #0]
 8002956:	2b00      	cmp	r3, #0
 8002958:	d004      	beq.n	8002964 <sduDataTransmitted+0x54>
    obqReleaseEmptyBufferI(&sdup->obqueue);
 800295a:	9b05      	ldr	r3, [sp, #20]
 800295c:	3344      	adds	r3, #68	; 0x44
 800295e:	4618      	mov	r0, r3
 8002960:	f7fe fdee 	bl	8001540 <obqReleaseEmptyBufferI>
  }

  /* Checking if there is a buffer ready for transmission.*/
  buf = obqGetFullBufferI(&sdup->obqueue, &n);
 8002964:	9b05      	ldr	r3, [sp, #20]
 8002966:	3344      	adds	r3, #68	; 0x44
 8002968:	aa03      	add	r2, sp, #12
 800296a:	4611      	mov	r1, r2
 800296c:	4618      	mov	r0, r3
 800296e:	f7fe fdbf 	bl	80014f0 <obqGetFullBufferI>
 8002972:	9004      	str	r0, [sp, #16]

  if (buf != NULL) {
 8002974:	9b04      	ldr	r3, [sp, #16]
 8002976:	2b00      	cmp	r3, #0
 8002978:	d007      	beq.n	800298a <sduDataTransmitted+0x7a>
    /* The endpoint cannot be busy, we are in the context of the callback,
       so it is safe to transmit without a check.*/
    usbStartTransmitI(usbp, ep, buf, n);
 800297a:	9b03      	ldr	r3, [sp, #12]
 800297c:	f89d 1003 	ldrb.w	r1, [sp, #3]
 8002980:	9a04      	ldr	r2, [sp, #16]
 8002982:	9801      	ldr	r0, [sp, #4]
 8002984:	f000 fc8c 	bl	80032a0 <usbStartTransmitI>
 8002988:	e028      	b.n	80029dc <sduDataTransmitted+0xcc>
  }
  else if ((usbp->epc[ep]->in_state->txsize > 0U) &&
 800298a:	f89d 3003 	ldrb.w	r3, [sp, #3]
 800298e:	9a01      	ldr	r2, [sp, #4]
 8002990:	3302      	adds	r3, #2
 8002992:	009b      	lsls	r3, r3, #2
 8002994:	4413      	add	r3, r2
 8002996:	685b      	ldr	r3, [r3, #4]
 8002998:	695b      	ldr	r3, [r3, #20]
 800299a:	681b      	ldr	r3, [r3, #0]
 800299c:	2b00      	cmp	r3, #0
 800299e:	d01d      	beq.n	80029dc <sduDataTransmitted+0xcc>
           ((usbp->epc[ep]->in_state->txsize &
 80029a0:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80029a4:	9a01      	ldr	r2, [sp, #4]
 80029a6:	3302      	adds	r3, #2
 80029a8:	009b      	lsls	r3, r3, #2
 80029aa:	4413      	add	r3, r2
 80029ac:	685b      	ldr	r3, [r3, #4]
 80029ae:	695b      	ldr	r3, [r3, #20]
 80029b0:	681a      	ldr	r2, [r3, #0]
            ((size_t)usbp->epc[ep]->in_maxsize - 1U)) == 0U)) {
 80029b2:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80029b6:	9901      	ldr	r1, [sp, #4]
 80029b8:	3302      	adds	r3, #2
 80029ba:	009b      	lsls	r3, r3, #2
 80029bc:	440b      	add	r3, r1
 80029be:	685b      	ldr	r3, [r3, #4]
 80029c0:	8a1b      	ldrh	r3, [r3, #16]
 80029c2:	3b01      	subs	r3, #1
           ((usbp->epc[ep]->in_state->txsize &
 80029c4:	4013      	ands	r3, r2
  else if ((usbp->epc[ep]->in_state->txsize > 0U) &&
 80029c6:	2b00      	cmp	r3, #0
 80029c8:	d108      	bne.n	80029dc <sduDataTransmitted+0xcc>
    /* Transmit zero sized packet in case the last one has maximum allowed
       size. Otherwise the recipient may expect more data coming soon and
       not return buffered data to app. See section 5.8.3 Bulk Transfer
       Packet Size Constraints of the USB Specification document.*/
    usbStartTransmitI(usbp, ep, usbp->setup, 0);
 80029ca:	9b01      	ldr	r3, [sp, #4]
 80029cc:	f103 025c 	add.w	r2, r3, #92	; 0x5c
 80029d0:	f89d 1003 	ldrb.w	r1, [sp, #3]
 80029d4:	2300      	movs	r3, #0
 80029d6:	9801      	ldr	r0, [sp, #4]
 80029d8:	f000 fc62 	bl	80032a0 <usbStartTransmitI>
  }
  else {
    /* Nothing to transmit.*/
  }

  osalSysUnlockFromISR();
 80029dc:	f7ff fcc8 	bl	8002370 <osalSysUnlockFromISR.lto_priv.661>
 80029e0:	e000      	b.n	80029e4 <sduDataTransmitted+0xd4>
    return;
 80029e2:	bf00      	nop
}
 80029e4:	b007      	add	sp, #28
 80029e6:	f85d fb04 	ldr.w	pc, [sp], #4
 80029ea:	bf00      	nop
 80029ec:	0000      	movs	r0, r0
	...

080029f0 <sduDataReceived>:
 *          data endpoint.
 *
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        OUT endpoint number
 */
void sduDataReceived(USBDriver *usbp, usbep_t ep) {
 80029f0:	b500      	push	{lr}
 80029f2:	b085      	sub	sp, #20
 80029f4:	9001      	str	r0, [sp, #4]
 80029f6:	460b      	mov	r3, r1
 80029f8:	f88d 3003 	strb.w	r3, [sp, #3]
  size_t size;
  SerialUSBDriver *sdup = usbp->out_params[ep - 1U];
 80029fc:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8002a00:	1e5a      	subs	r2, r3, #1
 8002a02:	9b01      	ldr	r3, [sp, #4]
 8002a04:	320e      	adds	r2, #14
 8002a06:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8002a0a:	9303      	str	r3, [sp, #12]

  if (sdup == NULL) {
 8002a0c:	9b03      	ldr	r3, [sp, #12]
 8002a0e:	2b00      	cmp	r3, #0
 8002a10:	d024      	beq.n	8002a5c <sduDataReceived+0x6c>
    return;
  }

  osalSysLockFromISR();
 8002a12:	f7ff fca5 	bl	8002360 <osalSysLockFromISR.lto_priv.667>

  /* Checking for zero-size transactions.*/
  size = usbGetReceiveTransactionSizeX(sdup->config->usbp,
 8002a16:	9b03      	ldr	r3, [sp, #12]
 8002a18:	f8d3 348c 	ldr.w	r3, [r3, #1164]	; 0x48c
 8002a1c:	681a      	ldr	r2, [r3, #0]
 8002a1e:	9b03      	ldr	r3, [sp, #12]
 8002a20:	f8d3 348c 	ldr.w	r3, [r3, #1164]	; 0x48c
 8002a24:	795b      	ldrb	r3, [r3, #5]
 8002a26:	3302      	adds	r3, #2
 8002a28:	009b      	lsls	r3, r3, #2
 8002a2a:	4413      	add	r3, r2
 8002a2c:	685b      	ldr	r3, [r3, #4]
 8002a2e:	699b      	ldr	r3, [r3, #24]
 8002a30:	685b      	ldr	r3, [r3, #4]
 8002a32:	9302      	str	r3, [sp, #8]
                                       sdup->config->bulk_out);
  if (size > (size_t)0) {
 8002a34:	9b02      	ldr	r3, [sp, #8]
 8002a36:	2b00      	cmp	r3, #0
 8002a38:	d00b      	beq.n	8002a52 <sduDataReceived+0x62>
    /* Signaling that data is available in the input queue.*/
    chnAddFlagsI(sdup, CHN_INPUT_AVAILABLE);
 8002a3a:	9b03      	ldr	r3, [sp, #12]
 8002a3c:	3304      	adds	r3, #4
 8002a3e:	2104      	movs	r1, #4
 8002a40:	4618      	mov	r0, r3
 8002a42:	f7ff fcad 	bl	80023a0 <osalEventBroadcastFlagsI.lto_priv.659>

    /* Posting the filled buffer in the queue.*/
    ibqPostFullBufferI(&sdup->ibqueue, size);
 8002a46:	9b03      	ldr	r3, [sp, #12]
 8002a48:	330c      	adds	r3, #12
 8002a4a:	9902      	ldr	r1, [sp, #8]
 8002a4c:	4618      	mov	r0, r3
 8002a4e:	f7fe fb77 	bl	8001140 <ibqPostFullBufferI>
  }

  /* The endpoint cannot be busy, we are in the context of the callback,
     so a packet is in the buffer for sure. Trying to get a free buffer
     for the next transaction.*/
  (void) sdu_start_receive(sdup);
 8002a52:	9803      	ldr	r0, [sp, #12]
 8002a54:	f7ff fcb4 	bl	80023c0 <sdu_start_receive>

  osalSysUnlockFromISR();
 8002a58:	f7ff fc8a 	bl	8002370 <osalSysUnlockFromISR.lto_priv.661>
}
 8002a5c:	b005      	add	sp, #20
 8002a5e:	f85d fb04 	ldr.w	pc, [sp], #4
 8002a62:	bf00      	nop
	...

08002a70 <sduInterruptTransmitted>:
 *          interrupt endpoint.
 *
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number
 */
void sduInterruptTransmitted(USBDriver *usbp, usbep_t ep) {
 8002a70:	b082      	sub	sp, #8
 8002a72:	9001      	str	r0, [sp, #4]
 8002a74:	460b      	mov	r3, r1
 8002a76:	f88d 3003 	strb.w	r3, [sp, #3]

  (void)usbp;
  (void)ep;
}
 8002a7a:	b002      	add	sp, #8
 8002a7c:	4770      	bx	lr
 8002a7e:	bf00      	nop

08002a80 <osalMutexObjectInit>:
 *
 * @param[out] mp       pointer to the @p mutex_t object
 *
 * @init
 */
static inline void osalMutexObjectInit(mutex_t *mp) {
 8002a80:	b500      	push	{lr}
 8002a82:	b083      	sub	sp, #12
 8002a84:	9001      	str	r0, [sp, #4]

#if CH_CFG_USE_MUTEXES
  chMtxObjectInit(mp);
 8002a86:	9801      	ldr	r0, [sp, #4]
 8002a88:	f005 f8ba 	bl	8007c00 <chMtxObjectInit>
#elif CH_CFG_USE_SEMAPHORES
  chSemObjectInit((semaphore_t *)mp, 1);
#else
 *mp = 0;
#endif
}
 8002a8c:	b003      	add	sp, #12
 8002a8e:	f85d fb04 	ldr.w	pc, [sp], #4
 8002a92:	bf00      	nop
	...

08002aa0 <spiInit>:
 * @note    This function is implicitly invoked by @p halInit(), there is
 *          no need to explicitly initialize the driver.
 *
 * @init
 */
void spiInit(void) {
 8002aa0:	b508      	push	{r3, lr}

  spi_lld_init();
 8002aa2:	f002 feb5 	bl	8005810 <spi_lld_init>
}
 8002aa6:	bd08      	pop	{r3, pc}
	...

08002ab0 <spiObjectInit>:
 *
 * @param[out] spip     pointer to the @p SPIDriver object
 *
 * @init
 */
void spiObjectInit(SPIDriver *spip) {
 8002ab0:	b500      	push	{lr}
 8002ab2:	b083      	sub	sp, #12
 8002ab4:	9001      	str	r0, [sp, #4]

  spip->state = SPI_STOP;
 8002ab6:	9b01      	ldr	r3, [sp, #4]
 8002ab8:	2201      	movs	r2, #1
 8002aba:	701a      	strb	r2, [r3, #0]
  spip->config = NULL;
 8002abc:	9b01      	ldr	r3, [sp, #4]
 8002abe:	2200      	movs	r2, #0
 8002ac0:	605a      	str	r2, [r3, #4]
#if SPI_USE_WAIT == TRUE
  spip->thread = NULL;
 8002ac2:	9b01      	ldr	r3, [sp, #4]
 8002ac4:	2200      	movs	r2, #0
 8002ac6:	609a      	str	r2, [r3, #8]
#endif
#if SPI_USE_MUTUAL_EXCLUSION == TRUE
  osalMutexObjectInit(&spip->mutex);
 8002ac8:	9b01      	ldr	r3, [sp, #4]
 8002aca:	330c      	adds	r3, #12
 8002acc:	4618      	mov	r0, r3
 8002ace:	f7ff ffd7 	bl	8002a80 <osalMutexObjectInit>
#endif
#if defined(SPI_DRIVER_EXT_INIT_HOOK)
  SPI_DRIVER_EXT_INIT_HOOK(spip);
#endif
}
 8002ad2:	b003      	add	sp, #12
 8002ad4:	f85d fb04 	ldr.w	pc, [sp], #4
	...

08002ae0 <port_lock.lto_priv.292>:
static inline void port_lock(void) {
 8002ae0:	b082      	sub	sp, #8
 8002ae2:	2320      	movs	r3, #32
 8002ae4:	9301      	str	r3, [sp, #4]
 8002ae6:	9b01      	ldr	r3, [sp, #4]
 8002ae8:	f383 8811 	msr	BASEPRI, r3
}
 8002aec:	b002      	add	sp, #8
 8002aee:	4770      	bx	lr

08002af0 <port_unlock.lto_priv.251>:
static inline void port_unlock(void) {
 8002af0:	b082      	sub	sp, #8
 8002af2:	2300      	movs	r3, #0
 8002af4:	9301      	str	r3, [sp, #4]
 8002af6:	9b01      	ldr	r3, [sp, #4]
 8002af8:	f383 8811 	msr	BASEPRI, r3
}
 8002afc:	b002      	add	sp, #8
 8002afe:	4770      	bx	lr

08002b00 <port_lock_from_isr.lto_priv.547>:
static inline void port_lock_from_isr(void) {
 8002b00:	b508      	push	{r3, lr}
  port_lock();
 8002b02:	f7ff ffed 	bl	8002ae0 <port_lock.lto_priv.292>
}
 8002b06:	bd08      	pop	{r3, pc}
	...

08002b10 <port_unlock_from_isr.lto_priv.535>:
static inline void port_unlock_from_isr(void) {
 8002b10:	b508      	push	{r3, lr}
  port_unlock();
 8002b12:	f7ff ffed 	bl	8002af0 <port_unlock.lto_priv.251>
}
 8002b16:	bd08      	pop	{r3, pc}
	...

08002b20 <chSysLock.lto_priv.406>:
static inline void chSysLock(void) {
 8002b20:	b508      	push	{r3, lr}
  port_lock();
 8002b22:	f7ff ffdd 	bl	8002ae0 <port_lock.lto_priv.292>
  _dbg_check_lock();
 8002b26:	f003 fc83 	bl	8006430 <_dbg_check_lock>
}
 8002b2a:	bd08      	pop	{r3, pc}
 8002b2c:	0000      	movs	r0, r0
	...

08002b30 <chSysUnlock.lto_priv.373>:
static inline void chSysUnlock(void) {
 8002b30:	b508      	push	{r3, lr}
  _dbg_check_unlock();
 8002b32:	f003 fc95 	bl	8006460 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8002b36:	4b09      	ldr	r3, [pc, #36]	; (8002b5c <chSysUnlock.lto_priv.373+0x2c>)
 8002b38:	681b      	ldr	r3, [r3, #0]
 8002b3a:	4a08      	ldr	r2, [pc, #32]	; (8002b5c <chSysUnlock.lto_priv.373+0x2c>)
 8002b3c:	4293      	cmp	r3, r2
 8002b3e:	d00a      	beq.n	8002b56 <chSysUnlock.lto_priv.373+0x26>
 8002b40:	4b06      	ldr	r3, [pc, #24]	; (8002b5c <chSysUnlock.lto_priv.373+0x2c>)
 8002b42:	699b      	ldr	r3, [r3, #24]
 8002b44:	689a      	ldr	r2, [r3, #8]
 8002b46:	4b05      	ldr	r3, [pc, #20]	; (8002b5c <chSysUnlock.lto_priv.373+0x2c>)
 8002b48:	681b      	ldr	r3, [r3, #0]
 8002b4a:	689b      	ldr	r3, [r3, #8]
 8002b4c:	429a      	cmp	r2, r3
 8002b4e:	d202      	bcs.n	8002b56 <chSysUnlock.lto_priv.373+0x26>
 8002b50:	4803      	ldr	r0, [pc, #12]	; (8002b60 <chSysUnlock.lto_priv.373+0x30>)
 8002b52:	f003 fbed 	bl	8006330 <chSysHalt>
  port_unlock();
 8002b56:	f7ff ffcb 	bl	8002af0 <port_unlock.lto_priv.251>
}
 8002b5a:	bd08      	pop	{r3, pc}
 8002b5c:	20000b38 	.word	0x20000b38
 8002b60:	0800888c 	.word	0x0800888c
	...

08002b70 <chSysLockFromISR.lto_priv.520>:
static inline void chSysLockFromISR(void) {
 8002b70:	b508      	push	{r3, lr}
  port_lock_from_isr();
 8002b72:	f7ff ffc5 	bl	8002b00 <port_lock_from_isr.lto_priv.547>
  _dbg_check_lock_from_isr();
 8002b76:	f003 fc8b 	bl	8006490 <_dbg_check_lock_from_isr>
}
 8002b7a:	bd08      	pop	{r3, pc}
 8002b7c:	0000      	movs	r0, r0
	...

08002b80 <chSysUnlockFromISR.lto_priv.511>:
static inline void chSysUnlockFromISR(void) {
 8002b80:	b508      	push	{r3, lr}
  _dbg_check_unlock_from_isr();
 8002b82:	f003 fc9d 	bl	80064c0 <_dbg_check_unlock_from_isr>
  port_unlock_from_isr();
 8002b86:	f7ff ffc3 	bl	8002b10 <port_unlock_from_isr.lto_priv.535>
}
 8002b8a:	bd08      	pop	{r3, pc}
 8002b8c:	0000      	movs	r0, r0
	...

08002b90 <osalSysLock.lto_priv.489>:
static inline void osalSysLock(void) {
 8002b90:	b508      	push	{r3, lr}
  chSysLock();
 8002b92:	f7ff ffc5 	bl	8002b20 <chSysLock.lto_priv.406>
}
 8002b96:	bd08      	pop	{r3, pc}
	...

08002ba0 <osalSysUnlock.lto_priv.478>:
static inline void osalSysUnlock(void) {
 8002ba0:	b508      	push	{r3, lr}
  chSysUnlock();
 8002ba2:	f7ff ffc5 	bl	8002b30 <chSysUnlock.lto_priv.373>
}
 8002ba6:	bd08      	pop	{r3, pc}
	...

08002bb0 <osalSysLockFromISR.lto_priv.668>:
static inline void osalSysLockFromISR(void) {
 8002bb0:	b508      	push	{r3, lr}
  chSysLockFromISR();
 8002bb2:	f7ff ffdd 	bl	8002b70 <chSysLockFromISR.lto_priv.520>
}
 8002bb6:	bd08      	pop	{r3, pc}
	...

08002bc0 <osalSysUnlockFromISR.lto_priv.662>:
static inline void osalSysUnlockFromISR(void) {
 8002bc0:	b508      	push	{r3, lr}
  chSysUnlockFromISR();
 8002bc2:	f7ff ffdd 	bl	8002b80 <chSysUnlockFromISR.lto_priv.511>
}
 8002bc6:	bd08      	pop	{r3, pc}
	...

08002bd0 <get_hword>:

/*===========================================================================*/
/* Driver local functions.                                                   */
/*===========================================================================*/

static uint16_t get_hword(uint8_t *p) {
 8002bd0:	b084      	sub	sp, #16
 8002bd2:	9001      	str	r0, [sp, #4]
  uint16_t hw;

  hw  = (uint16_t)*p++;
 8002bd4:	9b01      	ldr	r3, [sp, #4]
 8002bd6:	1c5a      	adds	r2, r3, #1
 8002bd8:	9201      	str	r2, [sp, #4]
 8002bda:	781b      	ldrb	r3, [r3, #0]
 8002bdc:	f8ad 300e 	strh.w	r3, [sp, #14]
  hw |= (uint16_t)*p << 8U;
 8002be0:	9b01      	ldr	r3, [sp, #4]
 8002be2:	781b      	ldrb	r3, [r3, #0]
 8002be4:	021b      	lsls	r3, r3, #8
 8002be6:	b21a      	sxth	r2, r3
 8002be8:	f9bd 300e 	ldrsh.w	r3, [sp, #14]
 8002bec:	4313      	orrs	r3, r2
 8002bee:	b21b      	sxth	r3, r3
 8002bf0:	f8ad 300e 	strh.w	r3, [sp, #14]
  return hw;
 8002bf4:	f8bd 300e 	ldrh.w	r3, [sp, #14]
}
 8002bf8:	4618      	mov	r0, r3
 8002bfa:	b004      	add	sp, #16
 8002bfc:	4770      	bx	lr
 8002bfe:	bf00      	nop

08002c00 <set_address>:
/**
 * @brief  SET ADDRESS transaction callback.
 *
 * @param[in] usbp      pointer to the @p USBDriver object
 */
static void set_address(USBDriver *usbp) {
 8002c00:	b500      	push	{lr}
 8002c02:	b083      	sub	sp, #12
 8002c04:	9001      	str	r0, [sp, #4]

  usbp->address = usbp->setup[2];
 8002c06:	9b01      	ldr	r3, [sp, #4]
 8002c08:	f893 205e 	ldrb.w	r2, [r3, #94]	; 0x5e
 8002c0c:	9b01      	ldr	r3, [sp, #4]
 8002c0e:	f883 2066 	strb.w	r2, [r3, #102]	; 0x66
  usb_lld_set_address(usbp);
 8002c12:	9801      	ldr	r0, [sp, #4]
 8002c14:	f002 fa84 	bl	8005120 <usb_lld_set_address>
  _usb_isr_invoke_event_cb(usbp, USB_EVENT_ADDRESS);
 8002c18:	9b01      	ldr	r3, [sp, #4]
 8002c1a:	685b      	ldr	r3, [r3, #4]
 8002c1c:	681b      	ldr	r3, [r3, #0]
 8002c1e:	2b00      	cmp	r3, #0
 8002c20:	d005      	beq.n	8002c2e <set_address+0x2e>
 8002c22:	9b01      	ldr	r3, [sp, #4]
 8002c24:	685b      	ldr	r3, [r3, #4]
 8002c26:	681b      	ldr	r3, [r3, #0]
 8002c28:	2101      	movs	r1, #1
 8002c2a:	9801      	ldr	r0, [sp, #4]
 8002c2c:	4798      	blx	r3
  usbp->state = USB_SELECTED;
 8002c2e:	9b01      	ldr	r3, [sp, #4]
 8002c30:	2203      	movs	r2, #3
 8002c32:	701a      	strb	r2, [r3, #0]
}
 8002c34:	b003      	add	sp, #12
 8002c36:	f85d fb04 	ldr.w	pc, [sp], #4
 8002c3a:	bf00      	nop
 8002c3c:	0000      	movs	r0, r0
	...

08002c40 <default_handler>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @return              The request handling exit code.
 * @retval false        Request not recognized by the handler or error.
 * @retval true         Request handled.
 */
static bool default_handler(USBDriver *usbp) {
 8002c40:	b570      	push	{r4, r5, r6, lr}
 8002c42:	b084      	sub	sp, #16
 8002c44:	9001      	str	r0, [sp, #4]
  const USBDescriptor *dp;

  /* Decoding the request.*/
  switch ((((uint32_t)usbp->setup[0] & (USB_RTYPE_RECIPIENT_MASK |
 8002c46:	9b01      	ldr	r3, [sp, #4]
 8002c48:	f893 305c 	ldrb.w	r3, [r3, #92]	; 0x5c
 8002c4c:	f003 027f 	and.w	r2, r3, #127	; 0x7f
                                        USB_RTYPE_TYPE_MASK)) |
           ((uint32_t)usbp->setup[1] << 8U))) {
 8002c50:	9b01      	ldr	r3, [sp, #4]
 8002c52:	f893 305d 	ldrb.w	r3, [r3, #93]	; 0x5d
 8002c56:	021b      	lsls	r3, r3, #8
                                        USB_RTYPE_TYPE_MASK)) |
 8002c58:	4313      	orrs	r3, r2
  switch ((((uint32_t)usbp->setup[0] & (USB_RTYPE_RECIPIENT_MASK |
 8002c5a:	f240 3202 	movw	r2, #770	; 0x302
 8002c5e:	4293      	cmp	r3, r2
 8002c60:	f000 8197 	beq.w	8002f92 <default_handler+0x352>
 8002c64:	f240 3202 	movw	r2, #770	; 0x302
 8002c68:	4293      	cmp	r3, r2
 8002c6a:	d815      	bhi.n	8002c98 <default_handler+0x58>
 8002c6c:	2b02      	cmp	r3, #2
 8002c6e:	f000 8106 	beq.w	8002e7e <default_handler+0x23e>
 8002c72:	2b02      	cmp	r3, #2
 8002c74:	d805      	bhi.n	8002c82 <default_handler+0x42>
 8002c76:	2b00      	cmp	r3, #0
 8002c78:	d027      	beq.n	8002cca <default_handler+0x8a>
 8002c7a:	2b01      	cmp	r3, #1
 8002c7c:	f000 80f4 	beq.w	8002e68 <default_handler+0x228>
 8002c80:	e1bb      	b.n	8002ffa <default_handler+0x3ba>
 8002c82:	f5b3 7f81 	cmp.w	r3, #258	; 0x102
 8002c86:	f000 8150 	beq.w	8002f2a <default_handler+0x2ea>
 8002c8a:	f5b3 7f40 	cmp.w	r3, #768	; 0x300
 8002c8e:	d044      	beq.n	8002d1a <default_handler+0xda>
 8002c90:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 8002c94:	d026      	beq.n	8002ce4 <default_handler+0xa4>
 8002c96:	e1b0      	b.n	8002ffa <default_handler+0x3ba>
 8002c98:	f240 6201 	movw	r2, #1537	; 0x601
 8002c9c:	4293      	cmp	r3, r2
 8002c9e:	d806      	bhi.n	8002cae <default_handler+0x6e>
 8002ca0:	f5b3 6fc0 	cmp.w	r3, #1536	; 0x600
 8002ca4:	d26c      	bcs.n	8002d80 <default_handler+0x140>
 8002ca6:	f5b3 6fa0 	cmp.w	r3, #1280	; 0x500
 8002caa:	d051      	beq.n	8002d50 <default_handler+0x110>
 8002cac:	e1a5      	b.n	8002ffa <default_handler+0x3ba>
 8002cae:	f5b3 6f10 	cmp.w	r3, #2304	; 0x900
 8002cb2:	f000 8098 	beq.w	8002de6 <default_handler+0x1a6>
 8002cb6:	f640 4202 	movw	r2, #3074	; 0xc02
 8002cba:	4293      	cmp	r3, r2
 8002cbc:	f000 80d4 	beq.w	8002e68 <default_handler+0x228>
 8002cc0:	f5b3 6f00 	cmp.w	r3, #2048	; 0x800
 8002cc4:	f000 8082 	beq.w	8002dcc <default_handler+0x18c>
 8002cc8:	e197      	b.n	8002ffa <default_handler+0x3ba>
  case (uint32_t)USB_RTYPE_RECIPIENT_DEVICE | ((uint32_t)USB_REQ_GET_STATUS << 8):
    /* Just returns the current status word.*/
    usbSetupTransfer(usbp, (uint8_t *)&usbp->status, 2, NULL);
 8002cca:	9b01      	ldr	r3, [sp, #4]
 8002ccc:	f103 0264 	add.w	r2, r3, #100	; 0x64
 8002cd0:	9b01      	ldr	r3, [sp, #4]
 8002cd2:	651a      	str	r2, [r3, #80]	; 0x50
 8002cd4:	9b01      	ldr	r3, [sp, #4]
 8002cd6:	2202      	movs	r2, #2
 8002cd8:	655a      	str	r2, [r3, #84]	; 0x54
 8002cda:	9b01      	ldr	r3, [sp, #4]
 8002cdc:	2200      	movs	r2, #0
 8002cde:	659a      	str	r2, [r3, #88]	; 0x58
    return true;
 8002ce0:	2301      	movs	r3, #1
 8002ce2:	e18b      	b.n	8002ffc <default_handler+0x3bc>
  case (uint32_t)USB_RTYPE_RECIPIENT_DEVICE | ((uint32_t)USB_REQ_CLEAR_FEATURE << 8):
    /* Only the DEVICE_REMOTE_WAKEUP is handled here, any other feature
       number is handled as an error.*/
    if (usbp->setup[2] == USB_FEATURE_DEVICE_REMOTE_WAKEUP) {
 8002ce4:	9b01      	ldr	r3, [sp, #4]
 8002ce6:	f893 305e 	ldrb.w	r3, [r3, #94]	; 0x5e
 8002cea:	2b01      	cmp	r3, #1
 8002cec:	d113      	bne.n	8002d16 <default_handler+0xd6>
      usbp->status &= ~2U;
 8002cee:	9b01      	ldr	r3, [sp, #4]
 8002cf0:	f8b3 3064 	ldrh.w	r3, [r3, #100]	; 0x64
 8002cf4:	f023 0302 	bic.w	r3, r3, #2
 8002cf8:	b29a      	uxth	r2, r3
 8002cfa:	9b01      	ldr	r3, [sp, #4]
 8002cfc:	f8a3 2064 	strh.w	r2, [r3, #100]	; 0x64
      usbSetupTransfer(usbp, NULL, 0, NULL);
 8002d00:	9b01      	ldr	r3, [sp, #4]
 8002d02:	2200      	movs	r2, #0
 8002d04:	651a      	str	r2, [r3, #80]	; 0x50
 8002d06:	9b01      	ldr	r3, [sp, #4]
 8002d08:	2200      	movs	r2, #0
 8002d0a:	655a      	str	r2, [r3, #84]	; 0x54
 8002d0c:	9b01      	ldr	r3, [sp, #4]
 8002d0e:	2200      	movs	r2, #0
 8002d10:	659a      	str	r2, [r3, #88]	; 0x58
      return true;
 8002d12:	2301      	movs	r3, #1
 8002d14:	e172      	b.n	8002ffc <default_handler+0x3bc>
    }
    return false;
 8002d16:	2300      	movs	r3, #0
 8002d18:	e170      	b.n	8002ffc <default_handler+0x3bc>
  case (uint32_t)USB_RTYPE_RECIPIENT_DEVICE | ((uint32_t)USB_REQ_SET_FEATURE << 8):
    /* Only the DEVICE_REMOTE_WAKEUP is handled here, any other feature
       number is handled as an error.*/
    if (usbp->setup[2] == USB_FEATURE_DEVICE_REMOTE_WAKEUP) {
 8002d1a:	9b01      	ldr	r3, [sp, #4]
 8002d1c:	f893 305e 	ldrb.w	r3, [r3, #94]	; 0x5e
 8002d20:	2b01      	cmp	r3, #1
 8002d22:	d113      	bne.n	8002d4c <default_handler+0x10c>
      usbp->status |= 2U;
 8002d24:	9b01      	ldr	r3, [sp, #4]
 8002d26:	f8b3 3064 	ldrh.w	r3, [r3, #100]	; 0x64
 8002d2a:	f043 0302 	orr.w	r3, r3, #2
 8002d2e:	b29a      	uxth	r2, r3
 8002d30:	9b01      	ldr	r3, [sp, #4]
 8002d32:	f8a3 2064 	strh.w	r2, [r3, #100]	; 0x64
      usbSetupTransfer(usbp, NULL, 0, NULL);
 8002d36:	9b01      	ldr	r3, [sp, #4]
 8002d38:	2200      	movs	r2, #0
 8002d3a:	651a      	str	r2, [r3, #80]	; 0x50
 8002d3c:	9b01      	ldr	r3, [sp, #4]
 8002d3e:	2200      	movs	r2, #0
 8002d40:	655a      	str	r2, [r3, #84]	; 0x54
 8002d42:	9b01      	ldr	r3, [sp, #4]
 8002d44:	2200      	movs	r2, #0
 8002d46:	659a      	str	r2, [r3, #88]	; 0x58
      return true;
 8002d48:	2301      	movs	r3, #1
 8002d4a:	e157      	b.n	8002ffc <default_handler+0x3bc>
    }
    return false;
 8002d4c:	2300      	movs	r3, #0
 8002d4e:	e155      	b.n	8002ffc <default_handler+0x3bc>
  case (uint32_t)USB_RTYPE_RECIPIENT_DEVICE | ((uint32_t)USB_REQ_SET_ADDRESS << 8):
    /* The SET_ADDRESS handling can be performed here or postponed after
       the status packed depending on the USB_SET_ADDRESS_MODE low
       driver setting.*/
#if USB_SET_ADDRESS_MODE == USB_EARLY_SET_ADDRESS
    if ((usbp->setup[0] == USB_RTYPE_RECIPIENT_DEVICE) &&
 8002d50:	9b01      	ldr	r3, [sp, #4]
 8002d52:	f893 305c 	ldrb.w	r3, [r3, #92]	; 0x5c
 8002d56:	2b00      	cmp	r3, #0
 8002d58:	d107      	bne.n	8002d6a <default_handler+0x12a>
        (usbp->setup[1] == USB_REQ_SET_ADDRESS)) {
 8002d5a:	9b01      	ldr	r3, [sp, #4]
 8002d5c:	f893 305d 	ldrb.w	r3, [r3, #93]	; 0x5d
    if ((usbp->setup[0] == USB_RTYPE_RECIPIENT_DEVICE) &&
 8002d60:	2b05      	cmp	r3, #5
 8002d62:	d102      	bne.n	8002d6a <default_handler+0x12a>
      set_address(usbp);
 8002d64:	9801      	ldr	r0, [sp, #4]
 8002d66:	f7ff ff4b 	bl	8002c00 <set_address>
    }
    usbSetupTransfer(usbp, NULL, 0, NULL);
 8002d6a:	9b01      	ldr	r3, [sp, #4]
 8002d6c:	2200      	movs	r2, #0
 8002d6e:	651a      	str	r2, [r3, #80]	; 0x50
 8002d70:	9b01      	ldr	r3, [sp, #4]
 8002d72:	2200      	movs	r2, #0
 8002d74:	655a      	str	r2, [r3, #84]	; 0x54
 8002d76:	9b01      	ldr	r3, [sp, #4]
 8002d78:	2200      	movs	r2, #0
 8002d7a:	659a      	str	r2, [r3, #88]	; 0x58
#else
    usbSetupTransfer(usbp, NULL, 0, set_address);
#endif
    return true;
 8002d7c:	2301      	movs	r3, #1
 8002d7e:	e13d      	b.n	8002ffc <default_handler+0x3bc>
  case (uint32_t)USB_RTYPE_RECIPIENT_DEVICE | ((uint32_t)USB_REQ_GET_DESCRIPTOR << 8):
  case (uint32_t)USB_RTYPE_RECIPIENT_INTERFACE | ((uint32_t)USB_REQ_GET_DESCRIPTOR << 8):
    /* Handling descriptor requests from the host.*/
    dp = usbp->config->get_descriptor_cb(usbp, usbp->setup[3],
 8002d80:	9b01      	ldr	r3, [sp, #4]
 8002d82:	685b      	ldr	r3, [r3, #4]
 8002d84:	685c      	ldr	r4, [r3, #4]
 8002d86:	9b01      	ldr	r3, [sp, #4]
 8002d88:	f893 505f 	ldrb.w	r5, [r3, #95]	; 0x5f
 8002d8c:	9b01      	ldr	r3, [sp, #4]
 8002d8e:	f893 605e 	ldrb.w	r6, [r3, #94]	; 0x5e
 8002d92:	9b01      	ldr	r3, [sp, #4]
 8002d94:	3360      	adds	r3, #96	; 0x60
 8002d96:	4618      	mov	r0, r3
 8002d98:	f7ff ff1a 	bl	8002bd0 <get_hword>
 8002d9c:	4603      	mov	r3, r0
 8002d9e:	4632      	mov	r2, r6
 8002da0:	4629      	mov	r1, r5
 8002da2:	9801      	ldr	r0, [sp, #4]
 8002da4:	47a0      	blx	r4
 8002da6:	9003      	str	r0, [sp, #12]
                                         usbp->setup[2],
                                         get_hword(&usbp->setup[4]));
    if (dp == NULL) {
 8002da8:	9b03      	ldr	r3, [sp, #12]
 8002daa:	2b00      	cmp	r3, #0
 8002dac:	d101      	bne.n	8002db2 <default_handler+0x172>
      return false;
 8002dae:	2300      	movs	r3, #0
 8002db0:	e124      	b.n	8002ffc <default_handler+0x3bc>
    }
    /*lint -save -e9005 [11.8] Removing const is fine.*/
    usbSetupTransfer(usbp, (uint8_t *)dp->ud_string, dp->ud_size, NULL);
 8002db2:	9b03      	ldr	r3, [sp, #12]
 8002db4:	685a      	ldr	r2, [r3, #4]
 8002db6:	9b01      	ldr	r3, [sp, #4]
 8002db8:	651a      	str	r2, [r3, #80]	; 0x50
 8002dba:	9b03      	ldr	r3, [sp, #12]
 8002dbc:	681a      	ldr	r2, [r3, #0]
 8002dbe:	9b01      	ldr	r3, [sp, #4]
 8002dc0:	655a      	str	r2, [r3, #84]	; 0x54
 8002dc2:	9b01      	ldr	r3, [sp, #4]
 8002dc4:	2200      	movs	r2, #0
 8002dc6:	659a      	str	r2, [r3, #88]	; 0x58
    /*lint -restore*/
    return true;
 8002dc8:	2301      	movs	r3, #1
 8002dca:	e117      	b.n	8002ffc <default_handler+0x3bc>
  case (uint32_t)USB_RTYPE_RECIPIENT_DEVICE | ((uint32_t)USB_REQ_GET_CONFIGURATION << 8):
    /* Returning the last selected configuration.*/
    usbSetupTransfer(usbp, &usbp->configuration, 1, NULL);
 8002dcc:	9b01      	ldr	r3, [sp, #4]
 8002dce:	f103 0267 	add.w	r2, r3, #103	; 0x67
 8002dd2:	9b01      	ldr	r3, [sp, #4]
 8002dd4:	651a      	str	r2, [r3, #80]	; 0x50
 8002dd6:	9b01      	ldr	r3, [sp, #4]
 8002dd8:	2201      	movs	r2, #1
 8002dda:	655a      	str	r2, [r3, #84]	; 0x54
 8002ddc:	9b01      	ldr	r3, [sp, #4]
 8002dde:	2200      	movs	r2, #0
 8002de0:	659a      	str	r2, [r3, #88]	; 0x58
    return true;
 8002de2:	2301      	movs	r3, #1
 8002de4:	e10a      	b.n	8002ffc <default_handler+0x3bc>
    if (usbp->configuration != usbp->setup[2])
#endif
    {
      /* If the USB device is already active then we have to perform the clear
         procedure on the current configuration.*/
      if (usbp->state == USB_ACTIVE) {
 8002de6:	9b01      	ldr	r3, [sp, #4]
 8002de8:	781b      	ldrb	r3, [r3, #0]
 8002dea:	2b04      	cmp	r3, #4
 8002dec:	d118      	bne.n	8002e20 <default_handler+0x1e0>
        /* Current configuration cleared.*/
        osalSysLockFromISR ();
 8002dee:	f7ff fedf 	bl	8002bb0 <osalSysLockFromISR.lto_priv.668>
        usbDisableEndpointsI(usbp);
 8002df2:	9801      	ldr	r0, [sp, #4]
 8002df4:	f000 f9cc 	bl	8003190 <usbDisableEndpointsI>
        osalSysUnlockFromISR ();
 8002df8:	f7ff fee2 	bl	8002bc0 <osalSysUnlockFromISR.lto_priv.662>
        usbp->configuration = 0U;
 8002dfc:	9b01      	ldr	r3, [sp, #4]
 8002dfe:	2200      	movs	r2, #0
 8002e00:	f883 2067 	strb.w	r2, [r3, #103]	; 0x67
        usbp->state = USB_SELECTED;
 8002e04:	9b01      	ldr	r3, [sp, #4]
 8002e06:	2203      	movs	r2, #3
 8002e08:	701a      	strb	r2, [r3, #0]
        _usb_isr_invoke_event_cb(usbp, USB_EVENT_UNCONFIGURED);
 8002e0a:	9b01      	ldr	r3, [sp, #4]
 8002e0c:	685b      	ldr	r3, [r3, #4]
 8002e0e:	681b      	ldr	r3, [r3, #0]
 8002e10:	2b00      	cmp	r3, #0
 8002e12:	d005      	beq.n	8002e20 <default_handler+0x1e0>
 8002e14:	9b01      	ldr	r3, [sp, #4]
 8002e16:	685b      	ldr	r3, [r3, #4]
 8002e18:	681b      	ldr	r3, [r3, #0]
 8002e1a:	2103      	movs	r1, #3
 8002e1c:	9801      	ldr	r0, [sp, #4]
 8002e1e:	4798      	blx	r3
      }
      if (usbp->setup[2] != 0U) {
 8002e20:	9b01      	ldr	r3, [sp, #4]
 8002e22:	f893 305e 	ldrb.w	r3, [r3, #94]	; 0x5e
 8002e26:	2b00      	cmp	r3, #0
 8002e28:	d013      	beq.n	8002e52 <default_handler+0x212>
        /* New configuration.*/
        usbp->configuration = usbp->setup[2];
 8002e2a:	9b01      	ldr	r3, [sp, #4]
 8002e2c:	f893 205e 	ldrb.w	r2, [r3, #94]	; 0x5e
 8002e30:	9b01      	ldr	r3, [sp, #4]
 8002e32:	f883 2067 	strb.w	r2, [r3, #103]	; 0x67
        usbp->state = USB_ACTIVE;
 8002e36:	9b01      	ldr	r3, [sp, #4]
 8002e38:	2204      	movs	r2, #4
 8002e3a:	701a      	strb	r2, [r3, #0]
        _usb_isr_invoke_event_cb(usbp, USB_EVENT_CONFIGURED);
 8002e3c:	9b01      	ldr	r3, [sp, #4]
 8002e3e:	685b      	ldr	r3, [r3, #4]
 8002e40:	681b      	ldr	r3, [r3, #0]
 8002e42:	2b00      	cmp	r3, #0
 8002e44:	d005      	beq.n	8002e52 <default_handler+0x212>
 8002e46:	9b01      	ldr	r3, [sp, #4]
 8002e48:	685b      	ldr	r3, [r3, #4]
 8002e4a:	681b      	ldr	r3, [r3, #0]
 8002e4c:	2102      	movs	r1, #2
 8002e4e:	9801      	ldr	r0, [sp, #4]
 8002e50:	4798      	blx	r3
      }
    }
    usbSetupTransfer(usbp, NULL, 0, NULL);
 8002e52:	9b01      	ldr	r3, [sp, #4]
 8002e54:	2200      	movs	r2, #0
 8002e56:	651a      	str	r2, [r3, #80]	; 0x50
 8002e58:	9b01      	ldr	r3, [sp, #4]
 8002e5a:	2200      	movs	r2, #0
 8002e5c:	655a      	str	r2, [r3, #84]	; 0x54
 8002e5e:	9b01      	ldr	r3, [sp, #4]
 8002e60:	2200      	movs	r2, #0
 8002e62:	659a      	str	r2, [r3, #88]	; 0x58
    return true;
 8002e64:	2301      	movs	r3, #1
 8002e66:	e0c9      	b.n	8002ffc <default_handler+0x3bc>
  case (uint32_t)USB_RTYPE_RECIPIENT_INTERFACE | ((uint32_t)USB_REQ_GET_STATUS << 8):
  case (uint32_t)USB_RTYPE_RECIPIENT_ENDPOINT | ((uint32_t)USB_REQ_SYNCH_FRAME << 8):
    /* Just sending two zero bytes, the application can change the behavior
       using a hook..*/
    /*lint -save -e9005 [11.8] Removing const is fine.*/
    usbSetupTransfer(usbp, (uint8_t *)zero_status, 2, NULL);
 8002e68:	9b01      	ldr	r3, [sp, #4]
 8002e6a:	4a66      	ldr	r2, [pc, #408]	; (8003004 <default_handler+0x3c4>)
 8002e6c:	651a      	str	r2, [r3, #80]	; 0x50
 8002e6e:	9b01      	ldr	r3, [sp, #4]
 8002e70:	2202      	movs	r2, #2
 8002e72:	655a      	str	r2, [r3, #84]	; 0x54
 8002e74:	9b01      	ldr	r3, [sp, #4]
 8002e76:	2200      	movs	r2, #0
 8002e78:	659a      	str	r2, [r3, #88]	; 0x58
    /*lint -restore*/
    return true;
 8002e7a:	2301      	movs	r3, #1
 8002e7c:	e0be      	b.n	8002ffc <default_handler+0x3bc>
  case (uint32_t)USB_RTYPE_RECIPIENT_ENDPOINT | ((uint32_t)USB_REQ_GET_STATUS << 8):
    /* Sending the EP status.*/
    if ((usbp->setup[4] & 0x80U) != 0U) {
 8002e7e:	9b01      	ldr	r3, [sp, #4]
 8002e80:	f893 3060 	ldrb.w	r3, [r3, #96]	; 0x60
 8002e84:	b25b      	sxtb	r3, r3
 8002e86:	2b00      	cmp	r3, #0
 8002e88:	da27      	bge.n	8002eda <default_handler+0x29a>
      switch (usb_lld_get_status_in(usbp, usbp->setup[4] & 0x0FU)) {
 8002e8a:	9b01      	ldr	r3, [sp, #4]
 8002e8c:	f893 3060 	ldrb.w	r3, [r3, #96]	; 0x60
 8002e90:	f003 030f 	and.w	r3, r3, #15
 8002e94:	b2db      	uxtb	r3, r3
 8002e96:	4619      	mov	r1, r3
 8002e98:	9801      	ldr	r0, [sp, #4]
 8002e9a:	f002 fab1 	bl	8005400 <usb_lld_get_status_in>
 8002e9e:	4603      	mov	r3, r0
 8002ea0:	2b01      	cmp	r3, #1
 8002ea2:	d002      	beq.n	8002eaa <default_handler+0x26a>
 8002ea4:	2b02      	cmp	r3, #2
 8002ea6:	d00b      	beq.n	8002ec0 <default_handler+0x280>
 8002ea8:	e015      	b.n	8002ed6 <default_handler+0x296>
      case EP_STATUS_STALLED:
        /*lint -save -e9005 [11.8] Removing const is fine.*/
        usbSetupTransfer(usbp, (uint8_t *)halted_status, 2, NULL);
 8002eaa:	9b01      	ldr	r3, [sp, #4]
 8002eac:	4a56      	ldr	r2, [pc, #344]	; (8003008 <default_handler+0x3c8>)
 8002eae:	651a      	str	r2, [r3, #80]	; 0x50
 8002eb0:	9b01      	ldr	r3, [sp, #4]
 8002eb2:	2202      	movs	r2, #2
 8002eb4:	655a      	str	r2, [r3, #84]	; 0x54
 8002eb6:	9b01      	ldr	r3, [sp, #4]
 8002eb8:	2200      	movs	r2, #0
 8002eba:	659a      	str	r2, [r3, #88]	; 0x58
        /*lint -restore*/
        return true;
 8002ebc:	2301      	movs	r3, #1
 8002ebe:	e09d      	b.n	8002ffc <default_handler+0x3bc>
      case EP_STATUS_ACTIVE:
        /*lint -save -e9005 [11.8] Removing const is fine.*/
        usbSetupTransfer(usbp, (uint8_t *)active_status, 2, NULL);
 8002ec0:	9b01      	ldr	r3, [sp, #4]
 8002ec2:	4a52      	ldr	r2, [pc, #328]	; (800300c <default_handler+0x3cc>)
 8002ec4:	651a      	str	r2, [r3, #80]	; 0x50
 8002ec6:	9b01      	ldr	r3, [sp, #4]
 8002ec8:	2202      	movs	r2, #2
 8002eca:	655a      	str	r2, [r3, #84]	; 0x54
 8002ecc:	9b01      	ldr	r3, [sp, #4]
 8002ece:	2200      	movs	r2, #0
 8002ed0:	659a      	str	r2, [r3, #88]	; 0x58
        /*lint -restore*/
        return true;
 8002ed2:	2301      	movs	r3, #1
 8002ed4:	e092      	b.n	8002ffc <default_handler+0x3bc>
      case EP_STATUS_DISABLED:
      default:
        return false;
 8002ed6:	2300      	movs	r3, #0
 8002ed8:	e090      	b.n	8002ffc <default_handler+0x3bc>
      }
    }
    else {
      switch (usb_lld_get_status_out(usbp, usbp->setup[4] & 0x0FU)) {
 8002eda:	9b01      	ldr	r3, [sp, #4]
 8002edc:	f893 3060 	ldrb.w	r3, [r3, #96]	; 0x60
 8002ee0:	f003 030f 	and.w	r3, r3, #15
 8002ee4:	b2db      	uxtb	r3, r3
 8002ee6:	4619      	mov	r1, r3
 8002ee8:	9801      	ldr	r0, [sp, #4]
 8002eea:	f002 fa69 	bl	80053c0 <usb_lld_get_status_out>
 8002eee:	4603      	mov	r3, r0
 8002ef0:	2b01      	cmp	r3, #1
 8002ef2:	d002      	beq.n	8002efa <default_handler+0x2ba>
 8002ef4:	2b02      	cmp	r3, #2
 8002ef6:	d00b      	beq.n	8002f10 <default_handler+0x2d0>
 8002ef8:	e015      	b.n	8002f26 <default_handler+0x2e6>
      case EP_STATUS_STALLED:
        /*lint -save -e9005 [11.8] Removing const is fine.*/
        usbSetupTransfer(usbp, (uint8_t *)halted_status, 2, NULL);
 8002efa:	9b01      	ldr	r3, [sp, #4]
 8002efc:	4a42      	ldr	r2, [pc, #264]	; (8003008 <default_handler+0x3c8>)
 8002efe:	651a      	str	r2, [r3, #80]	; 0x50
 8002f00:	9b01      	ldr	r3, [sp, #4]
 8002f02:	2202      	movs	r2, #2
 8002f04:	655a      	str	r2, [r3, #84]	; 0x54
 8002f06:	9b01      	ldr	r3, [sp, #4]
 8002f08:	2200      	movs	r2, #0
 8002f0a:	659a      	str	r2, [r3, #88]	; 0x58
        /*lint -restore*/
        return true;
 8002f0c:	2301      	movs	r3, #1
 8002f0e:	e075      	b.n	8002ffc <default_handler+0x3bc>
      case EP_STATUS_ACTIVE:
        /*lint -save -e9005 [11.8] Removing const is fine.*/
        usbSetupTransfer(usbp, (uint8_t *)active_status, 2, NULL);
 8002f10:	9b01      	ldr	r3, [sp, #4]
 8002f12:	4a3e      	ldr	r2, [pc, #248]	; (800300c <default_handler+0x3cc>)
 8002f14:	651a      	str	r2, [r3, #80]	; 0x50
 8002f16:	9b01      	ldr	r3, [sp, #4]
 8002f18:	2202      	movs	r2, #2
 8002f1a:	655a      	str	r2, [r3, #84]	; 0x54
 8002f1c:	9b01      	ldr	r3, [sp, #4]
 8002f1e:	2200      	movs	r2, #0
 8002f20:	659a      	str	r2, [r3, #88]	; 0x58
        /*lint -restore*/
        return true;
 8002f22:	2301      	movs	r3, #1
 8002f24:	e06a      	b.n	8002ffc <default_handler+0x3bc>
      case EP_STATUS_DISABLED:
      default:
        return false;
 8002f26:	2300      	movs	r3, #0
 8002f28:	e068      	b.n	8002ffc <default_handler+0x3bc>
      }
    }
  case (uint32_t)USB_RTYPE_RECIPIENT_ENDPOINT | ((uint32_t)USB_REQ_CLEAR_FEATURE << 8):
    /* Only ENDPOINT_HALT is handled as feature.*/
    if (usbp->setup[2] != USB_FEATURE_ENDPOINT_HALT) {
 8002f2a:	9b01      	ldr	r3, [sp, #4]
 8002f2c:	f893 305e 	ldrb.w	r3, [r3, #94]	; 0x5e
 8002f30:	2b00      	cmp	r3, #0
 8002f32:	d001      	beq.n	8002f38 <default_handler+0x2f8>
      return false;
 8002f34:	2300      	movs	r3, #0
 8002f36:	e061      	b.n	8002ffc <default_handler+0x3bc>
    }
    /* Clearing the EP status, not valid for EP0, it is ignored in that case.*/
    if ((usbp->setup[4] & 0x0FU) != 0U) {
 8002f38:	9b01      	ldr	r3, [sp, #4]
 8002f3a:	f893 3060 	ldrb.w	r3, [r3, #96]	; 0x60
 8002f3e:	f003 030f 	and.w	r3, r3, #15
 8002f42:	2b00      	cmp	r3, #0
 8002f44:	d01a      	beq.n	8002f7c <default_handler+0x33c>
      if ((usbp->setup[4] & 0x80U) != 0U) {
 8002f46:	9b01      	ldr	r3, [sp, #4]
 8002f48:	f893 3060 	ldrb.w	r3, [r3, #96]	; 0x60
 8002f4c:	b25b      	sxtb	r3, r3
 8002f4e:	2b00      	cmp	r3, #0
 8002f50:	da0a      	bge.n	8002f68 <default_handler+0x328>
        usb_lld_clear_in(usbp, usbp->setup[4] & 0x0FU);
 8002f52:	9b01      	ldr	r3, [sp, #4]
 8002f54:	f893 3060 	ldrb.w	r3, [r3, #96]	; 0x60
 8002f58:	f003 030f 	and.w	r3, r3, #15
 8002f5c:	b2db      	uxtb	r3, r3
 8002f5e:	4619      	mov	r1, r3
 8002f60:	9801      	ldr	r0, [sp, #4]
 8002f62:	f002 fc35 	bl	80057d0 <usb_lld_clear_in>
 8002f66:	e009      	b.n	8002f7c <default_handler+0x33c>
      }
      else {
        usb_lld_clear_out(usbp, usbp->setup[4] & 0x0FU);
 8002f68:	9b01      	ldr	r3, [sp, #4]
 8002f6a:	f893 3060 	ldrb.w	r3, [r3, #96]	; 0x60
 8002f6e:	f003 030f 	and.w	r3, r3, #15
 8002f72:	b2db      	uxtb	r3, r3
 8002f74:	4619      	mov	r1, r3
 8002f76:	9801      	ldr	r0, [sp, #4]
 8002f78:	f002 fc0a 	bl	8005790 <usb_lld_clear_out>
      }
    }
    usbSetupTransfer(usbp, NULL, 0, NULL);
 8002f7c:	9b01      	ldr	r3, [sp, #4]
 8002f7e:	2200      	movs	r2, #0
 8002f80:	651a      	str	r2, [r3, #80]	; 0x50
 8002f82:	9b01      	ldr	r3, [sp, #4]
 8002f84:	2200      	movs	r2, #0
 8002f86:	655a      	str	r2, [r3, #84]	; 0x54
 8002f88:	9b01      	ldr	r3, [sp, #4]
 8002f8a:	2200      	movs	r2, #0
 8002f8c:	659a      	str	r2, [r3, #88]	; 0x58
    return true;
 8002f8e:	2301      	movs	r3, #1
 8002f90:	e034      	b.n	8002ffc <default_handler+0x3bc>
  case (uint32_t)USB_RTYPE_RECIPIENT_ENDPOINT | ((uint32_t)USB_REQ_SET_FEATURE << 8):
    /* Only ENDPOINT_HALT is handled as feature.*/
    if (usbp->setup[2] != USB_FEATURE_ENDPOINT_HALT) {
 8002f92:	9b01      	ldr	r3, [sp, #4]
 8002f94:	f893 305e 	ldrb.w	r3, [r3, #94]	; 0x5e
 8002f98:	2b00      	cmp	r3, #0
 8002f9a:	d001      	beq.n	8002fa0 <default_handler+0x360>
      return false;
 8002f9c:	2300      	movs	r3, #0
 8002f9e:	e02d      	b.n	8002ffc <default_handler+0x3bc>
    }
    /* Stalling the EP, not valid for EP0, it is ignored in that case.*/
    if ((usbp->setup[4] & 0x0FU) != 0U) {
 8002fa0:	9b01      	ldr	r3, [sp, #4]
 8002fa2:	f893 3060 	ldrb.w	r3, [r3, #96]	; 0x60
 8002fa6:	f003 030f 	and.w	r3, r3, #15
 8002faa:	2b00      	cmp	r3, #0
 8002fac:	d01a      	beq.n	8002fe4 <default_handler+0x3a4>
      if ((usbp->setup[4] & 0x80U) != 0U) {
 8002fae:	9b01      	ldr	r3, [sp, #4]
 8002fb0:	f893 3060 	ldrb.w	r3, [r3, #96]	; 0x60
 8002fb4:	b25b      	sxtb	r3, r3
 8002fb6:	2b00      	cmp	r3, #0
 8002fb8:	da0a      	bge.n	8002fd0 <default_handler+0x390>
        usb_lld_stall_in(usbp, usbp->setup[4] & 0x0FU);
 8002fba:	9b01      	ldr	r3, [sp, #4]
 8002fbc:	f893 3060 	ldrb.w	r3, [r3, #96]	; 0x60
 8002fc0:	f003 030f 	and.w	r3, r3, #15
 8002fc4:	b2db      	uxtb	r3, r3
 8002fc6:	4619      	mov	r1, r3
 8002fc8:	9801      	ldr	r0, [sp, #4]
 8002fca:	f002 fbc1 	bl	8005750 <usb_lld_stall_in>
 8002fce:	e009      	b.n	8002fe4 <default_handler+0x3a4>
      }
      else {
        usb_lld_stall_out(usbp, usbp->setup[4] & 0x0FU);
 8002fd0:	9b01      	ldr	r3, [sp, #4]
 8002fd2:	f893 3060 	ldrb.w	r3, [r3, #96]	; 0x60
 8002fd6:	f003 030f 	and.w	r3, r3, #15
 8002fda:	b2db      	uxtb	r3, r3
 8002fdc:	4619      	mov	r1, r3
 8002fde:	9801      	ldr	r0, [sp, #4]
 8002fe0:	f002 fb96 	bl	8005710 <usb_lld_stall_out>
      }
    }
    usbSetupTransfer(usbp, NULL, 0, NULL);
 8002fe4:	9b01      	ldr	r3, [sp, #4]
 8002fe6:	2200      	movs	r2, #0
 8002fe8:	651a      	str	r2, [r3, #80]	; 0x50
 8002fea:	9b01      	ldr	r3, [sp, #4]
 8002fec:	2200      	movs	r2, #0
 8002fee:	655a      	str	r2, [r3, #84]	; 0x54
 8002ff0:	9b01      	ldr	r3, [sp, #4]
 8002ff2:	2200      	movs	r2, #0
 8002ff4:	659a      	str	r2, [r3, #88]	; 0x58
    return true;
 8002ff6:	2301      	movs	r3, #1
 8002ff8:	e000      	b.n	8002ffc <default_handler+0x3bc>
  case (uint32_t)USB_RTYPE_RECIPIENT_INTERFACE | ((uint32_t)USB_REQ_GET_INTERFACE << 8):
  case (uint32_t)USB_RTYPE_RECIPIENT_INTERFACE | ((uint32_t)USB_REQ_SET_INTERFACE << 8):
    /* All the above requests are not handled here, if you need them then
       use the hook mechanism and provide handling.*/
  default:
    return false;
 8002ffa:	2300      	movs	r3, #0
  }
}
 8002ffc:	4618      	mov	r0, r3
 8002ffe:	b004      	add	sp, #16
 8003000:	bd70      	pop	{r4, r5, r6, pc}
 8003002:	bf00      	nop
 8003004:	08008874 	.word	0x08008874
 8003008:	0800887c 	.word	0x0800887c
 800300c:	08008878 	.word	0x08008878

08003010 <usbInit>:
 * @note    This function is implicitly invoked by @p halInit(), there is
 *          no need to explicitly initialize the driver.
 *
 * @init
 */
void usbInit(void) {
 8003010:	b508      	push	{r3, lr}

  usb_lld_init();
 8003012:	f001 ff15 	bl	8004e40 <usb_lld_init>
}
 8003016:	bd08      	pop	{r3, pc}
	...

08003020 <usbObjectInit>:
 *
 * @param[out] usbp     pointer to the @p USBDriver object
 *
 * @init
 */
void usbObjectInit(USBDriver *usbp) {
 8003020:	b084      	sub	sp, #16
 8003022:	9001      	str	r0, [sp, #4]
  unsigned i;

  usbp->state        = USB_STOP;
 8003024:	9b01      	ldr	r3, [sp, #4]
 8003026:	2201      	movs	r2, #1
 8003028:	701a      	strb	r2, [r3, #0]
  usbp->config       = NULL;
 800302a:	9b01      	ldr	r3, [sp, #4]
 800302c:	2200      	movs	r2, #0
 800302e:	605a      	str	r2, [r3, #4]
  for (i = 0; i < (unsigned)USB_MAX_ENDPOINTS; i++) {
 8003030:	2300      	movs	r3, #0
 8003032:	9303      	str	r3, [sp, #12]
 8003034:	e00f      	b.n	8003056 <usbObjectInit+0x36>
    usbp->in_params[i]  = NULL;
 8003036:	9a01      	ldr	r2, [sp, #4]
 8003038:	9b03      	ldr	r3, [sp, #12]
 800303a:	3308      	adds	r3, #8
 800303c:	009b      	lsls	r3, r3, #2
 800303e:	4413      	add	r3, r2
 8003040:	2200      	movs	r2, #0
 8003042:	605a      	str	r2, [r3, #4]
    usbp->out_params[i] = NULL;
 8003044:	9b01      	ldr	r3, [sp, #4]
 8003046:	9a03      	ldr	r2, [sp, #12]
 8003048:	320e      	adds	r2, #14
 800304a:	2100      	movs	r1, #0
 800304c:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
  for (i = 0; i < (unsigned)USB_MAX_ENDPOINTS; i++) {
 8003050:	9b03      	ldr	r3, [sp, #12]
 8003052:	3301      	adds	r3, #1
 8003054:	9303      	str	r3, [sp, #12]
 8003056:	9b03      	ldr	r3, [sp, #12]
 8003058:	2b04      	cmp	r3, #4
 800305a:	d9ec      	bls.n	8003036 <usbObjectInit+0x16>
  }
  usbp->transmitting = 0;
 800305c:	9b01      	ldr	r3, [sp, #4]
 800305e:	2200      	movs	r2, #0
 8003060:	811a      	strh	r2, [r3, #8]
  usbp->receiving    = 0;
 8003062:	9b01      	ldr	r3, [sp, #4]
 8003064:	2200      	movs	r2, #0
 8003066:	815a      	strh	r2, [r3, #10]
}
 8003068:	b004      	add	sp, #16
 800306a:	4770      	bx	lr
 800306c:	0000      	movs	r0, r0
	...

08003070 <usbStart>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] config    pointer to the @p USBConfig object
 *
 * @api
 */
void usbStart(USBDriver *usbp, const USBConfig *config) {
 8003070:	b500      	push	{lr}
 8003072:	b085      	sub	sp, #20
 8003074:	9001      	str	r0, [sp, #4]
 8003076:	9100      	str	r1, [sp, #0]
  unsigned i;

  osalDbgCheck((usbp != NULL) && (config != NULL));
 8003078:	9b01      	ldr	r3, [sp, #4]
 800307a:	2b00      	cmp	r3, #0
 800307c:	d002      	beq.n	8003084 <usbStart+0x14>
 800307e:	9b00      	ldr	r3, [sp, #0]
 8003080:	2b00      	cmp	r3, #0
 8003082:	d102      	bne.n	800308a <usbStart+0x1a>
 8003084:	4816      	ldr	r0, [pc, #88]	; (80030e0 <usbStart+0x70>)
 8003086:	f003 f953 	bl	8006330 <chSysHalt>

  osalSysLock();
 800308a:	f7ff fd81 	bl	8002b90 <osalSysLock.lto_priv.489>
  osalDbgAssert((usbp->state == USB_STOP) || (usbp->state == USB_READY),
 800308e:	9b01      	ldr	r3, [sp, #4]
 8003090:	781b      	ldrb	r3, [r3, #0]
 8003092:	2b01      	cmp	r3, #1
 8003094:	d006      	beq.n	80030a4 <usbStart+0x34>
 8003096:	9b01      	ldr	r3, [sp, #4]
 8003098:	781b      	ldrb	r3, [r3, #0]
 800309a:	2b02      	cmp	r3, #2
 800309c:	d002      	beq.n	80030a4 <usbStart+0x34>
 800309e:	4810      	ldr	r0, [pc, #64]	; (80030e0 <usbStart+0x70>)
 80030a0:	f003 f946 	bl	8006330 <chSysHalt>
                "invalid state");
  usbp->config = config;
 80030a4:	9b01      	ldr	r3, [sp, #4]
 80030a6:	9a00      	ldr	r2, [sp, #0]
 80030a8:	605a      	str	r2, [r3, #4]
  for (i = 0; i <= (unsigned)USB_MAX_ENDPOINTS; i++) {
 80030aa:	2300      	movs	r3, #0
 80030ac:	9303      	str	r3, [sp, #12]
 80030ae:	e009      	b.n	80030c4 <usbStart+0x54>
    usbp->epc[i] = NULL;
 80030b0:	9a01      	ldr	r2, [sp, #4]
 80030b2:	9b03      	ldr	r3, [sp, #12]
 80030b4:	3302      	adds	r3, #2
 80030b6:	009b      	lsls	r3, r3, #2
 80030b8:	4413      	add	r3, r2
 80030ba:	2200      	movs	r2, #0
 80030bc:	605a      	str	r2, [r3, #4]
  for (i = 0; i <= (unsigned)USB_MAX_ENDPOINTS; i++) {
 80030be:	9b03      	ldr	r3, [sp, #12]
 80030c0:	3301      	adds	r3, #1
 80030c2:	9303      	str	r3, [sp, #12]
 80030c4:	9b03      	ldr	r3, [sp, #12]
 80030c6:	2b05      	cmp	r3, #5
 80030c8:	d9f2      	bls.n	80030b0 <usbStart+0x40>
  }
  usb_lld_start(usbp);
 80030ca:	9801      	ldr	r0, [sp, #4]
 80030cc:	f001 fed8 	bl	8004e80 <usb_lld_start>
  usbp->state = USB_READY;
 80030d0:	9b01      	ldr	r3, [sp, #4]
 80030d2:	2202      	movs	r2, #2
 80030d4:	701a      	strb	r2, [r3, #0]
  osalSysUnlock();
 80030d6:	f7ff fd63 	bl	8002ba0 <osalSysUnlock.lto_priv.478>
}
 80030da:	b005      	add	sp, #20
 80030dc:	f85d fb04 	ldr.w	pc, [sp], #4
 80030e0:	08008880 	.word	0x08008880
	...

080030f0 <usbInitEndpointI>:
 * @param[in] epcp      the endpoint configuration
 *
 * @iclass
 */
void usbInitEndpointI(USBDriver *usbp, usbep_t ep,
                      const USBEndpointConfig *epcp) {
 80030f0:	b500      	push	{lr}
 80030f2:	b085      	sub	sp, #20
 80030f4:	9003      	str	r0, [sp, #12]
 80030f6:	460b      	mov	r3, r1
 80030f8:	9201      	str	r2, [sp, #4]
 80030fa:	f88d 300b 	strb.w	r3, [sp, #11]

  osalDbgCheckClassI();
 80030fe:	f003 fa37 	bl	8006570 <chDbgCheckClassI>
  osalDbgCheck((usbp != NULL) && (epcp != NULL));
 8003102:	9b03      	ldr	r3, [sp, #12]
 8003104:	2b00      	cmp	r3, #0
 8003106:	d002      	beq.n	800310e <usbInitEndpointI+0x1e>
 8003108:	9b01      	ldr	r3, [sp, #4]
 800310a:	2b00      	cmp	r3, #0
 800310c:	d102      	bne.n	8003114 <usbInitEndpointI+0x24>
 800310e:	481e      	ldr	r0, [pc, #120]	; (8003188 <usbInitEndpointI+0x98>)
 8003110:	f003 f90e 	bl	8006330 <chSysHalt>
  osalDbgAssert(usbp->state == USB_ACTIVE,
 8003114:	9b03      	ldr	r3, [sp, #12]
 8003116:	781b      	ldrb	r3, [r3, #0]
 8003118:	2b04      	cmp	r3, #4
 800311a:	d002      	beq.n	8003122 <usbInitEndpointI+0x32>
 800311c:	481a      	ldr	r0, [pc, #104]	; (8003188 <usbInitEndpointI+0x98>)
 800311e:	f003 f907 	bl	8006330 <chSysHalt>
                "invalid state");
  osalDbgAssert(usbp->epc[ep] == NULL, "already initialized");
 8003122:	f89d 300b 	ldrb.w	r3, [sp, #11]
 8003126:	9a03      	ldr	r2, [sp, #12]
 8003128:	3302      	adds	r3, #2
 800312a:	009b      	lsls	r3, r3, #2
 800312c:	4413      	add	r3, r2
 800312e:	685b      	ldr	r3, [r3, #4]
 8003130:	2b00      	cmp	r3, #0
 8003132:	d002      	beq.n	800313a <usbInitEndpointI+0x4a>
 8003134:	4814      	ldr	r0, [pc, #80]	; (8003188 <usbInitEndpointI+0x98>)
 8003136:	f003 f8fb 	bl	8006330 <chSysHalt>

  /* Logically enabling the endpoint in the USBDriver structure.*/
  usbp->epc[ep] = epcp;
 800313a:	f89d 300b 	ldrb.w	r3, [sp, #11]
 800313e:	9a03      	ldr	r2, [sp, #12]
 8003140:	3302      	adds	r3, #2
 8003142:	009b      	lsls	r3, r3, #2
 8003144:	4413      	add	r3, r2
 8003146:	9a01      	ldr	r2, [sp, #4]
 8003148:	605a      	str	r2, [r3, #4]

  /* Clearing the state structures, custom fields as well.*/
  if (epcp->in_state != NULL) {
 800314a:	9b01      	ldr	r3, [sp, #4]
 800314c:	695b      	ldr	r3, [r3, #20]
 800314e:	2b00      	cmp	r3, #0
 8003150:	d006      	beq.n	8003160 <usbInitEndpointI+0x70>
    memset(epcp->in_state, 0, sizeof(USBInEndpointState));
 8003152:	9b01      	ldr	r3, [sp, #4]
 8003154:	695b      	ldr	r3, [r3, #20]
 8003156:	2210      	movs	r2, #16
 8003158:	2100      	movs	r1, #0
 800315a:	4618      	mov	r0, r3
 800315c:	f005 f994 	bl	8008488 <memset>
  }
  if (epcp->out_state != NULL) {
 8003160:	9b01      	ldr	r3, [sp, #4]
 8003162:	699b      	ldr	r3, [r3, #24]
 8003164:	2b00      	cmp	r3, #0
 8003166:	d006      	beq.n	8003176 <usbInitEndpointI+0x86>
    memset(epcp->out_state, 0, sizeof(USBOutEndpointState));
 8003168:	9b01      	ldr	r3, [sp, #4]
 800316a:	699b      	ldr	r3, [r3, #24]
 800316c:	2210      	movs	r2, #16
 800316e:	2100      	movs	r1, #0
 8003170:	4618      	mov	r0, r3
 8003172:	f005 f989 	bl	8008488 <memset>
  }

  /* Low level endpoint activation.*/
  usb_lld_init_endpoint(usbp, ep);
 8003176:	f89d 300b 	ldrb.w	r3, [sp, #11]
 800317a:	4619      	mov	r1, r3
 800317c:	9803      	ldr	r0, [sp, #12]
 800317e:	f001 ffe7 	bl	8005150 <usb_lld_init_endpoint>
}
 8003182:	b005      	add	sp, #20
 8003184:	f85d fb04 	ldr.w	pc, [sp], #4
 8003188:	08008898 	.word	0x08008898
 800318c:	00000000 	.word	0x00000000

08003190 <usbDisableEndpointsI>:
 *
 * @param[in] usbp      pointer to the @p USBDriver object
 *
 * @iclass
 */
void usbDisableEndpointsI(USBDriver *usbp) {
 8003190:	b500      	push	{lr}
 8003192:	b085      	sub	sp, #20
 8003194:	9001      	str	r0, [sp, #4]
  unsigned i;

  osalDbgCheckClassI();
 8003196:	f003 f9eb 	bl	8006570 <chDbgCheckClassI>
  osalDbgCheck(usbp != NULL);
 800319a:	9b01      	ldr	r3, [sp, #4]
 800319c:	2b00      	cmp	r3, #0
 800319e:	d102      	bne.n	80031a6 <usbDisableEndpointsI+0x16>
 80031a0:	4816      	ldr	r0, [pc, #88]	; (80031fc <usbDisableEndpointsI+0x6c>)
 80031a2:	f003 f8c5 	bl	8006330 <chSysHalt>
  osalDbgAssert(usbp->state == USB_ACTIVE, "invalid state");
 80031a6:	9b01      	ldr	r3, [sp, #4]
 80031a8:	781b      	ldrb	r3, [r3, #0]
 80031aa:	2b04      	cmp	r3, #4
 80031ac:	d002      	beq.n	80031b4 <usbDisableEndpointsI+0x24>
 80031ae:	4813      	ldr	r0, [pc, #76]	; (80031fc <usbDisableEndpointsI+0x6c>)
 80031b0:	f003 f8be 	bl	8006330 <chSysHalt>

  usbp->transmitting &= 1U;
 80031b4:	9b01      	ldr	r3, [sp, #4]
 80031b6:	891b      	ldrh	r3, [r3, #8]
 80031b8:	f003 0301 	and.w	r3, r3, #1
 80031bc:	b29a      	uxth	r2, r3
 80031be:	9b01      	ldr	r3, [sp, #4]
 80031c0:	811a      	strh	r2, [r3, #8]
  usbp->receiving    &= 1U;
 80031c2:	9b01      	ldr	r3, [sp, #4]
 80031c4:	895b      	ldrh	r3, [r3, #10]
 80031c6:	f003 0301 	and.w	r3, r3, #1
 80031ca:	b29a      	uxth	r2, r3
 80031cc:	9b01      	ldr	r3, [sp, #4]
 80031ce:	815a      	strh	r2, [r3, #10]

  for (i = 1; i <= (unsigned)USB_MAX_ENDPOINTS; i++) {
 80031d0:	2301      	movs	r3, #1
 80031d2:	9303      	str	r3, [sp, #12]
 80031d4:	e009      	b.n	80031ea <usbDisableEndpointsI+0x5a>
      if (usbp->epc[i]->out_state != NULL) {
        osalThreadResumeI(&usbp->epc[i]->out_state->thread, MSG_RESET);
      }
    }
#endif
    usbp->epc[i] = NULL;
 80031d6:	9a01      	ldr	r2, [sp, #4]
 80031d8:	9b03      	ldr	r3, [sp, #12]
 80031da:	3302      	adds	r3, #2
 80031dc:	009b      	lsls	r3, r3, #2
 80031de:	4413      	add	r3, r2
 80031e0:	2200      	movs	r2, #0
 80031e2:	605a      	str	r2, [r3, #4]
  for (i = 1; i <= (unsigned)USB_MAX_ENDPOINTS; i++) {
 80031e4:	9b03      	ldr	r3, [sp, #12]
 80031e6:	3301      	adds	r3, #1
 80031e8:	9303      	str	r3, [sp, #12]
 80031ea:	9b03      	ldr	r3, [sp, #12]
 80031ec:	2b05      	cmp	r3, #5
 80031ee:	d9f2      	bls.n	80031d6 <usbDisableEndpointsI+0x46>
  }

  /* Low level endpoints deactivation.*/
  usb_lld_disable_endpoints(usbp);
 80031f0:	9801      	ldr	r0, [sp, #4]
 80031f2:	f002 f8d5 	bl	80053a0 <usb_lld_disable_endpoints>
}
 80031f6:	b005      	add	sp, #20
 80031f8:	f85d fb04 	ldr.w	pc, [sp], #4
 80031fc:	080088ac 	.word	0x080088ac

08003200 <usbStartReceiveI>:
 *                      the packet size because the excess is discarded.
 *
 * @iclass
 */
void usbStartReceiveI(USBDriver *usbp, usbep_t ep,
                      uint8_t *buf, size_t n) {
 8003200:	b500      	push	{lr}
 8003202:	b087      	sub	sp, #28
 8003204:	9003      	str	r0, [sp, #12]
 8003206:	9201      	str	r2, [sp, #4]
 8003208:	9300      	str	r3, [sp, #0]
 800320a:	460b      	mov	r3, r1
 800320c:	f88d 300b 	strb.w	r3, [sp, #11]
  USBOutEndpointState *osp;

  osalDbgCheckClassI();
 8003210:	f003 f9ae 	bl	8006570 <chDbgCheckClassI>
  osalDbgCheck((usbp != NULL) && (ep <= (usbep_t)USB_MAX_ENDPOINTS));
 8003214:	9b03      	ldr	r3, [sp, #12]
 8003216:	2b00      	cmp	r3, #0
 8003218:	d003      	beq.n	8003222 <usbStartReceiveI+0x22>
 800321a:	f89d 300b 	ldrb.w	r3, [sp, #11]
 800321e:	2b05      	cmp	r3, #5
 8003220:	d902      	bls.n	8003228 <usbStartReceiveI+0x28>
 8003222:	481c      	ldr	r0, [pc, #112]	; (8003294 <usbStartReceiveI+0x94>)
 8003224:	f003 f884 	bl	8006330 <chSysHalt>
  osalDbgAssert(!usbGetReceiveStatusI(usbp, ep), "already receiving");
 8003228:	9b03      	ldr	r3, [sp, #12]
 800322a:	895a      	ldrh	r2, [r3, #10]
 800322c:	f89d 300b 	ldrb.w	r3, [sp, #11]
 8003230:	2101      	movs	r1, #1
 8003232:	fa01 f303 	lsl.w	r3, r1, r3
 8003236:	b29b      	uxth	r3, r3
 8003238:	4013      	ands	r3, r2
 800323a:	b29b      	uxth	r3, r3
 800323c:	2b00      	cmp	r3, #0
 800323e:	d002      	beq.n	8003246 <usbStartReceiveI+0x46>
 8003240:	4814      	ldr	r0, [pc, #80]	; (8003294 <usbStartReceiveI+0x94>)
 8003242:	f003 f875 	bl	8006330 <chSysHalt>

  /* Marking the endpoint as active.*/
  usbp->receiving |= (uint16_t)((unsigned)1U << (unsigned)ep);
 8003246:	9b03      	ldr	r3, [sp, #12]
 8003248:	895a      	ldrh	r2, [r3, #10]
 800324a:	f89d 300b 	ldrb.w	r3, [sp, #11]
 800324e:	2101      	movs	r1, #1
 8003250:	fa01 f303 	lsl.w	r3, r1, r3
 8003254:	b29b      	uxth	r3, r3
 8003256:	4313      	orrs	r3, r2
 8003258:	b29a      	uxth	r2, r3
 800325a:	9b03      	ldr	r3, [sp, #12]
 800325c:	815a      	strh	r2, [r3, #10]

  /* Setting up the transfer.*/
  /*lint -save -e661 [18.1] pclint is confused by the check on ep.*/
  osp = usbp->epc[ep]->out_state;
 800325e:	f89d 300b 	ldrb.w	r3, [sp, #11]
 8003262:	9a03      	ldr	r2, [sp, #12]
 8003264:	3302      	adds	r3, #2
 8003266:	009b      	lsls	r3, r3, #2
 8003268:	4413      	add	r3, r2
 800326a:	685b      	ldr	r3, [r3, #4]
 800326c:	699b      	ldr	r3, [r3, #24]
 800326e:	9305      	str	r3, [sp, #20]
  /*lint -restore*/
  osp->rxbuf  = buf;
 8003270:	9b05      	ldr	r3, [sp, #20]
 8003272:	9a01      	ldr	r2, [sp, #4]
 8003274:	609a      	str	r2, [r3, #8]
  osp->rxsize = n;
 8003276:	9b05      	ldr	r3, [sp, #20]
 8003278:	9a00      	ldr	r2, [sp, #0]
 800327a:	601a      	str	r2, [r3, #0]
  osp->rxcnt  = 0;
 800327c:	9b05      	ldr	r3, [sp, #20]
 800327e:	2200      	movs	r2, #0
 8003280:	605a      	str	r2, [r3, #4]
#if USB_USE_WAIT == TRUE
  osp->thread = NULL;
#endif

  /* Starting transfer.*/
  usb_lld_start_out(usbp, ep);
 8003282:	f89d 300b 	ldrb.w	r3, [sp, #11]
 8003286:	4619      	mov	r1, r3
 8003288:	9803      	ldr	r0, [sp, #12]
 800328a:	f002 f8f1 	bl	8005470 <usb_lld_start_out>
}
 800328e:	b007      	add	sp, #28
 8003290:	f85d fb04 	ldr.w	pc, [sp], #4
 8003294:	080088c4 	.word	0x080088c4
	...

080032a0 <usbStartTransmitI>:
 * @param[in] n         transaction size
 *
 * @iclass
 */
void usbStartTransmitI(USBDriver *usbp, usbep_t ep,
                       const uint8_t *buf, size_t n) {
 80032a0:	b500      	push	{lr}
 80032a2:	b087      	sub	sp, #28
 80032a4:	9003      	str	r0, [sp, #12]
 80032a6:	9201      	str	r2, [sp, #4]
 80032a8:	9300      	str	r3, [sp, #0]
 80032aa:	460b      	mov	r3, r1
 80032ac:	f88d 300b 	strb.w	r3, [sp, #11]
  USBInEndpointState *isp;

  osalDbgCheckClassI();
 80032b0:	f003 f95e 	bl	8006570 <chDbgCheckClassI>
  osalDbgCheck((usbp != NULL) && (ep <= (usbep_t)USB_MAX_ENDPOINTS));
 80032b4:	9b03      	ldr	r3, [sp, #12]
 80032b6:	2b00      	cmp	r3, #0
 80032b8:	d003      	beq.n	80032c2 <usbStartTransmitI+0x22>
 80032ba:	f89d 300b 	ldrb.w	r3, [sp, #11]
 80032be:	2b05      	cmp	r3, #5
 80032c0:	d902      	bls.n	80032c8 <usbStartTransmitI+0x28>
 80032c2:	481c      	ldr	r0, [pc, #112]	; (8003334 <usbStartTransmitI+0x94>)
 80032c4:	f003 f834 	bl	8006330 <chSysHalt>
  osalDbgAssert(!usbGetTransmitStatusI(usbp, ep), "already transmitting");
 80032c8:	9b03      	ldr	r3, [sp, #12]
 80032ca:	891a      	ldrh	r2, [r3, #8]
 80032cc:	f89d 300b 	ldrb.w	r3, [sp, #11]
 80032d0:	2101      	movs	r1, #1
 80032d2:	fa01 f303 	lsl.w	r3, r1, r3
 80032d6:	b29b      	uxth	r3, r3
 80032d8:	4013      	ands	r3, r2
 80032da:	b29b      	uxth	r3, r3
 80032dc:	2b00      	cmp	r3, #0
 80032de:	d002      	beq.n	80032e6 <usbStartTransmitI+0x46>
 80032e0:	4814      	ldr	r0, [pc, #80]	; (8003334 <usbStartTransmitI+0x94>)
 80032e2:	f003 f825 	bl	8006330 <chSysHalt>

  /* Marking the endpoint as active.*/
  usbp->transmitting |= (uint16_t)((unsigned)1U << (unsigned)ep);
 80032e6:	9b03      	ldr	r3, [sp, #12]
 80032e8:	891a      	ldrh	r2, [r3, #8]
 80032ea:	f89d 300b 	ldrb.w	r3, [sp, #11]
 80032ee:	2101      	movs	r1, #1
 80032f0:	fa01 f303 	lsl.w	r3, r1, r3
 80032f4:	b29b      	uxth	r3, r3
 80032f6:	4313      	orrs	r3, r2
 80032f8:	b29a      	uxth	r2, r3
 80032fa:	9b03      	ldr	r3, [sp, #12]
 80032fc:	811a      	strh	r2, [r3, #8]

  /* Setting up the transfer.*/
  /*lint -save -e661 [18.1] pclint is confused by the check on ep.*/
  isp = usbp->epc[ep]->in_state;
 80032fe:	f89d 300b 	ldrb.w	r3, [sp, #11]
 8003302:	9a03      	ldr	r2, [sp, #12]
 8003304:	3302      	adds	r3, #2
 8003306:	009b      	lsls	r3, r3, #2
 8003308:	4413      	add	r3, r2
 800330a:	685b      	ldr	r3, [r3, #4]
 800330c:	695b      	ldr	r3, [r3, #20]
 800330e:	9305      	str	r3, [sp, #20]
  /*lint -restore*/
  isp->txbuf  = buf;
 8003310:	9b05      	ldr	r3, [sp, #20]
 8003312:	9a01      	ldr	r2, [sp, #4]
 8003314:	609a      	str	r2, [r3, #8]
  isp->txsize = n;
 8003316:	9b05      	ldr	r3, [sp, #20]
 8003318:	9a00      	ldr	r2, [sp, #0]
 800331a:	601a      	str	r2, [r3, #0]
  isp->txcnt  = 0;
 800331c:	9b05      	ldr	r3, [sp, #20]
 800331e:	2200      	movs	r2, #0
 8003320:	605a      	str	r2, [r3, #4]
#if USB_USE_WAIT == TRUE
  isp->thread = NULL;
#endif

  /* Starting transfer.*/
  usb_lld_start_in(usbp, ep);
 8003322:	f89d 300b 	ldrb.w	r3, [sp, #11]
 8003326:	4619      	mov	r1, r3
 8003328:	9803      	ldr	r0, [sp, #12]
 800332a:	f002 f941 	bl	80055b0 <usb_lld_start_in>
}
 800332e:	b007      	add	sp, #28
 8003330:	f85d fb04 	ldr.w	pc, [sp], #4
 8003334:	080088d8 	.word	0x080088d8
	...

08003340 <_usb_reset>:
 *
 * @param[in] usbp      pointer to the @p USBDriver object
 *
 * @notapi
 */
void _usb_reset(USBDriver *usbp) {
 8003340:	b500      	push	{lr}
 8003342:	b085      	sub	sp, #20
 8003344:	9001      	str	r0, [sp, #4]
  unsigned i;

  /* State transition.*/
  usbp->state         = USB_READY;
 8003346:	9b01      	ldr	r3, [sp, #4]
 8003348:	2202      	movs	r2, #2
 800334a:	701a      	strb	r2, [r3, #0]

  /* Resetting internal state.*/
  usbp->status        = 0;
 800334c:	9b01      	ldr	r3, [sp, #4]
 800334e:	2200      	movs	r2, #0
 8003350:	f8a3 2064 	strh.w	r2, [r3, #100]	; 0x64
  usbp->address       = 0;
 8003354:	9b01      	ldr	r3, [sp, #4]
 8003356:	2200      	movs	r2, #0
 8003358:	f883 2066 	strb.w	r2, [r3, #102]	; 0x66
  usbp->configuration = 0;
 800335c:	9b01      	ldr	r3, [sp, #4]
 800335e:	2200      	movs	r2, #0
 8003360:	f883 2067 	strb.w	r2, [r3, #103]	; 0x67
  usbp->transmitting  = 0;
 8003364:	9b01      	ldr	r3, [sp, #4]
 8003366:	2200      	movs	r2, #0
 8003368:	811a      	strh	r2, [r3, #8]
  usbp->receiving     = 0;
 800336a:	9b01      	ldr	r3, [sp, #4]
 800336c:	2200      	movs	r2, #0
 800336e:	815a      	strh	r2, [r3, #10]

  /* Invalidates all endpoints into the USBDriver structure.*/
  for (i = 0; i <= (unsigned)USB_MAX_ENDPOINTS; i++) {
 8003370:	2300      	movs	r3, #0
 8003372:	9303      	str	r3, [sp, #12]
 8003374:	e009      	b.n	800338a <_usb_reset+0x4a>
        osalThreadResumeI(&usbp->epc[i]->out_state->thread, MSG_RESET);
      }
      osalSysUnlockFromISR();
    }
#endif
    usbp->epc[i] = NULL;
 8003376:	9a01      	ldr	r2, [sp, #4]
 8003378:	9b03      	ldr	r3, [sp, #12]
 800337a:	3302      	adds	r3, #2
 800337c:	009b      	lsls	r3, r3, #2
 800337e:	4413      	add	r3, r2
 8003380:	2200      	movs	r2, #0
 8003382:	605a      	str	r2, [r3, #4]
  for (i = 0; i <= (unsigned)USB_MAX_ENDPOINTS; i++) {
 8003384:	9b03      	ldr	r3, [sp, #12]
 8003386:	3301      	adds	r3, #1
 8003388:	9303      	str	r3, [sp, #12]
 800338a:	9b03      	ldr	r3, [sp, #12]
 800338c:	2b05      	cmp	r3, #5
 800338e:	d9f2      	bls.n	8003376 <_usb_reset+0x36>
  }

  /* EP0 state machine initialization.*/
  usbp->ep0state = USB_EP0_STP_WAITING;
 8003390:	9b01      	ldr	r3, [sp, #4]
 8003392:	2200      	movs	r2, #0
 8003394:	f883 204c 	strb.w	r2, [r3, #76]	; 0x4c

  /* Low level reset.*/
  usb_lld_reset(usbp);
 8003398:	9801      	ldr	r0, [sp, #4]
 800339a:	f001 fe29 	bl	8004ff0 <usb_lld_reset>

  /* Notification of reset event.*/
  _usb_isr_invoke_event_cb(usbp, USB_EVENT_RESET);
 800339e:	9b01      	ldr	r3, [sp, #4]
 80033a0:	685b      	ldr	r3, [r3, #4]
 80033a2:	681b      	ldr	r3, [r3, #0]
 80033a4:	2b00      	cmp	r3, #0
 80033a6:	d005      	beq.n	80033b4 <_usb_reset+0x74>
 80033a8:	9b01      	ldr	r3, [sp, #4]
 80033aa:	685b      	ldr	r3, [r3, #4]
 80033ac:	681b      	ldr	r3, [r3, #0]
 80033ae:	2100      	movs	r1, #0
 80033b0:	9801      	ldr	r0, [sp, #4]
 80033b2:	4798      	blx	r3
}
 80033b4:	b005      	add	sp, #20
 80033b6:	f85d fb04 	ldr.w	pc, [sp], #4
 80033ba:	bf00      	nop
 80033bc:	0000      	movs	r0, r0
	...

080033c0 <_usb_suspend>:
 *
 * @param[in] usbp      pointer to the @p USBDriver object
 *
 * @notapi
 */
void _usb_suspend(USBDriver *usbp) {
 80033c0:	b500      	push	{lr}
 80033c2:	b083      	sub	sp, #12
 80033c4:	9001      	str	r0, [sp, #4]
  /* No state change, suspend always returns to previous state. */

  /* State transition.*/
  usbp->saved_state = usbp->state;
 80033c6:	9b01      	ldr	r3, [sp, #4]
 80033c8:	781a      	ldrb	r2, [r3, #0]
 80033ca:	9b01      	ldr	r3, [sp, #4]
 80033cc:	f883 2068 	strb.w	r2, [r3, #104]	; 0x68
  usbp->state       = USB_SUSPENDED;
 80033d0:	9b01      	ldr	r3, [sp, #4]
 80033d2:	2205      	movs	r2, #5
 80033d4:	701a      	strb	r2, [r3, #0]

  /* Notification of suspend event.*/
  _usb_isr_invoke_event_cb(usbp, USB_EVENT_SUSPEND);
 80033d6:	9b01      	ldr	r3, [sp, #4]
 80033d8:	685b      	ldr	r3, [r3, #4]
 80033da:	681b      	ldr	r3, [r3, #0]
 80033dc:	2b00      	cmp	r3, #0
 80033de:	d005      	beq.n	80033ec <_usb_suspend+0x2c>
 80033e0:	9b01      	ldr	r3, [sp, #4]
 80033e2:	685b      	ldr	r3, [r3, #4]
 80033e4:	681b      	ldr	r3, [r3, #0]
 80033e6:	2104      	movs	r1, #4
 80033e8:	9801      	ldr	r0, [sp, #4]
 80033ea:	4798      	blx	r3
        osalSysUnlockFromISR();
      }
    }
  }
#endif
}
 80033ec:	b003      	add	sp, #12
 80033ee:	f85d fb04 	ldr.w	pc, [sp], #4
 80033f2:	bf00      	nop
	...

08003400 <_usb_wakeup>:
 *
 * @param[in] usbp      pointer to the @p USBDriver object
 *
 * @notapi
 */
void _usb_wakeup(USBDriver *usbp) {
 8003400:	b500      	push	{lr}
 8003402:	b083      	sub	sp, #12
 8003404:	9001      	str	r0, [sp, #4]

  /* State transition, returning to the previous state.*/
  usbp->state = usbp->saved_state;
 8003406:	9b01      	ldr	r3, [sp, #4]
 8003408:	f893 2068 	ldrb.w	r2, [r3, #104]	; 0x68
 800340c:	9b01      	ldr	r3, [sp, #4]
 800340e:	701a      	strb	r2, [r3, #0]

  /* Notification of suspend event.*/
  _usb_isr_invoke_event_cb(usbp, USB_EVENT_WAKEUP);
 8003410:	9b01      	ldr	r3, [sp, #4]
 8003412:	685b      	ldr	r3, [r3, #4]
 8003414:	681b      	ldr	r3, [r3, #0]
 8003416:	2b00      	cmp	r3, #0
 8003418:	d005      	beq.n	8003426 <_usb_wakeup+0x26>
 800341a:	9b01      	ldr	r3, [sp, #4]
 800341c:	685b      	ldr	r3, [r3, #4]
 800341e:	681b      	ldr	r3, [r3, #0]
 8003420:	2105      	movs	r1, #5
 8003422:	9801      	ldr	r0, [sp, #4]
 8003424:	4798      	blx	r3
}
 8003426:	b003      	add	sp, #12
 8003428:	f85d fb04 	ldr.w	pc, [sp], #4
 800342c:	0000      	movs	r0, r0
	...

08003430 <_usb_ep0setup>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number, always zero
 *
 * @notapi
 */
void _usb_ep0setup(USBDriver *usbp, usbep_t ep) {
 8003430:	b500      	push	{lr}
 8003432:	b085      	sub	sp, #20
 8003434:	9001      	str	r0, [sp, #4]
 8003436:	460b      	mov	r3, r1
 8003438:	f88d 3003 	strb.w	r3, [sp, #3]
  size_t max;

  /* Is the EP0 state machine in the correct state for handling setup
     packets?*/
  if (usbp->ep0state != USB_EP0_STP_WAITING) {
 800343c:	9b01      	ldr	r3, [sp, #4]
 800343e:	f893 304c 	ldrb.w	r3, [r3, #76]	; 0x4c
 8003442:	2b00      	cmp	r3, #0
 8003444:	d003      	beq.n	800344e <_usb_ep0setup+0x1e>
    /* This is unexpected could require handling with a warning event.*/
    /* TODO: handling here.*/

    /* Resetting the EP0 state machine and going ahead.*/
    usbp->ep0state = USB_EP0_STP_WAITING;
 8003446:	9b01      	ldr	r3, [sp, #4]
 8003448:	2200      	movs	r2, #0
 800344a:	f883 204c 	strb.w	r2, [r3, #76]	; 0x4c
  }

  /* Reading the setup data into the driver buffer.*/
  usbReadSetup(usbp, ep, usbp->setup);
 800344e:	9b01      	ldr	r3, [sp, #4]
 8003450:	f103 025c 	add.w	r2, r3, #92	; 0x5c
 8003454:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8003458:	4619      	mov	r1, r3
 800345a:	9801      	ldr	r0, [sp, #4]
 800345c:	f001 fff0 	bl	8005440 <usb_lld_read_setup>

  /* First verify if the application has an handler installed for this
     request.*/
  /*lint -save -e9007 [13.5] No side effects, it is intentional.*/
  if ((usbp->config->requests_hook_cb == NULL) ||
 8003460:	9b01      	ldr	r3, [sp, #4]
 8003462:	685b      	ldr	r3, [r3, #4]
 8003464:	689b      	ldr	r3, [r3, #8]
 8003466:	2b00      	cmp	r3, #0
 8003468:	d00a      	beq.n	8003480 <_usb_ep0setup+0x50>
      !(usbp->config->requests_hook_cb(usbp))) {
 800346a:	9b01      	ldr	r3, [sp, #4]
 800346c:	685b      	ldr	r3, [r3, #4]
 800346e:	689b      	ldr	r3, [r3, #8]
 8003470:	9801      	ldr	r0, [sp, #4]
 8003472:	4798      	blx	r3
 8003474:	4603      	mov	r3, r0
 8003476:	f083 0301 	eor.w	r3, r3, #1
 800347a:	b2db      	uxtb	r3, r3
  if ((usbp->config->requests_hook_cb == NULL) ||
 800347c:	2b00      	cmp	r3, #0
 800347e:	d027      	beq.n	80034d0 <_usb_ep0setup+0xa0>
  /*lint -restore*/
    /* Invoking the default handler, if this fails then stalls the
       endpoint zero as error.*/
    /*lint -save -e9007 [13.5] No side effects, it is intentional.*/
    if (((usbp->setup[0] & USB_RTYPE_TYPE_MASK) != USB_RTYPE_TYPE_STD) ||
 8003480:	9b01      	ldr	r3, [sp, #4]
 8003482:	f893 305c 	ldrb.w	r3, [r3, #92]	; 0x5c
 8003486:	f003 0360 	and.w	r3, r3, #96	; 0x60
 800348a:	2b00      	cmp	r3, #0
 800348c:	d108      	bne.n	80034a0 <_usb_ep0setup+0x70>
        !default_handler(usbp)) {
 800348e:	9801      	ldr	r0, [sp, #4]
 8003490:	f7ff fbd6 	bl	8002c40 <default_handler>
 8003494:	4603      	mov	r3, r0
 8003496:	f083 0301 	eor.w	r3, r3, #1
 800349a:	b2db      	uxtb	r3, r3
    if (((usbp->setup[0] & USB_RTYPE_TYPE_MASK) != USB_RTYPE_TYPE_STD) ||
 800349c:	2b00      	cmp	r3, #0
 800349e:	d017      	beq.n	80034d0 <_usb_ep0setup+0xa0>
    /*lint -restore*/
      /* Error response, the state machine goes into an error state, the low
         level layer will have to reset it to USB_EP0_WAITING_SETUP after
         receiving a SETUP packet.*/
      usb_lld_stall_in(usbp, 0);
 80034a0:	2100      	movs	r1, #0
 80034a2:	9801      	ldr	r0, [sp, #4]
 80034a4:	f002 f954 	bl	8005750 <usb_lld_stall_in>
      usb_lld_stall_out(usbp, 0);
 80034a8:	2100      	movs	r1, #0
 80034aa:	9801      	ldr	r0, [sp, #4]
 80034ac:	f002 f930 	bl	8005710 <usb_lld_stall_out>
      _usb_isr_invoke_event_cb(usbp, USB_EVENT_STALLED);
 80034b0:	9b01      	ldr	r3, [sp, #4]
 80034b2:	685b      	ldr	r3, [r3, #4]
 80034b4:	681b      	ldr	r3, [r3, #0]
 80034b6:	2b00      	cmp	r3, #0
 80034b8:	d005      	beq.n	80034c6 <_usb_ep0setup+0x96>
 80034ba:	9b01      	ldr	r3, [sp, #4]
 80034bc:	685b      	ldr	r3, [r3, #4]
 80034be:	681b      	ldr	r3, [r3, #0]
 80034c0:	2106      	movs	r1, #6
 80034c2:	9801      	ldr	r0, [sp, #4]
 80034c4:	4798      	blx	r3
      usbp->ep0state = USB_EP0_ERROR;
 80034c6:	9b01      	ldr	r3, [sp, #4]
 80034c8:	2206      	movs	r2, #6
 80034ca:	f883 204c 	strb.w	r2, [r3, #76]	; 0x4c
 80034ce:	e05b      	b.n	8003588 <_usb_ep0setup+0x158>
  }
#endif
  /* Transfer preparation. The request handler must have populated
     correctly the fields ep0next, ep0n and ep0endcb using the macro
     usbSetupTransfer().*/
  max = (size_t)get_hword(&usbp->setup[6]);
 80034d0:	9b01      	ldr	r3, [sp, #4]
 80034d2:	3362      	adds	r3, #98	; 0x62
 80034d4:	4618      	mov	r0, r3
 80034d6:	f7ff fb7b 	bl	8002bd0 <get_hword>
 80034da:	4603      	mov	r3, r0
 80034dc:	9303      	str	r3, [sp, #12]
  /* The transfer size cannot exceed the specified amount.*/
  if (usbp->ep0n > max) {
 80034de:	9b01      	ldr	r3, [sp, #4]
 80034e0:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 80034e2:	9a03      	ldr	r2, [sp, #12]
 80034e4:	429a      	cmp	r2, r3
 80034e6:	d202      	bcs.n	80034ee <_usb_ep0setup+0xbe>
    usbp->ep0n = max;
 80034e8:	9b01      	ldr	r3, [sp, #4]
 80034ea:	9a03      	ldr	r2, [sp, #12]
 80034ec:	655a      	str	r2, [r3, #84]	; 0x54
  }
  if ((usbp->setup[0] & USB_RTYPE_DIR_MASK) == USB_RTYPE_DIR_DEV2HOST) {
 80034ee:	9b01      	ldr	r3, [sp, #4]
 80034f0:	f893 305c 	ldrb.w	r3, [r3, #92]	; 0x5c
 80034f4:	b25b      	sxtb	r3, r3
 80034f6:	2b00      	cmp	r3, #0
 80034f8:	da23      	bge.n	8003542 <_usb_ep0setup+0x112>
    /* IN phase.*/
    if (usbp->ep0n != 0U) {
 80034fa:	9b01      	ldr	r3, [sp, #4]
 80034fc:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 80034fe:	2b00      	cmp	r3, #0
 8003500:	d010      	beq.n	8003524 <_usb_ep0setup+0xf4>
      /* Starts the transmit phase.*/
      usbp->ep0state = USB_EP0_IN_TX;
 8003502:	9b01      	ldr	r3, [sp, #4]
 8003504:	2209      	movs	r2, #9
 8003506:	f883 204c 	strb.w	r2, [r3, #76]	; 0x4c
      osalSysLockFromISR();
 800350a:	f7ff fb51 	bl	8002bb0 <osalSysLockFromISR.lto_priv.668>
      usbStartTransmitI(usbp, 0, usbp->ep0next, usbp->ep0n);
 800350e:	9b01      	ldr	r3, [sp, #4]
 8003510:	6d1a      	ldr	r2, [r3, #80]	; 0x50
 8003512:	9b01      	ldr	r3, [sp, #4]
 8003514:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8003516:	2100      	movs	r1, #0
 8003518:	9801      	ldr	r0, [sp, #4]
 800351a:	f7ff fec1 	bl	80032a0 <usbStartTransmitI>
      osalSysUnlockFromISR();
 800351e:	f7ff fb4f 	bl	8002bc0 <osalSysUnlockFromISR.lto_priv.662>
         packet.*/
      usbp->ep0state = USB_EP0_OUT_WAITING_STS;
#if (USB_EP0_STATUS_STAGE == USB_EP0_STATUS_STAGE_SW)
      osalSysLockFromISR();
      usbStartReceiveI(usbp, 0, NULL, 0);
      osalSysUnlockFromISR();
 8003522:	e031      	b.n	8003588 <_usb_ep0setup+0x158>
      usbp->ep0state = USB_EP0_OUT_WAITING_STS;
 8003524:	9b01      	ldr	r3, [sp, #4]
 8003526:	2214      	movs	r2, #20
 8003528:	f883 204c 	strb.w	r2, [r3, #76]	; 0x4c
      osalSysLockFromISR();
 800352c:	f7ff fb40 	bl	8002bb0 <osalSysLockFromISR.lto_priv.668>
      usbStartReceiveI(usbp, 0, NULL, 0);
 8003530:	2300      	movs	r3, #0
 8003532:	2200      	movs	r2, #0
 8003534:	2100      	movs	r1, #0
 8003536:	9801      	ldr	r0, [sp, #4]
 8003538:	f7ff fe62 	bl	8003200 <usbStartReceiveI>
      osalSysUnlockFromISR();
 800353c:	f7ff fb40 	bl	8002bc0 <osalSysUnlockFromISR.lto_priv.662>
 8003540:	e022      	b.n	8003588 <_usb_ep0setup+0x158>
#endif
    }
  }
  else {
    /* OUT phase.*/
    if (usbp->ep0n != 0U) {
 8003542:	9b01      	ldr	r3, [sp, #4]
 8003544:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8003546:	2b00      	cmp	r3, #0
 8003548:	d010      	beq.n	800356c <_usb_ep0setup+0x13c>
      /* Starts the receive phase.*/
      usbp->ep0state = USB_EP0_OUT_RX;
 800354a:	9b01      	ldr	r3, [sp, #4]
 800354c:	2215      	movs	r2, #21
 800354e:	f883 204c 	strb.w	r2, [r3, #76]	; 0x4c
      osalSysLockFromISR();
 8003552:	f7ff fb2d 	bl	8002bb0 <osalSysLockFromISR.lto_priv.668>
      usbStartReceiveI(usbp, 0, (uint8_t *)usbp->ep0next, usbp->ep0n);
 8003556:	9b01      	ldr	r3, [sp, #4]
 8003558:	6d1a      	ldr	r2, [r3, #80]	; 0x50
 800355a:	9b01      	ldr	r3, [sp, #4]
 800355c:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 800355e:	2100      	movs	r1, #0
 8003560:	9801      	ldr	r0, [sp, #4]
 8003562:	f7ff fe4d 	bl	8003200 <usbStartReceiveI>
      osalSysUnlockFromISR();
 8003566:	f7ff fb2b 	bl	8002bc0 <osalSysUnlockFromISR.lto_priv.662>
 800356a:	e00d      	b.n	8003588 <_usb_ep0setup+0x158>
    }
    else {
      /* No receive phase, directly sending the zero sized status
         packet.*/
      usbp->ep0state = USB_EP0_IN_SENDING_STS;
 800356c:	9b01      	ldr	r3, [sp, #4]
 800356e:	220b      	movs	r2, #11
 8003570:	f883 204c 	strb.w	r2, [r3, #76]	; 0x4c
#if (USB_EP0_STATUS_STAGE == USB_EP0_STATUS_STAGE_SW)
      osalSysLockFromISR();
 8003574:	f7ff fb1c 	bl	8002bb0 <osalSysLockFromISR.lto_priv.668>
      usbStartTransmitI(usbp, 0, NULL, 0);
 8003578:	2300      	movs	r3, #0
 800357a:	2200      	movs	r2, #0
 800357c:	2100      	movs	r1, #0
 800357e:	9801      	ldr	r0, [sp, #4]
 8003580:	f7ff fe8e 	bl	80032a0 <usbStartTransmitI>
      osalSysUnlockFromISR();
 8003584:	f7ff fb1c 	bl	8002bc0 <osalSysUnlockFromISR.lto_priv.662>
#else
      usb_lld_end_setup(usbp, ep);
#endif
    }
  }
}
 8003588:	b005      	add	sp, #20
 800358a:	f85d fb04 	ldr.w	pc, [sp], #4
 800358e:	bf00      	nop

08003590 <_usb_ep0in>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number, always zero
 *
 * @notapi
 */
void _usb_ep0in(USBDriver *usbp, usbep_t ep) {
 8003590:	b500      	push	{lr}
 8003592:	b085      	sub	sp, #20
 8003594:	9001      	str	r0, [sp, #4]
 8003596:	460b      	mov	r3, r1
 8003598:	f88d 3003 	strb.w	r3, [sp, #3]
  size_t max;

  (void)ep;
  switch (usbp->ep0state) {
 800359c:	9b01      	ldr	r3, [sp, #4]
 800359e:	f893 304c 	ldrb.w	r3, [r3, #76]	; 0x4c
 80035a2:	2b15      	cmp	r3, #21
 80035a4:	f200 808e 	bhi.w	80036c4 <_usb_ep0in+0x134>
 80035a8:	a201      	add	r2, pc, #4	; (adr r2, 80035b0 <_usb_ep0in+0x20>)
 80035aa:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 80035ae:	bf00      	nop
 80035b0:	0800368f 	.word	0x0800368f
 80035b4:	080036c5 	.word	0x080036c5
 80035b8:	080036c5 	.word	0x080036c5
 80035bc:	080036c5 	.word	0x080036c5
 80035c0:	080036c5 	.word	0x080036c5
 80035c4:	080036c5 	.word	0x080036c5
 80035c8:	08003695 	.word	0x08003695
 80035cc:	080036c5 	.word	0x080036c5
 80035d0:	080036c5 	.word	0x080036c5
 80035d4:	08003609 	.word	0x08003609
 80035d8:	08003657 	.word	0x08003657
 80035dc:	08003675 	.word	0x08003675
 80035e0:	080036c5 	.word	0x080036c5
 80035e4:	080036c5 	.word	0x080036c5
 80035e8:	080036c5 	.word	0x080036c5
 80035ec:	080036c5 	.word	0x080036c5
 80035f0:	080036c5 	.word	0x080036c5
 80035f4:	080036c5 	.word	0x080036c5
 80035f8:	080036c5 	.word	0x080036c5
 80035fc:	080036c5 	.word	0x080036c5
 8003600:	0800368f 	.word	0x0800368f
 8003604:	0800368f 	.word	0x0800368f
  case USB_EP0_IN_TX:
    max = (size_t)get_hword(&usbp->setup[6]);
 8003608:	9b01      	ldr	r3, [sp, #4]
 800360a:	3362      	adds	r3, #98	; 0x62
 800360c:	4618      	mov	r0, r3
 800360e:	f7ff fadf 	bl	8002bd0 <get_hword>
 8003612:	4603      	mov	r3, r0
 8003614:	9303      	str	r3, [sp, #12]
    /* If the transmitted size is less than the requested size and it is a
       multiple of the maximum packet size then a zero size packet must be
       transmitted.*/
    if ((usbp->ep0n < max) &&
 8003616:	9b01      	ldr	r3, [sp, #4]
 8003618:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 800361a:	9a03      	ldr	r2, [sp, #12]
 800361c:	429a      	cmp	r2, r3
 800361e:	d91a      	bls.n	8003656 <_usb_ep0in+0xc6>
        ((usbp->ep0n % usbp->epc[0]->in_maxsize) == 0U)) {
 8003620:	9b01      	ldr	r3, [sp, #4]
 8003622:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8003624:	9a01      	ldr	r2, [sp, #4]
 8003626:	68d2      	ldr	r2, [r2, #12]
 8003628:	8a12      	ldrh	r2, [r2, #16]
 800362a:	fbb3 f1f2 	udiv	r1, r3, r2
 800362e:	fb02 f201 	mul.w	r2, r2, r1
 8003632:	1a9b      	subs	r3, r3, r2
    if ((usbp->ep0n < max) &&
 8003634:	2b00      	cmp	r3, #0
 8003636:	d10e      	bne.n	8003656 <_usb_ep0in+0xc6>
      osalSysLockFromISR();
 8003638:	f7ff faba 	bl	8002bb0 <osalSysLockFromISR.lto_priv.668>
      usbStartTransmitI(usbp, 0, NULL, 0);
 800363c:	2300      	movs	r3, #0
 800363e:	2200      	movs	r2, #0
 8003640:	2100      	movs	r1, #0
 8003642:	9801      	ldr	r0, [sp, #4]
 8003644:	f7ff fe2c 	bl	80032a0 <usbStartTransmitI>
      osalSysUnlockFromISR();
 8003648:	f7ff faba 	bl	8002bc0 <osalSysUnlockFromISR.lto_priv.662>
      usbp->ep0state = USB_EP0_IN_WAITING_TX0;
 800364c:	9b01      	ldr	r3, [sp, #4]
 800364e:	220a      	movs	r2, #10
 8003650:	f883 204c 	strb.w	r2, [r3, #76]	; 0x4c
 8003654:	e039      	b.n	80036ca <_usb_ep0in+0x13a>
      return;
    }
    /* Falls through.*/
  case USB_EP0_IN_WAITING_TX0:
    /* Transmit phase over, receiving the zero sized status packet.*/
    usbp->ep0state = USB_EP0_OUT_WAITING_STS;
 8003656:	9b01      	ldr	r3, [sp, #4]
 8003658:	2214      	movs	r2, #20
 800365a:	f883 204c 	strb.w	r2, [r3, #76]	; 0x4c
#if (USB_EP0_STATUS_STAGE == USB_EP0_STATUS_STAGE_SW)
    osalSysLockFromISR();
 800365e:	f7ff faa7 	bl	8002bb0 <osalSysLockFromISR.lto_priv.668>
    usbStartReceiveI(usbp, 0, NULL, 0);
 8003662:	2300      	movs	r3, #0
 8003664:	2200      	movs	r2, #0
 8003666:	2100      	movs	r1, #0
 8003668:	9801      	ldr	r0, [sp, #4]
 800366a:	f7ff fdc9 	bl	8003200 <usbStartReceiveI>
    osalSysUnlockFromISR();
 800366e:	f7ff faa7 	bl	8002bc0 <osalSysUnlockFromISR.lto_priv.662>
 8003672:	e02a      	b.n	80036ca <_usb_ep0in+0x13a>
    usb_lld_end_setup(usbp, ep);
#endif
    return;
  case USB_EP0_IN_SENDING_STS:
    /* Status packet sent, invoking the callback if defined.*/
    if (usbp->ep0endcb != NULL) {
 8003674:	9b01      	ldr	r3, [sp, #4]
 8003676:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 8003678:	2b00      	cmp	r3, #0
 800367a:	d003      	beq.n	8003684 <_usb_ep0in+0xf4>
      usbp->ep0endcb(usbp);
 800367c:	9b01      	ldr	r3, [sp, #4]
 800367e:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 8003680:	9801      	ldr	r0, [sp, #4]
 8003682:	4798      	blx	r3
    }
    usbp->ep0state = USB_EP0_STP_WAITING;
 8003684:	9b01      	ldr	r3, [sp, #4]
 8003686:	2200      	movs	r2, #0
 8003688:	f883 204c 	strb.w	r2, [r3, #76]	; 0x4c
 800368c:	e01d      	b.n	80036ca <_usb_ep0in+0x13a>
    return;
  case USB_EP0_STP_WAITING:
  case USB_EP0_OUT_WAITING_STS:
  case USB_EP0_OUT_RX:
    /* All the above are invalid states in the IN phase.*/
    osalDbgAssert(false, "EP0 state machine error");
 800368e:	4810      	ldr	r0, [pc, #64]	; (80036d0 <_usb_ep0in+0x140>)
 8003690:	f002 fe4e 	bl	8006330 <chSysHalt>
    /* Falls through.*/
  case USB_EP0_ERROR:
    /* Error response, the state machine goes into an error state, the low
       level layer will have to reset it to USB_EP0_WAITING_SETUP after
       receiving a SETUP packet.*/
    usb_lld_stall_in(usbp, 0);
 8003694:	2100      	movs	r1, #0
 8003696:	9801      	ldr	r0, [sp, #4]
 8003698:	f002 f85a 	bl	8005750 <usb_lld_stall_in>
    usb_lld_stall_out(usbp, 0);
 800369c:	2100      	movs	r1, #0
 800369e:	9801      	ldr	r0, [sp, #4]
 80036a0:	f002 f836 	bl	8005710 <usb_lld_stall_out>
    _usb_isr_invoke_event_cb(usbp, USB_EVENT_STALLED);
 80036a4:	9b01      	ldr	r3, [sp, #4]
 80036a6:	685b      	ldr	r3, [r3, #4]
 80036a8:	681b      	ldr	r3, [r3, #0]
 80036aa:	2b00      	cmp	r3, #0
 80036ac:	d005      	beq.n	80036ba <_usb_ep0in+0x12a>
 80036ae:	9b01      	ldr	r3, [sp, #4]
 80036b0:	685b      	ldr	r3, [r3, #4]
 80036b2:	681b      	ldr	r3, [r3, #0]
 80036b4:	2106      	movs	r1, #6
 80036b6:	9801      	ldr	r0, [sp, #4]
 80036b8:	4798      	blx	r3
    usbp->ep0state = USB_EP0_ERROR;
 80036ba:	9b01      	ldr	r3, [sp, #4]
 80036bc:	2206      	movs	r2, #6
 80036be:	f883 204c 	strb.w	r2, [r3, #76]	; 0x4c
 80036c2:	e002      	b.n	80036ca <_usb_ep0in+0x13a>
    return;
  default:
    osalDbgAssert(false, "EP0 state machine invalid state");
 80036c4:	4802      	ldr	r0, [pc, #8]	; (80036d0 <_usb_ep0in+0x140>)
 80036c6:	f002 fe33 	bl	8006330 <chSysHalt>
  }
}
 80036ca:	b005      	add	sp, #20
 80036cc:	f85d fb04 	ldr.w	pc, [sp], #4
 80036d0:	080088ec 	.word	0x080088ec
	...

080036e0 <_usb_ep0out>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number, always zero
 *
 * @notapi
 */
void _usb_ep0out(USBDriver *usbp, usbep_t ep) {
 80036e0:	b500      	push	{lr}
 80036e2:	b083      	sub	sp, #12
 80036e4:	9001      	str	r0, [sp, #4]
 80036e6:	460b      	mov	r3, r1
 80036e8:	f88d 3003 	strb.w	r3, [sp, #3]

  (void)ep;
  switch (usbp->ep0state) {
 80036ec:	9b01      	ldr	r3, [sp, #4]
 80036ee:	f893 304c 	ldrb.w	r3, [r3, #76]	; 0x4c
 80036f2:	2b15      	cmp	r3, #21
 80036f4:	d86b      	bhi.n	80037ce <_usb_ep0out+0xee>
 80036f6:	a201      	add	r2, pc, #4	; (adr r2, 80036fc <_usb_ep0out+0x1c>)
 80036f8:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 80036fc:	08003799 	.word	0x08003799
 8003700:	080037cf 	.word	0x080037cf
 8003704:	080037cf 	.word	0x080037cf
 8003708:	080037cf 	.word	0x080037cf
 800370c:	080037cf 	.word	0x080037cf
 8003710:	080037cf 	.word	0x080037cf
 8003714:	0800379f 	.word	0x0800379f
 8003718:	080037cf 	.word	0x080037cf
 800371c:	080037cf 	.word	0x080037cf
 8003720:	08003799 	.word	0x08003799
 8003724:	08003799 	.word	0x08003799
 8003728:	08003799 	.word	0x08003799
 800372c:	080037cf 	.word	0x080037cf
 8003730:	080037cf 	.word	0x080037cf
 8003734:	080037cf 	.word	0x080037cf
 8003738:	080037cf 	.word	0x080037cf
 800373c:	080037cf 	.word	0x080037cf
 8003740:	080037cf 	.word	0x080037cf
 8003744:	080037cf 	.word	0x080037cf
 8003748:	080037cf 	.word	0x080037cf
 800374c:	08003773 	.word	0x08003773
 8003750:	08003755 	.word	0x08003755
  case USB_EP0_OUT_RX:
    /* Receive phase over, sending the zero sized status packet.*/
    usbp->ep0state = USB_EP0_IN_SENDING_STS;
 8003754:	9b01      	ldr	r3, [sp, #4]
 8003756:	220b      	movs	r2, #11
 8003758:	f883 204c 	strb.w	r2, [r3, #76]	; 0x4c
#if (USB_EP0_STATUS_STAGE == USB_EP0_STATUS_STAGE_SW)
    osalSysLockFromISR();
 800375c:	f7ff fa28 	bl	8002bb0 <osalSysLockFromISR.lto_priv.668>
    usbStartTransmitI(usbp, 0, NULL, 0);
 8003760:	2300      	movs	r3, #0
 8003762:	2200      	movs	r2, #0
 8003764:	2100      	movs	r1, #0
 8003766:	9801      	ldr	r0, [sp, #4]
 8003768:	f7ff fd9a 	bl	80032a0 <usbStartTransmitI>
    osalSysUnlockFromISR();
 800376c:	f7ff fa28 	bl	8002bc0 <osalSysUnlockFromISR.lto_priv.662>
 8003770:	e030      	b.n	80037d4 <_usb_ep0out+0xf4>
    return;
  case USB_EP0_OUT_WAITING_STS:
    /* Status packet received, it must be zero sized, invoking the callback
       if defined.*/
#if (USB_EP0_STATUS_STAGE == USB_EP0_STATUS_STAGE_SW)
    if (usbGetReceiveTransactionSizeX(usbp, 0) != 0U) {
 8003772:	9b01      	ldr	r3, [sp, #4]
 8003774:	68db      	ldr	r3, [r3, #12]
 8003776:	699b      	ldr	r3, [r3, #24]
 8003778:	685b      	ldr	r3, [r3, #4]
 800377a:	2b00      	cmp	r3, #0
 800377c:	d12a      	bne.n	80037d4 <_usb_ep0out+0xf4>
      break;
    }
#endif
    if (usbp->ep0endcb != NULL) {
 800377e:	9b01      	ldr	r3, [sp, #4]
 8003780:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 8003782:	2b00      	cmp	r3, #0
 8003784:	d003      	beq.n	800378e <_usb_ep0out+0xae>
      usbp->ep0endcb(usbp);
 8003786:	9b01      	ldr	r3, [sp, #4]
 8003788:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 800378a:	9801      	ldr	r0, [sp, #4]
 800378c:	4798      	blx	r3
    }
    usbp->ep0state = USB_EP0_STP_WAITING;
 800378e:	9b01      	ldr	r3, [sp, #4]
 8003790:	2200      	movs	r2, #0
 8003792:	f883 204c 	strb.w	r2, [r3, #76]	; 0x4c
 8003796:	e01d      	b.n	80037d4 <_usb_ep0out+0xf4>
  case USB_EP0_STP_WAITING:
  case USB_EP0_IN_TX:
  case USB_EP0_IN_WAITING_TX0:
  case USB_EP0_IN_SENDING_STS:
    /* All the above are invalid states in the IN phase.*/
    osalDbgAssert(false, "EP0 state machine error");
 8003798:	4810      	ldr	r0, [pc, #64]	; (80037dc <_usb_ep0out+0xfc>)
 800379a:	f002 fdc9 	bl	8006330 <chSysHalt>
    /* Falls through.*/
  case USB_EP0_ERROR:
    /* Error response, the state machine goes into an error state, the low
       level layer will have to reset it to USB_EP0_WAITING_SETUP after
       receiving a SETUP packet.*/
    usb_lld_stall_in(usbp, 0);
 800379e:	2100      	movs	r1, #0
 80037a0:	9801      	ldr	r0, [sp, #4]
 80037a2:	f001 ffd5 	bl	8005750 <usb_lld_stall_in>
    usb_lld_stall_out(usbp, 0);
 80037a6:	2100      	movs	r1, #0
 80037a8:	9801      	ldr	r0, [sp, #4]
 80037aa:	f001 ffb1 	bl	8005710 <usb_lld_stall_out>
    _usb_isr_invoke_event_cb(usbp, USB_EVENT_STALLED);
 80037ae:	9b01      	ldr	r3, [sp, #4]
 80037b0:	685b      	ldr	r3, [r3, #4]
 80037b2:	681b      	ldr	r3, [r3, #0]
 80037b4:	2b00      	cmp	r3, #0
 80037b6:	d005      	beq.n	80037c4 <_usb_ep0out+0xe4>
 80037b8:	9b01      	ldr	r3, [sp, #4]
 80037ba:	685b      	ldr	r3, [r3, #4]
 80037bc:	681b      	ldr	r3, [r3, #0]
 80037be:	2106      	movs	r1, #6
 80037c0:	9801      	ldr	r0, [sp, #4]
 80037c2:	4798      	blx	r3
    usbp->ep0state = USB_EP0_ERROR;
 80037c4:	9b01      	ldr	r3, [sp, #4]
 80037c6:	2206      	movs	r2, #6
 80037c8:	f883 204c 	strb.w	r2, [r3, #76]	; 0x4c
 80037cc:	e002      	b.n	80037d4 <_usb_ep0out+0xf4>
    return;
  default:
    osalDbgAssert(false, "EP0 state machine invalid state");
 80037ce:	4803      	ldr	r0, [pc, #12]	; (80037dc <_usb_ep0out+0xfc>)
 80037d0:	f002 fdae 	bl	8006330 <chSysHalt>
  }
}
 80037d4:	b003      	add	sp, #12
 80037d6:	f85d fb04 	ldr.w	pc, [sp], #4
 80037da:	bf00      	nop
 80037dc:	080088f8 	.word	0x080088f8

080037e0 <nvicEnableVector>:
 * @brief   Sets the priority of an interrupt handler and enables it.
 *
 * @param[in] n         the interrupt number
 * @param[in] prio      the interrupt priority
 */
void nvicEnableVector(uint32_t n, uint32_t prio) {
 80037e0:	b082      	sub	sp, #8
 80037e2:	9001      	str	r0, [sp, #4]
 80037e4:	9100      	str	r1, [sp, #0]

#if defined(__CORE_CM0_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = (NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
                         (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 80037e6:	9b00      	ldr	r3, [sp, #0]
 80037e8:	b2db      	uxtb	r3, r3
 80037ea:	4a11      	ldr	r2, [pc, #68]	; (8003830 <nvicEnableVector+0x50>)
 80037ec:	011b      	lsls	r3, r3, #4
 80037ee:	b2d9      	uxtb	r1, r3
 80037f0:	9b01      	ldr	r3, [sp, #4]
 80037f2:	4413      	add	r3, r2
 80037f4:	f503 7340 	add.w	r3, r3, #768	; 0x300
 80037f8:	460a      	mov	r2, r1
 80037fa:	701a      	strb	r2, [r3, #0]
#endif
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 80037fc:	9b01      	ldr	r3, [sp, #4]
 80037fe:	f003 021f 	and.w	r2, r3, #31
 8003802:	490b      	ldr	r1, [pc, #44]	; (8003830 <nvicEnableVector+0x50>)
 8003804:	9b01      	ldr	r3, [sp, #4]
 8003806:	095b      	lsrs	r3, r3, #5
 8003808:	2001      	movs	r0, #1
 800380a:	fa00 f202 	lsl.w	r2, r0, r2
 800380e:	3360      	adds	r3, #96	; 0x60
 8003810:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
 8003814:	9b01      	ldr	r3, [sp, #4]
 8003816:	f003 021f 	and.w	r2, r3, #31
 800381a:	4905      	ldr	r1, [pc, #20]	; (8003830 <nvicEnableVector+0x50>)
 800381c:	9b01      	ldr	r3, [sp, #4]
 800381e:	095b      	lsrs	r3, r3, #5
 8003820:	2001      	movs	r0, #1
 8003822:	fa00 f202 	lsl.w	r2, r0, r2
 8003826:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
 800382a:	b002      	add	sp, #8
 800382c:	4770      	bx	lr
 800382e:	bf00      	nop
 8003830:	e000e100 	.word	0xe000e100
	...

08003840 <irqInit>:
/**
 * @brief   Enables IRQ sources.
 *
 * @notapi
 */
void irqInit(void) {
 8003840:	b508      	push	{r3, lr}

#if HAL_USE_PAL
  nvicEnableVector(EXTI0_IRQn, STM32_IRQ_EXTI0_PRIORITY);
 8003842:	2106      	movs	r1, #6
 8003844:	2006      	movs	r0, #6
 8003846:	f7ff ffcb 	bl	80037e0 <nvicEnableVector>
  nvicEnableVector(EXTI1_IRQn, STM32_IRQ_EXTI1_PRIORITY);
 800384a:	2106      	movs	r1, #6
 800384c:	2007      	movs	r0, #7
 800384e:	f7ff ffc7 	bl	80037e0 <nvicEnableVector>
  nvicEnableVector(EXTI2_IRQn, STM32_IRQ_EXTI2_PRIORITY);
 8003852:	2106      	movs	r1, #6
 8003854:	2008      	movs	r0, #8
 8003856:	f7ff ffc3 	bl	80037e0 <nvicEnableVector>
  nvicEnableVector(EXTI3_IRQn, STM32_IRQ_EXTI3_PRIORITY);
 800385a:	2106      	movs	r1, #6
 800385c:	2009      	movs	r0, #9
 800385e:	f7ff ffbf 	bl	80037e0 <nvicEnableVector>
  nvicEnableVector(EXTI4_IRQn, STM32_IRQ_EXTI4_PRIORITY);
 8003862:	2106      	movs	r1, #6
 8003864:	200a      	movs	r0, #10
 8003866:	f7ff ffbb 	bl	80037e0 <nvicEnableVector>
  nvicEnableVector(EXTI9_5_IRQn, STM32_IRQ_EXTI5_9_PRIORITY);
 800386a:	2106      	movs	r1, #6
 800386c:	2017      	movs	r0, #23
 800386e:	f7ff ffb7 	bl	80037e0 <nvicEnableVector>
  nvicEnableVector(EXTI15_10_IRQn, STM32_IRQ_EXTI10_15_PRIORITY);
 8003872:	2106      	movs	r1, #6
 8003874:	2028      	movs	r0, #40	; 0x28
 8003876:	f7ff ffb3 	bl	80037e0 <nvicEnableVector>
#endif
}
 800387a:	bd08      	pop	{r3, pc}
 800387c:	0000      	movs	r0, r0
	...

08003880 <hal_lld_backup_domain_init>:
 *          of the whole BKP domain.
 */
static void hal_lld_backup_domain_init(void) {

  /* Backup domain access enabled and left open.*/
  PWR->CR |= PWR_CR_DBP;
 8003880:	4b0d      	ldr	r3, [pc, #52]	; (80038b8 <hal_lld_backup_domain_init+0x38>)
 8003882:	681b      	ldr	r3, [r3, #0]
 8003884:	4a0c      	ldr	r2, [pc, #48]	; (80038b8 <hal_lld_backup_domain_init+0x38>)
 8003886:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 800388a:	6013      	str	r3, [r2, #0]

  /* Reset BKP domain if different clock source selected.*/
  if ((RCC->BDCR & STM32_RTCSEL_MASK) != STM32_RTCSEL) {
 800388c:	4b0b      	ldr	r3, [pc, #44]	; (80038bc <hal_lld_backup_domain_init+0x3c>)
 800388e:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 8003890:	f403 7340 	and.w	r3, r3, #768	; 0x300
 8003894:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 8003898:	d006      	beq.n	80038a8 <hal_lld_backup_domain_init+0x28>
    /* Backup domain reset.*/
    RCC->BDCR = RCC_BDCR_BDRST;
 800389a:	4b08      	ldr	r3, [pc, #32]	; (80038bc <hal_lld_backup_domain_init+0x3c>)
 800389c:	f44f 3280 	mov.w	r2, #65536	; 0x10000
 80038a0:	671a      	str	r2, [r3, #112]	; 0x70
    RCC->BDCR = 0;
 80038a2:	4b06      	ldr	r3, [pc, #24]	; (80038bc <hal_lld_backup_domain_init+0x3c>)
 80038a4:	2200      	movs	r2, #0
 80038a6:	671a      	str	r2, [r3, #112]	; 0x70

  PWR->CSR |= PWR_CSR_BRE;
  while ((PWR->CSR & PWR_CSR_BRR) == 0)
    ;                                /* Waits until the regulator is stable */
#else
  PWR->CSR &= ~PWR_CSR_BRE;
 80038a8:	4b03      	ldr	r3, [pc, #12]	; (80038b8 <hal_lld_backup_domain_init+0x38>)
 80038aa:	685b      	ldr	r3, [r3, #4]
 80038ac:	4a02      	ldr	r2, [pc, #8]	; (80038b8 <hal_lld_backup_domain_init+0x38>)
 80038ae:	f423 7300 	bic.w	r3, r3, #512	; 0x200
 80038b2:	6053      	str	r3, [r2, #4]
#endif /* STM32_BKPRAM_ENABLE */
}
 80038b4:	4770      	bx	lr
 80038b6:	bf00      	nop
 80038b8:	40007000 	.word	0x40007000
 80038bc:	40023800 	.word	0x40023800

080038c0 <hal_lld_init>:
/**
 * @brief   Low level HAL driver initialization.
 *
 * @notapi
 */
void hal_lld_init(void) {
 80038c0:	b508      	push	{r3, lr}

  /* Reset of all peripherals. AHB3 is not reseted because it could have
     been initialized in the board initialization file (board.c).
     Note, GPIOs are not reset because initialized before this point in
     board files.*/
  rccResetAHB1(~STM32_GPIO_EN_MASK);
 80038c2:	4b26      	ldr	r3, [pc, #152]	; (800395c <hal_lld_init+0x9c>)
 80038c4:	691b      	ldr	r3, [r3, #16]
 80038c6:	4a25      	ldr	r2, [pc, #148]	; (800395c <hal_lld_init+0x9c>)
 80038c8:	ea6f 53c3 	mvn.w	r3, r3, lsl #23
 80038cc:	ea6f 53d3 	mvn.w	r3, r3, lsr #23
 80038d0:	6113      	str	r3, [r2, #16]
 80038d2:	4b22      	ldr	r3, [pc, #136]	; (800395c <hal_lld_init+0x9c>)
 80038d4:	691b      	ldr	r3, [r3, #16]
 80038d6:	4a21      	ldr	r2, [pc, #132]	; (800395c <hal_lld_init+0x9c>)
 80038d8:	f3c3 0308 	ubfx	r3, r3, #0, #9
 80038dc:	6113      	str	r3, [r2, #16]
 80038de:	4b1f      	ldr	r3, [pc, #124]	; (800395c <hal_lld_init+0x9c>)
 80038e0:	691b      	ldr	r3, [r3, #16]
#if !defined(STM32F410xx)
  rccResetAHB2(~0);
 80038e2:	4b1e      	ldr	r3, [pc, #120]	; (800395c <hal_lld_init+0x9c>)
 80038e4:	695b      	ldr	r3, [r3, #20]
 80038e6:	4b1d      	ldr	r3, [pc, #116]	; (800395c <hal_lld_init+0x9c>)
 80038e8:	f04f 32ff 	mov.w	r2, #4294967295
 80038ec:	615a      	str	r2, [r3, #20]
 80038ee:	4b1b      	ldr	r3, [pc, #108]	; (800395c <hal_lld_init+0x9c>)
 80038f0:	695b      	ldr	r3, [r3, #20]
 80038f2:	4b1a      	ldr	r3, [pc, #104]	; (800395c <hal_lld_init+0x9c>)
 80038f4:	2200      	movs	r2, #0
 80038f6:	615a      	str	r2, [r3, #20]
 80038f8:	4b18      	ldr	r3, [pc, #96]	; (800395c <hal_lld_init+0x9c>)
 80038fa:	695b      	ldr	r3, [r3, #20]
#endif
  rccResetAPB1(~RCC_APB1RSTR_PWRRST);
 80038fc:	4b17      	ldr	r3, [pc, #92]	; (800395c <hal_lld_init+0x9c>)
 80038fe:	6a1b      	ldr	r3, [r3, #32]
 8003900:	4a16      	ldr	r2, [pc, #88]	; (800395c <hal_lld_init+0x9c>)
 8003902:	f063 5380 	orn	r3, r3, #268435456	; 0x10000000
 8003906:	6213      	str	r3, [r2, #32]
 8003908:	4b14      	ldr	r3, [pc, #80]	; (800395c <hal_lld_init+0x9c>)
 800390a:	6a1b      	ldr	r3, [r3, #32]
 800390c:	4a13      	ldr	r2, [pc, #76]	; (800395c <hal_lld_init+0x9c>)
 800390e:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 8003912:	6213      	str	r3, [r2, #32]
 8003914:	4b11      	ldr	r3, [pc, #68]	; (800395c <hal_lld_init+0x9c>)
 8003916:	6a1b      	ldr	r3, [r3, #32]
  rccResetAPB2(~0);
 8003918:	4b10      	ldr	r3, [pc, #64]	; (800395c <hal_lld_init+0x9c>)
 800391a:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800391c:	4b0f      	ldr	r3, [pc, #60]	; (800395c <hal_lld_init+0x9c>)
 800391e:	f04f 32ff 	mov.w	r2, #4294967295
 8003922:	625a      	str	r2, [r3, #36]	; 0x24
 8003924:	4b0d      	ldr	r3, [pc, #52]	; (800395c <hal_lld_init+0x9c>)
 8003926:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8003928:	4b0c      	ldr	r3, [pc, #48]	; (800395c <hal_lld_init+0x9c>)
 800392a:	2200      	movs	r2, #0
 800392c:	625a      	str	r2, [r3, #36]	; 0x24
 800392e:	4b0b      	ldr	r3, [pc, #44]	; (800395c <hal_lld_init+0x9c>)
 8003930:	6a5b      	ldr	r3, [r3, #36]	; 0x24

  /* PWR clock enabled.*/
  rccEnablePWRInterface(true);
 8003932:	4b0a      	ldr	r3, [pc, #40]	; (800395c <hal_lld_init+0x9c>)
 8003934:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8003936:	4a09      	ldr	r2, [pc, #36]	; (800395c <hal_lld_init+0x9c>)
 8003938:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 800393c:	6413      	str	r3, [r2, #64]	; 0x40
 800393e:	4b07      	ldr	r3, [pc, #28]	; (800395c <hal_lld_init+0x9c>)
 8003940:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 8003942:	4a06      	ldr	r2, [pc, #24]	; (800395c <hal_lld_init+0x9c>)
 8003944:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 8003948:	6613      	str	r3, [r2, #96]	; 0x60
 800394a:	4b04      	ldr	r3, [pc, #16]	; (800395c <hal_lld_init+0x9c>)
 800394c:	6e1b      	ldr	r3, [r3, #96]	; 0x60

  /* Initializes the backup domain.*/
  hal_lld_backup_domain_init();
 800394e:	f7ff ff97 	bl	8003880 <hal_lld_backup_domain_init>

  /* DMA subsystems initialization.*/
#if defined(STM32_DMA_REQUIRED)
  dmaInit();
 8003952:	f000 fba5 	bl	80040a0 <dmaInit>
#endif

  /* IRQ subsystem initialization.*/
  irqInit();
 8003956:	f7ff ff73 	bl	8003840 <irqInit>

  /* Programmable voltage detector enable.*/
#if STM32_PVD_ENABLE
  PWR->CR |= PWR_CR_PVDE | (STM32_PLS & STM32_PLS_MASK);
#endif /* STM32_PVD_ENABLE */
}
 800395a:	bd08      	pop	{r3, pc}
 800395c:	40023800 	.word	0x40023800

08003960 <stm32_clock_init>:
#if !STM32_NO_INIT
  /* PWR clock enable.*/
#if defined(HAL_USE_RTC) && defined(RCC_APB1ENR_RTCAPBEN)
  RCC->APB1ENR = RCC_APB1ENR_PWREN | RCC_APB1ENR_RTCAPBEN;
#else
  RCC->APB1ENR = RCC_APB1ENR_PWREN;
 8003960:	4b43      	ldr	r3, [pc, #268]	; (8003a70 <stm32_clock_init+0x110>)
 8003962:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8003966:	641a      	str	r2, [r3, #64]	; 0x40
#endif

  /* PWR initialization.*/
#if defined(STM32F4XX) || defined(__DOXYGEN__)
  PWR->CR = STM32_VOS;
 8003968:	4b42      	ldr	r3, [pc, #264]	; (8003a74 <stm32_clock_init+0x114>)
 800396a:	f44f 4240 	mov.w	r2, #49152	; 0xc000
 800396e:	601a      	str	r2, [r3, #0]
  PWR->CR = 0;
#endif

  /* HSI setup, it enforces the reset situation in order to handle possible
     problems with JTAG probes and re-initializations.*/
  RCC->CR |= RCC_CR_HSION;                  /* Make sure HSI is ON.         */
 8003970:	4b3f      	ldr	r3, [pc, #252]	; (8003a70 <stm32_clock_init+0x110>)
 8003972:	681b      	ldr	r3, [r3, #0]
 8003974:	4a3e      	ldr	r2, [pc, #248]	; (8003a70 <stm32_clock_init+0x110>)
 8003976:	f043 0301 	orr.w	r3, r3, #1
 800397a:	6013      	str	r3, [r2, #0]
  while (!(RCC->CR & RCC_CR_HSIRDY))
 800397c:	4b3c      	ldr	r3, [pc, #240]	; (8003a70 <stm32_clock_init+0x110>)
 800397e:	681b      	ldr	r3, [r3, #0]
 8003980:	f003 0302 	and.w	r3, r3, #2
 8003984:	2b00      	cmp	r3, #0
 8003986:	d0f9      	beq.n	800397c <stm32_clock_init+0x1c>
    ;                                       /* Wait until HSI is stable.    */

  /* HSI is selected as new source without touching the other fields in
     CFGR. Clearing the register has to be postponed after HSI is the
     new source.*/
  RCC->CFGR &= ~RCC_CFGR_SW;                /* Reset SW, selecting HSI.     */
 8003988:	4b39      	ldr	r3, [pc, #228]	; (8003a70 <stm32_clock_init+0x110>)
 800398a:	689b      	ldr	r3, [r3, #8]
 800398c:	4a38      	ldr	r2, [pc, #224]	; (8003a70 <stm32_clock_init+0x110>)
 800398e:	f023 0303 	bic.w	r3, r3, #3
 8003992:	6093      	str	r3, [r2, #8]
  while ((RCC->CFGR & RCC_CFGR_SWS) != RCC_CFGR_SWS_HSI)
 8003994:	4b36      	ldr	r3, [pc, #216]	; (8003a70 <stm32_clock_init+0x110>)
 8003996:	689b      	ldr	r3, [r3, #8]
 8003998:	f003 030c 	and.w	r3, r3, #12
 800399c:	2b00      	cmp	r3, #0
 800399e:	d1f9      	bne.n	8003994 <stm32_clock_init+0x34>
    ;                                       /* Wait until HSI is selected.  */

  /* Registers finally cleared to reset values.*/
  RCC->CR &= RCC_CR_HSITRIM | RCC_CR_HSION; /* CR Reset value.              */
 80039a0:	4b33      	ldr	r3, [pc, #204]	; (8003a70 <stm32_clock_init+0x110>)
 80039a2:	681b      	ldr	r3, [r3, #0]
 80039a4:	4a32      	ldr	r2, [pc, #200]	; (8003a70 <stm32_clock_init+0x110>)
 80039a6:	f003 03f9 	and.w	r3, r3, #249	; 0xf9
 80039aa:	6013      	str	r3, [r2, #0]
  RCC->CFGR = 0;                            /* CFGR reset value.            */
 80039ac:	4b30      	ldr	r3, [pc, #192]	; (8003a70 <stm32_clock_init+0x110>)
 80039ae:	2200      	movs	r2, #0
 80039b0:	609a      	str	r2, [r3, #8]
#if defined(STM32_HSE_BYPASS)
  /* HSE Bypass.*/
  RCC->CR |= RCC_CR_HSEON | RCC_CR_HSEBYP;
#else
  /* No HSE Bypass.*/
  RCC->CR |= RCC_CR_HSEON;
 80039b2:	4b2f      	ldr	r3, [pc, #188]	; (8003a70 <stm32_clock_init+0x110>)
 80039b4:	681b      	ldr	r3, [r3, #0]
 80039b6:	4a2e      	ldr	r2, [pc, #184]	; (8003a70 <stm32_clock_init+0x110>)
 80039b8:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 80039bc:	6013      	str	r3, [r2, #0]
#endif
  while ((RCC->CR & RCC_CR_HSERDY) == 0)
 80039be:	4b2c      	ldr	r3, [pc, #176]	; (8003a70 <stm32_clock_init+0x110>)
 80039c0:	681b      	ldr	r3, [r3, #0]
 80039c2:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 80039c6:	2b00      	cmp	r3, #0
 80039c8:	d0f9      	beq.n	80039be <stm32_clock_init+0x5e>
    ;                           /* Waits until HSE is stable.               */
#endif

#if STM32_LSI_ENABLED
  /* LSI activation.*/
  RCC->CSR |= RCC_CSR_LSION;
 80039ca:	4b29      	ldr	r3, [pc, #164]	; (8003a70 <stm32_clock_init+0x110>)
 80039cc:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 80039ce:	4a28      	ldr	r2, [pc, #160]	; (8003a70 <stm32_clock_init+0x110>)
 80039d0:	f043 0301 	orr.w	r3, r3, #1
 80039d4:	6753      	str	r3, [r2, #116]	; 0x74
  while ((RCC->CSR & RCC_CSR_LSIRDY) == 0)
 80039d6:	4b26      	ldr	r3, [pc, #152]	; (8003a70 <stm32_clock_init+0x110>)
 80039d8:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 80039da:	f003 0302 	and.w	r3, r3, #2
 80039de:	2b00      	cmp	r3, #0
 80039e0:	d0f9      	beq.n	80039d6 <stm32_clock_init+0x76>
    ;                           /* Waits until LSI is stable.               */
#endif

#if STM32_ACTIVATE_PLL
  /* PLL activation.*/
  RCC->PLLCFGR = STM32_PLLQ | STM32_PLLSRC | STM32_PLLP | STM32_PLLN |
 80039e2:	4b23      	ldr	r3, [pc, #140]	; (8003a70 <stm32_clock_init+0x110>)
 80039e4:	4a24      	ldr	r2, [pc, #144]	; (8003a78 <stm32_clock_init+0x118>)
 80039e6:	605a      	str	r2, [r3, #4]
                 STM32_PLLM;
  RCC->CR |= RCC_CR_PLLON;
 80039e8:	4b21      	ldr	r3, [pc, #132]	; (8003a70 <stm32_clock_init+0x110>)
 80039ea:	681b      	ldr	r3, [r3, #0]
 80039ec:	4a20      	ldr	r2, [pc, #128]	; (8003a70 <stm32_clock_init+0x110>)
 80039ee:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
 80039f2:	6013      	str	r3, [r2, #0]

  /* Synchronization with voltage regulator stabilization.*/
#if defined(STM32F4XX)
  while ((PWR->CSR & PWR_CSR_VOSRDY) == 0)
 80039f4:	4b1f      	ldr	r3, [pc, #124]	; (8003a74 <stm32_clock_init+0x114>)
 80039f6:	685b      	ldr	r3, [r3, #4]
 80039f8:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
 80039fc:	2b00      	cmp	r3, #0
 80039fe:	d0f9      	beq.n	80039f4 <stm32_clock_init+0x94>
      ;
#endif /* STM32_OVERDRIVE_REQUIRED */
#endif /* defined(STM32F4XX) */

  /* Waiting for PLL lock.*/
  while (!(RCC->CR & RCC_CR_PLLRDY))
 8003a00:	4b1b      	ldr	r3, [pc, #108]	; (8003a70 <stm32_clock_init+0x110>)
 8003a02:	681b      	ldr	r3, [r3, #0]
 8003a04:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
 8003a08:	2b00      	cmp	r3, #0
 8003a0a:	d0f9      	beq.n	8003a00 <stm32_clock_init+0xa0>
    ;
#endif /* STM32_ACTIVATE_PLLSAI */

  /* Other clock-related settings (dividers, MCO etc).*/
#if !defined(STM32F413xx)
  RCC->CFGR = STM32_MCO2PRE | STM32_MCO2SEL | STM32_MCO1PRE | STM32_MCO1SEL |
 8003a0c:	4b18      	ldr	r3, [pc, #96]	; (8003a70 <stm32_clock_init+0x110>)
 8003a0e:	4a1b      	ldr	r2, [pc, #108]	; (8003a7c <stm32_clock_init+0x11c>)
 8003a10:	609a      	str	r2, [r3, #8]

  /* Flash setup.*/
#if !defined(STM32_REMOVE_REVISION_A_FIX)
  /* Some old revisions of F4x MCUs randomly crashes with compiler
     optimizations enabled AND flash caches enabled. */
  if ((DBGMCU->IDCODE == 0x20006411) && (SCB->CPUID == 0x410FC241))
 8003a12:	4b1b      	ldr	r3, [pc, #108]	; (8003a80 <stm32_clock_init+0x120>)
 8003a14:	681b      	ldr	r3, [r3, #0]
 8003a16:	4a1b      	ldr	r2, [pc, #108]	; (8003a84 <stm32_clock_init+0x124>)
 8003a18:	4293      	cmp	r3, r2
 8003a1a:	d109      	bne.n	8003a30 <stm32_clock_init+0xd0>
 8003a1c:	4b1a      	ldr	r3, [pc, #104]	; (8003a88 <stm32_clock_init+0x128>)
 8003a1e:	681b      	ldr	r3, [r3, #0]
 8003a20:	4a1a      	ldr	r2, [pc, #104]	; (8003a8c <stm32_clock_init+0x12c>)
 8003a22:	4293      	cmp	r3, r2
 8003a24:	d104      	bne.n	8003a30 <stm32_clock_init+0xd0>
    FLASH->ACR = FLASH_ACR_PRFTEN | STM32_FLASHBITS;
 8003a26:	4b1a      	ldr	r3, [pc, #104]	; (8003a90 <stm32_clock_init+0x130>)
 8003a28:	f240 1205 	movw	r2, #261	; 0x105
 8003a2c:	601a      	str	r2, [r3, #0]
 8003a2e:	e003      	b.n	8003a38 <stm32_clock_init+0xd8>
  else
    FLASH->ACR = FLASH_ACR_PRFTEN | FLASH_ACR_ICEN |
 8003a30:	4b17      	ldr	r3, [pc, #92]	; (8003a90 <stm32_clock_init+0x130>)
 8003a32:	f240 7205 	movw	r2, #1797	; 0x705
 8003a36:	601a      	str	r2, [r3, #0]
               FLASH_ACR_DCEN | STM32_FLASHBITS;
#endif

  /* Switching to the configured clock source if it is different from HSI.*/
#if (STM32_SW != STM32_SW_HSI)
  RCC->CFGR |= STM32_SW;        /* Switches on the selected clock source.   */
 8003a38:	4b0d      	ldr	r3, [pc, #52]	; (8003a70 <stm32_clock_init+0x110>)
 8003a3a:	689b      	ldr	r3, [r3, #8]
 8003a3c:	4a0c      	ldr	r2, [pc, #48]	; (8003a70 <stm32_clock_init+0x110>)
 8003a3e:	f043 0302 	orr.w	r3, r3, #2
 8003a42:	6093      	str	r3, [r2, #8]
  while ((RCC->CFGR & RCC_CFGR_SWS) != (STM32_SW << 2))
 8003a44:	4b0a      	ldr	r3, [pc, #40]	; (8003a70 <stm32_clock_init+0x110>)
 8003a46:	689b      	ldr	r3, [r3, #8]
 8003a48:	f003 030c 	and.w	r3, r3, #12
 8003a4c:	2b08      	cmp	r3, #8
 8003a4e:	d1f9      	bne.n	8003a44 <stm32_clock_init+0xe4>
#endif
#endif /* STM32_NO_INIT */

  /* SYSCFG clock enabled here because it is a multi-functional unit shared
     among multiple drivers.*/
  rccEnableAPB2(RCC_APB2ENR_SYSCFGEN, true);
 8003a50:	4b07      	ldr	r3, [pc, #28]	; (8003a70 <stm32_clock_init+0x110>)
 8003a52:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8003a54:	4a06      	ldr	r2, [pc, #24]	; (8003a70 <stm32_clock_init+0x110>)
 8003a56:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 8003a5a:	6453      	str	r3, [r2, #68]	; 0x44
 8003a5c:	4b04      	ldr	r3, [pc, #16]	; (8003a70 <stm32_clock_init+0x110>)
 8003a5e:	6e5b      	ldr	r3, [r3, #100]	; 0x64
 8003a60:	4a03      	ldr	r2, [pc, #12]	; (8003a70 <stm32_clock_init+0x110>)
 8003a62:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 8003a66:	6653      	str	r3, [r2, #100]	; 0x64
 8003a68:	4b01      	ldr	r3, [pc, #4]	; (8003a70 <stm32_clock_init+0x110>)
 8003a6a:	6e5b      	ldr	r3, [r3, #100]	; 0x64
}
 8003a6c:	4770      	bx	lr
 8003a6e:	bf00      	nop
 8003a70:	40023800 	.word	0x40023800
 8003a74:	40007000 	.word	0x40007000
 8003a78:	07405408 	.word	0x07405408
 8003a7c:	38889400 	.word	0x38889400
 8003a80:	e0042000 	.word	0xe0042000
 8003a84:	20006411 	.word	0x20006411
 8003a88:	e000ed00 	.word	0xe000ed00
 8003a8c:	410fc241 	.word	0x410fc241
 8003a90:	40023c00 	.word	0x40023c00
	...

08003aa0 <Vector6C>:
/**
 * @brief   DMA1 stream 0 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH0_HANDLER) {
 8003aa0:	b500      	push	{lr}
 8003aa2:	b083      	sub	sp, #12
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
 8003aa4:	4810      	ldr	r0, [pc, #64]	; (8003ae8 <Vector6C+0x48>)
 8003aa6:	f002 fe53 	bl	8006750 <_trace_isr_enter>
 8003aaa:	f002 fd21 	bl	80064f0 <_dbg_check_enter_isr>

  flags = (DMA1->LISR >> 0U) & STM32_DMA_ISR_MASK;
 8003aae:	4b0f      	ldr	r3, [pc, #60]	; (8003aec <Vector6C+0x4c>)
 8003ab0:	681b      	ldr	r3, [r3, #0]
 8003ab2:	f003 033d 	and.w	r3, r3, #61	; 0x3d
 8003ab6:	9301      	str	r3, [sp, #4]
  DMA1->LIFCR = flags << 0U;
 8003ab8:	4a0c      	ldr	r2, [pc, #48]	; (8003aec <Vector6C+0x4c>)
 8003aba:	9b01      	ldr	r3, [sp, #4]
 8003abc:	6093      	str	r3, [r2, #8]
  if (dma.streams[0].func)
 8003abe:	4b0c      	ldr	r3, [pc, #48]	; (8003af0 <Vector6C+0x50>)
 8003ac0:	685b      	ldr	r3, [r3, #4]
 8003ac2:	2b00      	cmp	r3, #0
 8003ac4:	d006      	beq.n	8003ad4 <Vector6C+0x34>
    dma.streams[0].func(dma.streams[0].param, flags);
 8003ac6:	4b0a      	ldr	r3, [pc, #40]	; (8003af0 <Vector6C+0x50>)
 8003ac8:	685b      	ldr	r3, [r3, #4]
 8003aca:	4a09      	ldr	r2, [pc, #36]	; (8003af0 <Vector6C+0x50>)
 8003acc:	6892      	ldr	r2, [r2, #8]
 8003ace:	9901      	ldr	r1, [sp, #4]
 8003ad0:	4610      	mov	r0, r2
 8003ad2:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
 8003ad4:	f002 fd2c 	bl	8006530 <_dbg_check_leave_isr>
 8003ad8:	4803      	ldr	r0, [pc, #12]	; (8003ae8 <Vector6C+0x48>)
 8003ada:	f002 fe61 	bl	80067a0 <_trace_isr_leave>
 8003ade:	f004 fc9f 	bl	8008420 <_port_irq_epilogue>
}
 8003ae2:	b003      	add	sp, #12
 8003ae4:	f85d fb04 	ldr.w	pc, [sp], #4
 8003ae8:	080089c4 	.word	0x080089c4
 8003aec:	40026000 	.word	0x40026000
 8003af0:	20000808 	.word	0x20000808
	...

08003b00 <Vector70>:
/**
 * @brief   DMA1 stream 1 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH1_HANDLER) {
 8003b00:	b500      	push	{lr}
 8003b02:	b083      	sub	sp, #12
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
 8003b04:	4811      	ldr	r0, [pc, #68]	; (8003b4c <Vector70+0x4c>)
 8003b06:	f002 fe23 	bl	8006750 <_trace_isr_enter>
 8003b0a:	f002 fcf1 	bl	80064f0 <_dbg_check_enter_isr>

  flags = (DMA1->LISR >> 6U) & STM32_DMA_ISR_MASK;
 8003b0e:	4b10      	ldr	r3, [pc, #64]	; (8003b50 <Vector70+0x50>)
 8003b10:	681b      	ldr	r3, [r3, #0]
 8003b12:	099b      	lsrs	r3, r3, #6
 8003b14:	f003 033d 	and.w	r3, r3, #61	; 0x3d
 8003b18:	9301      	str	r3, [sp, #4]
  DMA1->LIFCR = flags << 6U;
 8003b1a:	4a0d      	ldr	r2, [pc, #52]	; (8003b50 <Vector70+0x50>)
 8003b1c:	9b01      	ldr	r3, [sp, #4]
 8003b1e:	019b      	lsls	r3, r3, #6
 8003b20:	6093      	str	r3, [r2, #8]
  if (dma.streams[1].func)
 8003b22:	4b0c      	ldr	r3, [pc, #48]	; (8003b54 <Vector70+0x54>)
 8003b24:	68db      	ldr	r3, [r3, #12]
 8003b26:	2b00      	cmp	r3, #0
 8003b28:	d006      	beq.n	8003b38 <Vector70+0x38>
    dma.streams[1].func(dma.streams[1].param, flags);
 8003b2a:	4b0a      	ldr	r3, [pc, #40]	; (8003b54 <Vector70+0x54>)
 8003b2c:	68db      	ldr	r3, [r3, #12]
 8003b2e:	4a09      	ldr	r2, [pc, #36]	; (8003b54 <Vector70+0x54>)
 8003b30:	6912      	ldr	r2, [r2, #16]
 8003b32:	9901      	ldr	r1, [sp, #4]
 8003b34:	4610      	mov	r0, r2
 8003b36:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
 8003b38:	f002 fcfa 	bl	8006530 <_dbg_check_leave_isr>
 8003b3c:	4803      	ldr	r0, [pc, #12]	; (8003b4c <Vector70+0x4c>)
 8003b3e:	f002 fe2f 	bl	80067a0 <_trace_isr_leave>
 8003b42:	f004 fc6d 	bl	8008420 <_port_irq_epilogue>
}
 8003b46:	b003      	add	sp, #12
 8003b48:	f85d fb04 	ldr.w	pc, [sp], #4
 8003b4c:	080089d0 	.word	0x080089d0
 8003b50:	40026000 	.word	0x40026000
 8003b54:	20000808 	.word	0x20000808
	...

08003b60 <Vector74>:
/**
 * @brief   DMA1 stream 2 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH2_HANDLER) {
 8003b60:	b500      	push	{lr}
 8003b62:	b083      	sub	sp, #12
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
 8003b64:	4811      	ldr	r0, [pc, #68]	; (8003bac <Vector74+0x4c>)
 8003b66:	f002 fdf3 	bl	8006750 <_trace_isr_enter>
 8003b6a:	f002 fcc1 	bl	80064f0 <_dbg_check_enter_isr>

  flags = (DMA1->LISR >> 16U) & STM32_DMA_ISR_MASK;
 8003b6e:	4b10      	ldr	r3, [pc, #64]	; (8003bb0 <Vector74+0x50>)
 8003b70:	681b      	ldr	r3, [r3, #0]
 8003b72:	0c1b      	lsrs	r3, r3, #16
 8003b74:	f003 033d 	and.w	r3, r3, #61	; 0x3d
 8003b78:	9301      	str	r3, [sp, #4]
  DMA1->LIFCR = flags << 16U;
 8003b7a:	4a0d      	ldr	r2, [pc, #52]	; (8003bb0 <Vector74+0x50>)
 8003b7c:	9b01      	ldr	r3, [sp, #4]
 8003b7e:	041b      	lsls	r3, r3, #16
 8003b80:	6093      	str	r3, [r2, #8]
  if (dma.streams[2].func)
 8003b82:	4b0c      	ldr	r3, [pc, #48]	; (8003bb4 <Vector74+0x54>)
 8003b84:	695b      	ldr	r3, [r3, #20]
 8003b86:	2b00      	cmp	r3, #0
 8003b88:	d006      	beq.n	8003b98 <Vector74+0x38>
    dma.streams[2].func(dma.streams[2].param, flags);
 8003b8a:	4b0a      	ldr	r3, [pc, #40]	; (8003bb4 <Vector74+0x54>)
 8003b8c:	695b      	ldr	r3, [r3, #20]
 8003b8e:	4a09      	ldr	r2, [pc, #36]	; (8003bb4 <Vector74+0x54>)
 8003b90:	6992      	ldr	r2, [r2, #24]
 8003b92:	9901      	ldr	r1, [sp, #4]
 8003b94:	4610      	mov	r0, r2
 8003b96:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
 8003b98:	f002 fcca 	bl	8006530 <_dbg_check_leave_isr>
 8003b9c:	4803      	ldr	r0, [pc, #12]	; (8003bac <Vector74+0x4c>)
 8003b9e:	f002 fdff 	bl	80067a0 <_trace_isr_leave>
 8003ba2:	f004 fc3d 	bl	8008420 <_port_irq_epilogue>
}
 8003ba6:	b003      	add	sp, #12
 8003ba8:	f85d fb04 	ldr.w	pc, [sp], #4
 8003bac:	080089dc 	.word	0x080089dc
 8003bb0:	40026000 	.word	0x40026000
 8003bb4:	20000808 	.word	0x20000808
	...

08003bc0 <Vector78>:
/**
 * @brief   DMA1 stream 3 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH3_HANDLER) {
 8003bc0:	b500      	push	{lr}
 8003bc2:	b083      	sub	sp, #12
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
 8003bc4:	4811      	ldr	r0, [pc, #68]	; (8003c0c <Vector78+0x4c>)
 8003bc6:	f002 fdc3 	bl	8006750 <_trace_isr_enter>
 8003bca:	f002 fc91 	bl	80064f0 <_dbg_check_enter_isr>

  flags = (DMA1->LISR >> 22U) & STM32_DMA_ISR_MASK;
 8003bce:	4b10      	ldr	r3, [pc, #64]	; (8003c10 <Vector78+0x50>)
 8003bd0:	681b      	ldr	r3, [r3, #0]
 8003bd2:	0d9b      	lsrs	r3, r3, #22
 8003bd4:	f003 033d 	and.w	r3, r3, #61	; 0x3d
 8003bd8:	9301      	str	r3, [sp, #4]
  DMA1->LIFCR = flags << 22U;
 8003bda:	4a0d      	ldr	r2, [pc, #52]	; (8003c10 <Vector78+0x50>)
 8003bdc:	9b01      	ldr	r3, [sp, #4]
 8003bde:	059b      	lsls	r3, r3, #22
 8003be0:	6093      	str	r3, [r2, #8]
  if (dma.streams[3].func)
 8003be2:	4b0c      	ldr	r3, [pc, #48]	; (8003c14 <Vector78+0x54>)
 8003be4:	69db      	ldr	r3, [r3, #28]
 8003be6:	2b00      	cmp	r3, #0
 8003be8:	d006      	beq.n	8003bf8 <Vector78+0x38>
    dma.streams[3].func(dma.streams[3].param, flags);
 8003bea:	4b0a      	ldr	r3, [pc, #40]	; (8003c14 <Vector78+0x54>)
 8003bec:	69db      	ldr	r3, [r3, #28]
 8003bee:	4a09      	ldr	r2, [pc, #36]	; (8003c14 <Vector78+0x54>)
 8003bf0:	6a12      	ldr	r2, [r2, #32]
 8003bf2:	9901      	ldr	r1, [sp, #4]
 8003bf4:	4610      	mov	r0, r2
 8003bf6:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
 8003bf8:	f002 fc9a 	bl	8006530 <_dbg_check_leave_isr>
 8003bfc:	4803      	ldr	r0, [pc, #12]	; (8003c0c <Vector78+0x4c>)
 8003bfe:	f002 fdcf 	bl	80067a0 <_trace_isr_leave>
 8003c02:	f004 fc0d 	bl	8008420 <_port_irq_epilogue>
}
 8003c06:	b003      	add	sp, #12
 8003c08:	f85d fb04 	ldr.w	pc, [sp], #4
 8003c0c:	080089e8 	.word	0x080089e8
 8003c10:	40026000 	.word	0x40026000
 8003c14:	20000808 	.word	0x20000808
	...

08003c20 <Vector7C>:
/**
 * @brief   DMA1 stream 4 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH4_HANDLER) {
 8003c20:	b500      	push	{lr}
 8003c22:	b083      	sub	sp, #12
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
 8003c24:	4810      	ldr	r0, [pc, #64]	; (8003c68 <Vector7C+0x48>)
 8003c26:	f002 fd93 	bl	8006750 <_trace_isr_enter>
 8003c2a:	f002 fc61 	bl	80064f0 <_dbg_check_enter_isr>

  flags = (DMA1->HISR >> 0U) & STM32_DMA_ISR_MASK;
 8003c2e:	4b0f      	ldr	r3, [pc, #60]	; (8003c6c <Vector7C+0x4c>)
 8003c30:	685b      	ldr	r3, [r3, #4]
 8003c32:	f003 033d 	and.w	r3, r3, #61	; 0x3d
 8003c36:	9301      	str	r3, [sp, #4]
  DMA1->HIFCR = flags << 0U;
 8003c38:	4a0c      	ldr	r2, [pc, #48]	; (8003c6c <Vector7C+0x4c>)
 8003c3a:	9b01      	ldr	r3, [sp, #4]
 8003c3c:	60d3      	str	r3, [r2, #12]
  if (dma.streams[4].func)
 8003c3e:	4b0c      	ldr	r3, [pc, #48]	; (8003c70 <Vector7C+0x50>)
 8003c40:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8003c42:	2b00      	cmp	r3, #0
 8003c44:	d006      	beq.n	8003c54 <Vector7C+0x34>
    dma.streams[4].func(dma.streams[4].param, flags);
 8003c46:	4b0a      	ldr	r3, [pc, #40]	; (8003c70 <Vector7C+0x50>)
 8003c48:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8003c4a:	4a09      	ldr	r2, [pc, #36]	; (8003c70 <Vector7C+0x50>)
 8003c4c:	6a92      	ldr	r2, [r2, #40]	; 0x28
 8003c4e:	9901      	ldr	r1, [sp, #4]
 8003c50:	4610      	mov	r0, r2
 8003c52:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
 8003c54:	f002 fc6c 	bl	8006530 <_dbg_check_leave_isr>
 8003c58:	4803      	ldr	r0, [pc, #12]	; (8003c68 <Vector7C+0x48>)
 8003c5a:	f002 fda1 	bl	80067a0 <_trace_isr_leave>
 8003c5e:	f004 fbdf 	bl	8008420 <_port_irq_epilogue>
}
 8003c62:	b003      	add	sp, #12
 8003c64:	f85d fb04 	ldr.w	pc, [sp], #4
 8003c68:	080089f4 	.word	0x080089f4
 8003c6c:	40026000 	.word	0x40026000
 8003c70:	20000808 	.word	0x20000808
	...

08003c80 <Vector80>:
/**
 * @brief   DMA1 stream 5 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH5_HANDLER) {
 8003c80:	b500      	push	{lr}
 8003c82:	b083      	sub	sp, #12
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
 8003c84:	4811      	ldr	r0, [pc, #68]	; (8003ccc <Vector80+0x4c>)
 8003c86:	f002 fd63 	bl	8006750 <_trace_isr_enter>
 8003c8a:	f002 fc31 	bl	80064f0 <_dbg_check_enter_isr>

  flags = (DMA1->HISR >> 6U) & STM32_DMA_ISR_MASK;
 8003c8e:	4b10      	ldr	r3, [pc, #64]	; (8003cd0 <Vector80+0x50>)
 8003c90:	685b      	ldr	r3, [r3, #4]
 8003c92:	099b      	lsrs	r3, r3, #6
 8003c94:	f003 033d 	and.w	r3, r3, #61	; 0x3d
 8003c98:	9301      	str	r3, [sp, #4]
  DMA1->HIFCR = flags << 6U;
 8003c9a:	4a0d      	ldr	r2, [pc, #52]	; (8003cd0 <Vector80+0x50>)
 8003c9c:	9b01      	ldr	r3, [sp, #4]
 8003c9e:	019b      	lsls	r3, r3, #6
 8003ca0:	60d3      	str	r3, [r2, #12]
  if (dma.streams[5].func)
 8003ca2:	4b0c      	ldr	r3, [pc, #48]	; (8003cd4 <Vector80+0x54>)
 8003ca4:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8003ca6:	2b00      	cmp	r3, #0
 8003ca8:	d006      	beq.n	8003cb8 <Vector80+0x38>
    dma.streams[5].func(dma.streams[5].param, flags);
 8003caa:	4b0a      	ldr	r3, [pc, #40]	; (8003cd4 <Vector80+0x54>)
 8003cac:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8003cae:	4a09      	ldr	r2, [pc, #36]	; (8003cd4 <Vector80+0x54>)
 8003cb0:	6b12      	ldr	r2, [r2, #48]	; 0x30
 8003cb2:	9901      	ldr	r1, [sp, #4]
 8003cb4:	4610      	mov	r0, r2
 8003cb6:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
 8003cb8:	f002 fc3a 	bl	8006530 <_dbg_check_leave_isr>
 8003cbc:	4803      	ldr	r0, [pc, #12]	; (8003ccc <Vector80+0x4c>)
 8003cbe:	f002 fd6f 	bl	80067a0 <_trace_isr_leave>
 8003cc2:	f004 fbad 	bl	8008420 <_port_irq_epilogue>
}
 8003cc6:	b003      	add	sp, #12
 8003cc8:	f85d fb04 	ldr.w	pc, [sp], #4
 8003ccc:	08008a00 	.word	0x08008a00
 8003cd0:	40026000 	.word	0x40026000
 8003cd4:	20000808 	.word	0x20000808
	...

08003ce0 <Vector84>:
/**
 * @brief   DMA1 stream 6 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH6_HANDLER) {
 8003ce0:	b500      	push	{lr}
 8003ce2:	b083      	sub	sp, #12
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
 8003ce4:	4811      	ldr	r0, [pc, #68]	; (8003d2c <Vector84+0x4c>)
 8003ce6:	f002 fd33 	bl	8006750 <_trace_isr_enter>
 8003cea:	f002 fc01 	bl	80064f0 <_dbg_check_enter_isr>

  flags = (DMA1->HISR >> 16U) & STM32_DMA_ISR_MASK;
 8003cee:	4b10      	ldr	r3, [pc, #64]	; (8003d30 <Vector84+0x50>)
 8003cf0:	685b      	ldr	r3, [r3, #4]
 8003cf2:	0c1b      	lsrs	r3, r3, #16
 8003cf4:	f003 033d 	and.w	r3, r3, #61	; 0x3d
 8003cf8:	9301      	str	r3, [sp, #4]
  DMA1->HIFCR = flags << 16U;
 8003cfa:	4a0d      	ldr	r2, [pc, #52]	; (8003d30 <Vector84+0x50>)
 8003cfc:	9b01      	ldr	r3, [sp, #4]
 8003cfe:	041b      	lsls	r3, r3, #16
 8003d00:	60d3      	str	r3, [r2, #12]
  if (dma.streams[6].func)
 8003d02:	4b0c      	ldr	r3, [pc, #48]	; (8003d34 <Vector84+0x54>)
 8003d04:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8003d06:	2b00      	cmp	r3, #0
 8003d08:	d006      	beq.n	8003d18 <Vector84+0x38>
    dma.streams[6].func(dma.streams[6].param, flags);
 8003d0a:	4b0a      	ldr	r3, [pc, #40]	; (8003d34 <Vector84+0x54>)
 8003d0c:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8003d0e:	4a09      	ldr	r2, [pc, #36]	; (8003d34 <Vector84+0x54>)
 8003d10:	6b92      	ldr	r2, [r2, #56]	; 0x38
 8003d12:	9901      	ldr	r1, [sp, #4]
 8003d14:	4610      	mov	r0, r2
 8003d16:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
 8003d18:	f002 fc0a 	bl	8006530 <_dbg_check_leave_isr>
 8003d1c:	4803      	ldr	r0, [pc, #12]	; (8003d2c <Vector84+0x4c>)
 8003d1e:	f002 fd3f 	bl	80067a0 <_trace_isr_leave>
 8003d22:	f004 fb7d 	bl	8008420 <_port_irq_epilogue>
}
 8003d26:	b003      	add	sp, #12
 8003d28:	f85d fb04 	ldr.w	pc, [sp], #4
 8003d2c:	08008a0c 	.word	0x08008a0c
 8003d30:	40026000 	.word	0x40026000
 8003d34:	20000808 	.word	0x20000808
	...

08003d40 <VectorFC>:
/**
 * @brief   DMA1 stream 7 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH7_HANDLER) {
 8003d40:	b500      	push	{lr}
 8003d42:	b083      	sub	sp, #12
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
 8003d44:	4811      	ldr	r0, [pc, #68]	; (8003d8c <VectorFC+0x4c>)
 8003d46:	f002 fd03 	bl	8006750 <_trace_isr_enter>
 8003d4a:	f002 fbd1 	bl	80064f0 <_dbg_check_enter_isr>

  flags = (DMA1->HISR >> 22U) & STM32_DMA_ISR_MASK;
 8003d4e:	4b10      	ldr	r3, [pc, #64]	; (8003d90 <VectorFC+0x50>)
 8003d50:	685b      	ldr	r3, [r3, #4]
 8003d52:	0d9b      	lsrs	r3, r3, #22
 8003d54:	f003 033d 	and.w	r3, r3, #61	; 0x3d
 8003d58:	9301      	str	r3, [sp, #4]
  DMA1->HIFCR = flags << 22U;
 8003d5a:	4a0d      	ldr	r2, [pc, #52]	; (8003d90 <VectorFC+0x50>)
 8003d5c:	9b01      	ldr	r3, [sp, #4]
 8003d5e:	059b      	lsls	r3, r3, #22
 8003d60:	60d3      	str	r3, [r2, #12]
  if (dma.streams[7].func)
 8003d62:	4b0c      	ldr	r3, [pc, #48]	; (8003d94 <VectorFC+0x54>)
 8003d64:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8003d66:	2b00      	cmp	r3, #0
 8003d68:	d006      	beq.n	8003d78 <VectorFC+0x38>
    dma.streams[7].func(dma.streams[7].param, flags);
 8003d6a:	4b0a      	ldr	r3, [pc, #40]	; (8003d94 <VectorFC+0x54>)
 8003d6c:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8003d6e:	4a09      	ldr	r2, [pc, #36]	; (8003d94 <VectorFC+0x54>)
 8003d70:	6c12      	ldr	r2, [r2, #64]	; 0x40
 8003d72:	9901      	ldr	r1, [sp, #4]
 8003d74:	4610      	mov	r0, r2
 8003d76:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
 8003d78:	f002 fbda 	bl	8006530 <_dbg_check_leave_isr>
 8003d7c:	4803      	ldr	r0, [pc, #12]	; (8003d8c <VectorFC+0x4c>)
 8003d7e:	f002 fd0f 	bl	80067a0 <_trace_isr_leave>
 8003d82:	f004 fb4d 	bl	8008420 <_port_irq_epilogue>
}
 8003d86:	b003      	add	sp, #12
 8003d88:	f85d fb04 	ldr.w	pc, [sp], #4
 8003d8c:	08008a18 	.word	0x08008a18
 8003d90:	40026000 	.word	0x40026000
 8003d94:	20000808 	.word	0x20000808
	...

08003da0 <Vector120>:
/**
 * @brief   DMA2 stream 0 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH0_HANDLER) {
 8003da0:	b500      	push	{lr}
 8003da2:	b083      	sub	sp, #12
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
 8003da4:	4810      	ldr	r0, [pc, #64]	; (8003de8 <Vector120+0x48>)
 8003da6:	f002 fcd3 	bl	8006750 <_trace_isr_enter>
 8003daa:	f002 fba1 	bl	80064f0 <_dbg_check_enter_isr>

  flags = (DMA2->LISR >> 0U) & STM32_DMA_ISR_MASK;
 8003dae:	4b0f      	ldr	r3, [pc, #60]	; (8003dec <Vector120+0x4c>)
 8003db0:	681b      	ldr	r3, [r3, #0]
 8003db2:	f003 033d 	and.w	r3, r3, #61	; 0x3d
 8003db6:	9301      	str	r3, [sp, #4]
  DMA2->LIFCR = flags << 0U;
 8003db8:	4a0c      	ldr	r2, [pc, #48]	; (8003dec <Vector120+0x4c>)
 8003dba:	9b01      	ldr	r3, [sp, #4]
 8003dbc:	6093      	str	r3, [r2, #8]
  if (dma.streams[8].func)
 8003dbe:	4b0c      	ldr	r3, [pc, #48]	; (8003df0 <Vector120+0x50>)
 8003dc0:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8003dc2:	2b00      	cmp	r3, #0
 8003dc4:	d006      	beq.n	8003dd4 <Vector120+0x34>
    dma.streams[8].func(dma.streams[8].param, flags);
 8003dc6:	4b0a      	ldr	r3, [pc, #40]	; (8003df0 <Vector120+0x50>)
 8003dc8:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8003dca:	4a09      	ldr	r2, [pc, #36]	; (8003df0 <Vector120+0x50>)
 8003dcc:	6c92      	ldr	r2, [r2, #72]	; 0x48
 8003dce:	9901      	ldr	r1, [sp, #4]
 8003dd0:	4610      	mov	r0, r2
 8003dd2:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
 8003dd4:	f002 fbac 	bl	8006530 <_dbg_check_leave_isr>
 8003dd8:	4803      	ldr	r0, [pc, #12]	; (8003de8 <Vector120+0x48>)
 8003dda:	f002 fce1 	bl	80067a0 <_trace_isr_leave>
 8003dde:	f004 fb1f 	bl	8008420 <_port_irq_epilogue>
}
 8003de2:	b003      	add	sp, #12
 8003de4:	f85d fb04 	ldr.w	pc, [sp], #4
 8003de8:	08008a24 	.word	0x08008a24
 8003dec:	40026400 	.word	0x40026400
 8003df0:	20000808 	.word	0x20000808
	...

08003e00 <Vector124>:
/**
 * @brief   DMA2 stream 1 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH1_HANDLER) {
 8003e00:	b500      	push	{lr}
 8003e02:	b083      	sub	sp, #12
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
 8003e04:	4811      	ldr	r0, [pc, #68]	; (8003e4c <Vector124+0x4c>)
 8003e06:	f002 fca3 	bl	8006750 <_trace_isr_enter>
 8003e0a:	f002 fb71 	bl	80064f0 <_dbg_check_enter_isr>

  flags = (DMA2->LISR >> 6U) & STM32_DMA_ISR_MASK;
 8003e0e:	4b10      	ldr	r3, [pc, #64]	; (8003e50 <Vector124+0x50>)
 8003e10:	681b      	ldr	r3, [r3, #0]
 8003e12:	099b      	lsrs	r3, r3, #6
 8003e14:	f003 033d 	and.w	r3, r3, #61	; 0x3d
 8003e18:	9301      	str	r3, [sp, #4]
  DMA2->LIFCR = flags << 6U;
 8003e1a:	4a0d      	ldr	r2, [pc, #52]	; (8003e50 <Vector124+0x50>)
 8003e1c:	9b01      	ldr	r3, [sp, #4]
 8003e1e:	019b      	lsls	r3, r3, #6
 8003e20:	6093      	str	r3, [r2, #8]
  if (dma.streams[9].func)
 8003e22:	4b0c      	ldr	r3, [pc, #48]	; (8003e54 <Vector124+0x54>)
 8003e24:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 8003e26:	2b00      	cmp	r3, #0
 8003e28:	d006      	beq.n	8003e38 <Vector124+0x38>
    dma.streams[9].func(dma.streams[9].param, flags);
 8003e2a:	4b0a      	ldr	r3, [pc, #40]	; (8003e54 <Vector124+0x54>)
 8003e2c:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 8003e2e:	4a09      	ldr	r2, [pc, #36]	; (8003e54 <Vector124+0x54>)
 8003e30:	6d12      	ldr	r2, [r2, #80]	; 0x50
 8003e32:	9901      	ldr	r1, [sp, #4]
 8003e34:	4610      	mov	r0, r2
 8003e36:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
 8003e38:	f002 fb7a 	bl	8006530 <_dbg_check_leave_isr>
 8003e3c:	4803      	ldr	r0, [pc, #12]	; (8003e4c <Vector124+0x4c>)
 8003e3e:	f002 fcaf 	bl	80067a0 <_trace_isr_leave>
 8003e42:	f004 faed 	bl	8008420 <_port_irq_epilogue>
}
 8003e46:	b003      	add	sp, #12
 8003e48:	f85d fb04 	ldr.w	pc, [sp], #4
 8003e4c:	08008a30 	.word	0x08008a30
 8003e50:	40026400 	.word	0x40026400
 8003e54:	20000808 	.word	0x20000808
	...

08003e60 <Vector128>:
/**
 * @brief   DMA2 stream 2 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH2_HANDLER) {
 8003e60:	b500      	push	{lr}
 8003e62:	b083      	sub	sp, #12
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
 8003e64:	4811      	ldr	r0, [pc, #68]	; (8003eac <Vector128+0x4c>)
 8003e66:	f002 fc73 	bl	8006750 <_trace_isr_enter>
 8003e6a:	f002 fb41 	bl	80064f0 <_dbg_check_enter_isr>

  flags = (DMA2->LISR >> 16U) & STM32_DMA_ISR_MASK;
 8003e6e:	4b10      	ldr	r3, [pc, #64]	; (8003eb0 <Vector128+0x50>)
 8003e70:	681b      	ldr	r3, [r3, #0]
 8003e72:	0c1b      	lsrs	r3, r3, #16
 8003e74:	f003 033d 	and.w	r3, r3, #61	; 0x3d
 8003e78:	9301      	str	r3, [sp, #4]
  DMA2->LIFCR = flags << 16U;
 8003e7a:	4a0d      	ldr	r2, [pc, #52]	; (8003eb0 <Vector128+0x50>)
 8003e7c:	9b01      	ldr	r3, [sp, #4]
 8003e7e:	041b      	lsls	r3, r3, #16
 8003e80:	6093      	str	r3, [r2, #8]
  if (dma.streams[10].func)
 8003e82:	4b0c      	ldr	r3, [pc, #48]	; (8003eb4 <Vector128+0x54>)
 8003e84:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8003e86:	2b00      	cmp	r3, #0
 8003e88:	d006      	beq.n	8003e98 <Vector128+0x38>
    dma.streams[10].func(dma.streams[10].param, flags);
 8003e8a:	4b0a      	ldr	r3, [pc, #40]	; (8003eb4 <Vector128+0x54>)
 8003e8c:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8003e8e:	4a09      	ldr	r2, [pc, #36]	; (8003eb4 <Vector128+0x54>)
 8003e90:	6d92      	ldr	r2, [r2, #88]	; 0x58
 8003e92:	9901      	ldr	r1, [sp, #4]
 8003e94:	4610      	mov	r0, r2
 8003e96:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
 8003e98:	f002 fb4a 	bl	8006530 <_dbg_check_leave_isr>
 8003e9c:	4803      	ldr	r0, [pc, #12]	; (8003eac <Vector128+0x4c>)
 8003e9e:	f002 fc7f 	bl	80067a0 <_trace_isr_leave>
 8003ea2:	f004 fabd 	bl	8008420 <_port_irq_epilogue>
}
 8003ea6:	b003      	add	sp, #12
 8003ea8:	f85d fb04 	ldr.w	pc, [sp], #4
 8003eac:	08008a3c 	.word	0x08008a3c
 8003eb0:	40026400 	.word	0x40026400
 8003eb4:	20000808 	.word	0x20000808
	...

08003ec0 <Vector12C>:
/**
 * @brief   DMA2 stream 3 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH3_HANDLER) {
 8003ec0:	b500      	push	{lr}
 8003ec2:	b083      	sub	sp, #12
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
 8003ec4:	4811      	ldr	r0, [pc, #68]	; (8003f0c <Vector12C+0x4c>)
 8003ec6:	f002 fc43 	bl	8006750 <_trace_isr_enter>
 8003eca:	f002 fb11 	bl	80064f0 <_dbg_check_enter_isr>

  flags = (DMA2->LISR >> 22U) & STM32_DMA_ISR_MASK;
 8003ece:	4b10      	ldr	r3, [pc, #64]	; (8003f10 <Vector12C+0x50>)
 8003ed0:	681b      	ldr	r3, [r3, #0]
 8003ed2:	0d9b      	lsrs	r3, r3, #22
 8003ed4:	f003 033d 	and.w	r3, r3, #61	; 0x3d
 8003ed8:	9301      	str	r3, [sp, #4]
  DMA2->LIFCR = flags << 22U;
 8003eda:	4a0d      	ldr	r2, [pc, #52]	; (8003f10 <Vector12C+0x50>)
 8003edc:	9b01      	ldr	r3, [sp, #4]
 8003ede:	059b      	lsls	r3, r3, #22
 8003ee0:	6093      	str	r3, [r2, #8]
  if (dma.streams[11].func)
 8003ee2:	4b0c      	ldr	r3, [pc, #48]	; (8003f14 <Vector12C+0x54>)
 8003ee4:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 8003ee6:	2b00      	cmp	r3, #0
 8003ee8:	d006      	beq.n	8003ef8 <Vector12C+0x38>
    dma.streams[11].func(dma.streams[11].param, flags);
 8003eea:	4b0a      	ldr	r3, [pc, #40]	; (8003f14 <Vector12C+0x54>)
 8003eec:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 8003eee:	4a09      	ldr	r2, [pc, #36]	; (8003f14 <Vector12C+0x54>)
 8003ef0:	6e12      	ldr	r2, [r2, #96]	; 0x60
 8003ef2:	9901      	ldr	r1, [sp, #4]
 8003ef4:	4610      	mov	r0, r2
 8003ef6:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
 8003ef8:	f002 fb1a 	bl	8006530 <_dbg_check_leave_isr>
 8003efc:	4803      	ldr	r0, [pc, #12]	; (8003f0c <Vector12C+0x4c>)
 8003efe:	f002 fc4f 	bl	80067a0 <_trace_isr_leave>
 8003f02:	f004 fa8d 	bl	8008420 <_port_irq_epilogue>
}
 8003f06:	b003      	add	sp, #12
 8003f08:	f85d fb04 	ldr.w	pc, [sp], #4
 8003f0c:	08008a48 	.word	0x08008a48
 8003f10:	40026400 	.word	0x40026400
 8003f14:	20000808 	.word	0x20000808
	...

08003f20 <Vector130>:
/**
 * @brief   DMA2 stream 4 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH4_HANDLER) {
 8003f20:	b500      	push	{lr}
 8003f22:	b083      	sub	sp, #12
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
 8003f24:	4810      	ldr	r0, [pc, #64]	; (8003f68 <Vector130+0x48>)
 8003f26:	f002 fc13 	bl	8006750 <_trace_isr_enter>
 8003f2a:	f002 fae1 	bl	80064f0 <_dbg_check_enter_isr>

  flags = (DMA2->HISR >> 0U) & STM32_DMA_ISR_MASK;
 8003f2e:	4b0f      	ldr	r3, [pc, #60]	; (8003f6c <Vector130+0x4c>)
 8003f30:	685b      	ldr	r3, [r3, #4]
 8003f32:	f003 033d 	and.w	r3, r3, #61	; 0x3d
 8003f36:	9301      	str	r3, [sp, #4]
  DMA2->HIFCR = flags << 0U;
 8003f38:	4a0c      	ldr	r2, [pc, #48]	; (8003f6c <Vector130+0x4c>)
 8003f3a:	9b01      	ldr	r3, [sp, #4]
 8003f3c:	60d3      	str	r3, [r2, #12]
  if (dma.streams[12].func)
 8003f3e:	4b0c      	ldr	r3, [pc, #48]	; (8003f70 <Vector130+0x50>)
 8003f40:	6e5b      	ldr	r3, [r3, #100]	; 0x64
 8003f42:	2b00      	cmp	r3, #0
 8003f44:	d006      	beq.n	8003f54 <Vector130+0x34>
    dma.streams[12].func(dma.streams[12].param, flags);
 8003f46:	4b0a      	ldr	r3, [pc, #40]	; (8003f70 <Vector130+0x50>)
 8003f48:	6e5b      	ldr	r3, [r3, #100]	; 0x64
 8003f4a:	4a09      	ldr	r2, [pc, #36]	; (8003f70 <Vector130+0x50>)
 8003f4c:	6e92      	ldr	r2, [r2, #104]	; 0x68
 8003f4e:	9901      	ldr	r1, [sp, #4]
 8003f50:	4610      	mov	r0, r2
 8003f52:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
 8003f54:	f002 faec 	bl	8006530 <_dbg_check_leave_isr>
 8003f58:	4803      	ldr	r0, [pc, #12]	; (8003f68 <Vector130+0x48>)
 8003f5a:	f002 fc21 	bl	80067a0 <_trace_isr_leave>
 8003f5e:	f004 fa5f 	bl	8008420 <_port_irq_epilogue>
}
 8003f62:	b003      	add	sp, #12
 8003f64:	f85d fb04 	ldr.w	pc, [sp], #4
 8003f68:	08008a54 	.word	0x08008a54
 8003f6c:	40026400 	.word	0x40026400
 8003f70:	20000808 	.word	0x20000808
	...

08003f80 <Vector150>:
/**
 * @brief   DMA2 stream 5 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH5_HANDLER) {
 8003f80:	b500      	push	{lr}
 8003f82:	b083      	sub	sp, #12
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
 8003f84:	4811      	ldr	r0, [pc, #68]	; (8003fcc <Vector150+0x4c>)
 8003f86:	f002 fbe3 	bl	8006750 <_trace_isr_enter>
 8003f8a:	f002 fab1 	bl	80064f0 <_dbg_check_enter_isr>

  flags = (DMA2->HISR >> 6U) & STM32_DMA_ISR_MASK;
 8003f8e:	4b10      	ldr	r3, [pc, #64]	; (8003fd0 <Vector150+0x50>)
 8003f90:	685b      	ldr	r3, [r3, #4]
 8003f92:	099b      	lsrs	r3, r3, #6
 8003f94:	f003 033d 	and.w	r3, r3, #61	; 0x3d
 8003f98:	9301      	str	r3, [sp, #4]
  DMA2->HIFCR = flags << 6U;
 8003f9a:	4a0d      	ldr	r2, [pc, #52]	; (8003fd0 <Vector150+0x50>)
 8003f9c:	9b01      	ldr	r3, [sp, #4]
 8003f9e:	019b      	lsls	r3, r3, #6
 8003fa0:	60d3      	str	r3, [r2, #12]
  if (dma.streams[13].func)
 8003fa2:	4b0c      	ldr	r3, [pc, #48]	; (8003fd4 <Vector150+0x54>)
 8003fa4:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 8003fa6:	2b00      	cmp	r3, #0
 8003fa8:	d006      	beq.n	8003fb8 <Vector150+0x38>
    dma.streams[13].func(dma.streams[13].param, flags);
 8003faa:	4b0a      	ldr	r3, [pc, #40]	; (8003fd4 <Vector150+0x54>)
 8003fac:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 8003fae:	4a09      	ldr	r2, [pc, #36]	; (8003fd4 <Vector150+0x54>)
 8003fb0:	6f12      	ldr	r2, [r2, #112]	; 0x70
 8003fb2:	9901      	ldr	r1, [sp, #4]
 8003fb4:	4610      	mov	r0, r2
 8003fb6:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
 8003fb8:	f002 faba 	bl	8006530 <_dbg_check_leave_isr>
 8003fbc:	4803      	ldr	r0, [pc, #12]	; (8003fcc <Vector150+0x4c>)
 8003fbe:	f002 fbef 	bl	80067a0 <_trace_isr_leave>
 8003fc2:	f004 fa2d 	bl	8008420 <_port_irq_epilogue>
}
 8003fc6:	b003      	add	sp, #12
 8003fc8:	f85d fb04 	ldr.w	pc, [sp], #4
 8003fcc:	08008a60 	.word	0x08008a60
 8003fd0:	40026400 	.word	0x40026400
 8003fd4:	20000808 	.word	0x20000808
	...

08003fe0 <Vector154>:
/**
 * @brief   DMA2 stream 6 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH6_HANDLER) {
 8003fe0:	b500      	push	{lr}
 8003fe2:	b083      	sub	sp, #12
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
 8003fe4:	4811      	ldr	r0, [pc, #68]	; (800402c <Vector154+0x4c>)
 8003fe6:	f002 fbb3 	bl	8006750 <_trace_isr_enter>
 8003fea:	f002 fa81 	bl	80064f0 <_dbg_check_enter_isr>

  flags = (DMA2->HISR >> 16U) & STM32_DMA_ISR_MASK;
 8003fee:	4b10      	ldr	r3, [pc, #64]	; (8004030 <Vector154+0x50>)
 8003ff0:	685b      	ldr	r3, [r3, #4]
 8003ff2:	0c1b      	lsrs	r3, r3, #16
 8003ff4:	f003 033d 	and.w	r3, r3, #61	; 0x3d
 8003ff8:	9301      	str	r3, [sp, #4]
  DMA2->HIFCR = flags << 16U;
 8003ffa:	4a0d      	ldr	r2, [pc, #52]	; (8004030 <Vector154+0x50>)
 8003ffc:	9b01      	ldr	r3, [sp, #4]
 8003ffe:	041b      	lsls	r3, r3, #16
 8004000:	60d3      	str	r3, [r2, #12]
  if (dma.streams[14].func)
 8004002:	4b0c      	ldr	r3, [pc, #48]	; (8004034 <Vector154+0x54>)
 8004004:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 8004006:	2b00      	cmp	r3, #0
 8004008:	d006      	beq.n	8004018 <Vector154+0x38>
    dma.streams[14].func(dma.streams[14].param, flags);
 800400a:	4b0a      	ldr	r3, [pc, #40]	; (8004034 <Vector154+0x54>)
 800400c:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 800400e:	4a09      	ldr	r2, [pc, #36]	; (8004034 <Vector154+0x54>)
 8004010:	6f92      	ldr	r2, [r2, #120]	; 0x78
 8004012:	9901      	ldr	r1, [sp, #4]
 8004014:	4610      	mov	r0, r2
 8004016:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
 8004018:	f002 fa8a 	bl	8006530 <_dbg_check_leave_isr>
 800401c:	4803      	ldr	r0, [pc, #12]	; (800402c <Vector154+0x4c>)
 800401e:	f002 fbbf 	bl	80067a0 <_trace_isr_leave>
 8004022:	f004 f9fd 	bl	8008420 <_port_irq_epilogue>
}
 8004026:	b003      	add	sp, #12
 8004028:	f85d fb04 	ldr.w	pc, [sp], #4
 800402c:	08008a6c 	.word	0x08008a6c
 8004030:	40026400 	.word	0x40026400
 8004034:	20000808 	.word	0x20000808
	...

08004040 <Vector158>:
/**
 * @brief   DMA2 stream 7 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH7_HANDLER) {
 8004040:	b500      	push	{lr}
 8004042:	b083      	sub	sp, #12
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
 8004044:	4812      	ldr	r0, [pc, #72]	; (8004090 <Vector158+0x50>)
 8004046:	f002 fb83 	bl	8006750 <_trace_isr_enter>
 800404a:	f002 fa51 	bl	80064f0 <_dbg_check_enter_isr>

  flags = (DMA2->HISR >> 22U) & STM32_DMA_ISR_MASK;
 800404e:	4b11      	ldr	r3, [pc, #68]	; (8004094 <Vector158+0x54>)
 8004050:	685b      	ldr	r3, [r3, #4]
 8004052:	0d9b      	lsrs	r3, r3, #22
 8004054:	f003 033d 	and.w	r3, r3, #61	; 0x3d
 8004058:	9301      	str	r3, [sp, #4]
  DMA2->HIFCR = flags << 22U;
 800405a:	4a0e      	ldr	r2, [pc, #56]	; (8004094 <Vector158+0x54>)
 800405c:	9b01      	ldr	r3, [sp, #4]
 800405e:	059b      	lsls	r3, r3, #22
 8004060:	60d3      	str	r3, [r2, #12]
  if (dma.streams[15].func)
 8004062:	4b0d      	ldr	r3, [pc, #52]	; (8004098 <Vector158+0x58>)
 8004064:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
 8004066:	2b00      	cmp	r3, #0
 8004068:	d007      	beq.n	800407a <Vector158+0x3a>
    dma.streams[15].func(dma.streams[15].param, flags);
 800406a:	4b0b      	ldr	r3, [pc, #44]	; (8004098 <Vector158+0x58>)
 800406c:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
 800406e:	4a0a      	ldr	r2, [pc, #40]	; (8004098 <Vector158+0x58>)
 8004070:	f8d2 2080 	ldr.w	r2, [r2, #128]	; 0x80
 8004074:	9901      	ldr	r1, [sp, #4]
 8004076:	4610      	mov	r0, r2
 8004078:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
 800407a:	f002 fa59 	bl	8006530 <_dbg_check_leave_isr>
 800407e:	4804      	ldr	r0, [pc, #16]	; (8004090 <Vector158+0x50>)
 8004080:	f002 fb8e 	bl	80067a0 <_trace_isr_leave>
 8004084:	f004 f9cc 	bl	8008420 <_port_irq_epilogue>
}
 8004088:	b003      	add	sp, #12
 800408a:	f85d fb04 	ldr.w	pc, [sp], #4
 800408e:	bf00      	nop
 8004090:	08008a78 	.word	0x08008a78
 8004094:	40026400 	.word	0x40026400
 8004098:	20000808 	.word	0x20000808
 800409c:	00000000 	.word	0x00000000

080040a0 <dmaInit>:
/**
 * @brief   STM32 DMA helper initialization.
 *
 * @init
 */
void dmaInit(void) {
 80040a0:	b082      	sub	sp, #8
  unsigned i;

  dma.allocated_mask = 0U;
 80040a2:	4b17      	ldr	r3, [pc, #92]	; (8004100 <dmaInit+0x60>)
 80040a4:	2200      	movs	r2, #0
 80040a6:	601a      	str	r2, [r3, #0]
  for (i = 0U; i < STM32_DMA_STREAMS; i++) {
 80040a8:	2300      	movs	r3, #0
 80040aa:	9301      	str	r3, [sp, #4]
 80040ac:	e012      	b.n	80040d4 <dmaInit+0x34>
    _stm32_dma_streams[i].stream->CR = STM32_DMA_CR_RESET_VALUE;
 80040ae:	4915      	ldr	r1, [pc, #84]	; (8004104 <dmaInit+0x64>)
 80040b0:	9a01      	ldr	r2, [sp, #4]
 80040b2:	4613      	mov	r3, r2
 80040b4:	005b      	lsls	r3, r3, #1
 80040b6:	4413      	add	r3, r2
 80040b8:	009b      	lsls	r3, r3, #2
 80040ba:	440b      	add	r3, r1
 80040bc:	681b      	ldr	r3, [r3, #0]
 80040be:	2200      	movs	r2, #0
 80040c0:	601a      	str	r2, [r3, #0]
    dma.streams[i].func = NULL;
 80040c2:	4a0f      	ldr	r2, [pc, #60]	; (8004100 <dmaInit+0x60>)
 80040c4:	9b01      	ldr	r3, [sp, #4]
 80040c6:	00db      	lsls	r3, r3, #3
 80040c8:	4413      	add	r3, r2
 80040ca:	2200      	movs	r2, #0
 80040cc:	605a      	str	r2, [r3, #4]
  for (i = 0U; i < STM32_DMA_STREAMS; i++) {
 80040ce:	9b01      	ldr	r3, [sp, #4]
 80040d0:	3301      	adds	r3, #1
 80040d2:	9301      	str	r3, [sp, #4]
 80040d4:	9b01      	ldr	r3, [sp, #4]
 80040d6:	2b0f      	cmp	r3, #15
 80040d8:	d9e9      	bls.n	80040ae <dmaInit+0xe>
  }
  DMA1->LIFCR = 0xFFFFFFFFU;
 80040da:	4b0b      	ldr	r3, [pc, #44]	; (8004108 <dmaInit+0x68>)
 80040dc:	f04f 32ff 	mov.w	r2, #4294967295
 80040e0:	609a      	str	r2, [r3, #8]
  DMA1->HIFCR = 0xFFFFFFFFU;
 80040e2:	4b09      	ldr	r3, [pc, #36]	; (8004108 <dmaInit+0x68>)
 80040e4:	f04f 32ff 	mov.w	r2, #4294967295
 80040e8:	60da      	str	r2, [r3, #12]
  DMA2->LIFCR = 0xFFFFFFFFU;
 80040ea:	4b08      	ldr	r3, [pc, #32]	; (800410c <dmaInit+0x6c>)
 80040ec:	f04f 32ff 	mov.w	r2, #4294967295
 80040f0:	609a      	str	r2, [r3, #8]
  DMA2->HIFCR = 0xFFFFFFFFU;
 80040f2:	4b06      	ldr	r3, [pc, #24]	; (800410c <dmaInit+0x6c>)
 80040f4:	f04f 32ff 	mov.w	r2, #4294967295
 80040f8:	60da      	str	r2, [r3, #12]
}
 80040fa:	b002      	add	sp, #8
 80040fc:	4770      	bx	lr
 80040fe:	bf00      	nop
 8004100:	20000808 	.word	0x20000808
 8004104:	08008904 	.word	0x08008904
 8004108:	40026000 	.word	0x40026000
 800410c:	40026400 	.word	0x40026400

08004110 <_pal_lld_init>:

  for (i = 0; i < 16; i++) {
    _pal_init_event(i);
  }
#endif
}
 8004110:	4770      	bx	lr
 8004112:	bf00      	nop
	...

08004120 <_pal_lld_setgroupmode>:
 *
 * @notapi
 */
void _pal_lld_setgroupmode(ioportid_t port,
                           ioportmask_t mask,
                           iomode_t mode) {
 8004120:	b08e      	sub	sp, #56	; 0x38
 8004122:	9003      	str	r0, [sp, #12]
 8004124:	9102      	str	r1, [sp, #8]
 8004126:	9201      	str	r2, [sp, #4]

  uint32_t moder   = (mode & PAL_STM32_MODE_MASK) >> 0;
 8004128:	9b01      	ldr	r3, [sp, #4]
 800412a:	f003 0303 	and.w	r3, r3, #3
 800412e:	930d      	str	r3, [sp, #52]	; 0x34
  uint32_t otyper  = (mode & PAL_STM32_OTYPE_MASK) >> 2;
 8004130:	9b01      	ldr	r3, [sp, #4]
 8004132:	089b      	lsrs	r3, r3, #2
 8004134:	f003 0301 	and.w	r3, r3, #1
 8004138:	930c      	str	r3, [sp, #48]	; 0x30
  uint32_t ospeedr = (mode & PAL_STM32_OSPEED_MASK) >> 3;
 800413a:	9b01      	ldr	r3, [sp, #4]
 800413c:	08db      	lsrs	r3, r3, #3
 800413e:	f003 0303 	and.w	r3, r3, #3
 8004142:	930b      	str	r3, [sp, #44]	; 0x2c
  uint32_t pupdr   = (mode & PAL_STM32_PUPDR_MASK) >> 5;
 8004144:	9b01      	ldr	r3, [sp, #4]
 8004146:	095b      	lsrs	r3, r3, #5
 8004148:	f003 0303 	and.w	r3, r3, #3
 800414c:	930a      	str	r3, [sp, #40]	; 0x28
  uint32_t altr    = (mode & PAL_STM32_ALTERNATE_MASK) >> 7;
 800414e:	9b01      	ldr	r3, [sp, #4]
 8004150:	09db      	lsrs	r3, r3, #7
 8004152:	f003 030f 	and.w	r3, r3, #15
 8004156:	9308      	str	r3, [sp, #32]
  uint32_t bit     = 0;
 8004158:	2300      	movs	r3, #0
 800415a:	9309      	str	r3, [sp, #36]	; 0x24
  while (true) {
    if ((mask & 1) != 0) {
 800415c:	9b02      	ldr	r3, [sp, #8]
 800415e:	f003 0301 	and.w	r3, r3, #1
 8004162:	2b00      	cmp	r3, #0
 8004164:	d079      	beq.n	800425a <_pal_lld_setgroupmode+0x13a>
      uint32_t altrmask, m1, m2, m4;

      altrmask = altr << ((bit & 7) * 4);
 8004166:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8004168:	f003 0307 	and.w	r3, r3, #7
 800416c:	009b      	lsls	r3, r3, #2
 800416e:	9a08      	ldr	r2, [sp, #32]
 8004170:	fa02 f303 	lsl.w	r3, r2, r3
 8004174:	9307      	str	r3, [sp, #28]
      m1 = 1 << bit;
 8004176:	2201      	movs	r2, #1
 8004178:	9b09      	ldr	r3, [sp, #36]	; 0x24
 800417a:	fa02 f303 	lsl.w	r3, r2, r3
 800417e:	9306      	str	r3, [sp, #24]
      m2 = 3 << (bit * 2);
 8004180:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8004182:	005b      	lsls	r3, r3, #1
 8004184:	2203      	movs	r2, #3
 8004186:	fa02 f303 	lsl.w	r3, r2, r3
 800418a:	9305      	str	r3, [sp, #20]
      m4 = 15 << ((bit & 7) * 4);
 800418c:	9b09      	ldr	r3, [sp, #36]	; 0x24
 800418e:	f003 0307 	and.w	r3, r3, #7
 8004192:	009b      	lsls	r3, r3, #2
 8004194:	220f      	movs	r2, #15
 8004196:	fa02 f303 	lsl.w	r3, r2, r3
 800419a:	9304      	str	r3, [sp, #16]
      port->OTYPER  = (port->OTYPER & ~m1) | otyper;
 800419c:	9b03      	ldr	r3, [sp, #12]
 800419e:	685a      	ldr	r2, [r3, #4]
 80041a0:	9b06      	ldr	r3, [sp, #24]
 80041a2:	43db      	mvns	r3, r3
 80041a4:	401a      	ands	r2, r3
 80041a6:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 80041a8:	431a      	orrs	r2, r3
 80041aa:	9b03      	ldr	r3, [sp, #12]
 80041ac:	605a      	str	r2, [r3, #4]
      port->OSPEEDR = (port->OSPEEDR & ~m2) | ospeedr;
 80041ae:	9b03      	ldr	r3, [sp, #12]
 80041b0:	689a      	ldr	r2, [r3, #8]
 80041b2:	9b05      	ldr	r3, [sp, #20]
 80041b4:	43db      	mvns	r3, r3
 80041b6:	401a      	ands	r2, r3
 80041b8:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 80041ba:	431a      	orrs	r2, r3
 80041bc:	9b03      	ldr	r3, [sp, #12]
 80041be:	609a      	str	r2, [r3, #8]
      port->PUPDR   = (port->PUPDR & ~m2) | pupdr;
 80041c0:	9b03      	ldr	r3, [sp, #12]
 80041c2:	68da      	ldr	r2, [r3, #12]
 80041c4:	9b05      	ldr	r3, [sp, #20]
 80041c6:	43db      	mvns	r3, r3
 80041c8:	401a      	ands	r2, r3
 80041ca:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 80041cc:	431a      	orrs	r2, r3
 80041ce:	9b03      	ldr	r3, [sp, #12]
 80041d0:	60da      	str	r2, [r3, #12]
      if ((mode & PAL_STM32_MODE_MASK) == PAL_STM32_MODE_ALTERNATE) {
 80041d2:	9b01      	ldr	r3, [sp, #4]
 80041d4:	f003 0303 	and.w	r3, r3, #3
 80041d8:	2b02      	cmp	r3, #2
 80041da:	d11f      	bne.n	800421c <_pal_lld_setgroupmode+0xfc>
        /* If going in alternate mode then the alternate number is set
           before switching mode in order to avoid glitches.*/
        if (bit < 8)
 80041dc:	9b09      	ldr	r3, [sp, #36]	; 0x24
 80041de:	2b07      	cmp	r3, #7
 80041e0:	d809      	bhi.n	80041f6 <_pal_lld_setgroupmode+0xd6>
          port->AFRL = (port->AFRL & ~m4) | altrmask;
 80041e2:	9b03      	ldr	r3, [sp, #12]
 80041e4:	6a1a      	ldr	r2, [r3, #32]
 80041e6:	9b04      	ldr	r3, [sp, #16]
 80041e8:	43db      	mvns	r3, r3
 80041ea:	401a      	ands	r2, r3
 80041ec:	9b07      	ldr	r3, [sp, #28]
 80041ee:	431a      	orrs	r2, r3
 80041f0:	9b03      	ldr	r3, [sp, #12]
 80041f2:	621a      	str	r2, [r3, #32]
 80041f4:	e008      	b.n	8004208 <_pal_lld_setgroupmode+0xe8>
        else
          port->AFRH = (port->AFRH & ~m4) | altrmask;
 80041f6:	9b03      	ldr	r3, [sp, #12]
 80041f8:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 80041fa:	9b04      	ldr	r3, [sp, #16]
 80041fc:	43db      	mvns	r3, r3
 80041fe:	401a      	ands	r2, r3
 8004200:	9b07      	ldr	r3, [sp, #28]
 8004202:	431a      	orrs	r2, r3
 8004204:	9b03      	ldr	r3, [sp, #12]
 8004206:	625a      	str	r2, [r3, #36]	; 0x24
        port->MODER   = (port->MODER & ~m2) | moder;
 8004208:	9b03      	ldr	r3, [sp, #12]
 800420a:	681a      	ldr	r2, [r3, #0]
 800420c:	9b05      	ldr	r3, [sp, #20]
 800420e:	43db      	mvns	r3, r3
 8004210:	401a      	ands	r2, r3
 8004212:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8004214:	431a      	orrs	r2, r3
 8004216:	9b03      	ldr	r3, [sp, #12]
 8004218:	601a      	str	r2, [r3, #0]
 800421a:	e01e      	b.n	800425a <_pal_lld_setgroupmode+0x13a>
      }
      else {
        /* If going into a non-alternate mode then the mode is switched
           before setting the alternate mode in order to avoid glitches.*/
        port->MODER   = (port->MODER & ~m2) | moder;
 800421c:	9b03      	ldr	r3, [sp, #12]
 800421e:	681a      	ldr	r2, [r3, #0]
 8004220:	9b05      	ldr	r3, [sp, #20]
 8004222:	43db      	mvns	r3, r3
 8004224:	401a      	ands	r2, r3
 8004226:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8004228:	431a      	orrs	r2, r3
 800422a:	9b03      	ldr	r3, [sp, #12]
 800422c:	601a      	str	r2, [r3, #0]
        if (bit < 8)
 800422e:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8004230:	2b07      	cmp	r3, #7
 8004232:	d809      	bhi.n	8004248 <_pal_lld_setgroupmode+0x128>
          port->AFRL = (port->AFRL & ~m4) | altrmask;
 8004234:	9b03      	ldr	r3, [sp, #12]
 8004236:	6a1a      	ldr	r2, [r3, #32]
 8004238:	9b04      	ldr	r3, [sp, #16]
 800423a:	43db      	mvns	r3, r3
 800423c:	401a      	ands	r2, r3
 800423e:	9b07      	ldr	r3, [sp, #28]
 8004240:	431a      	orrs	r2, r3
 8004242:	9b03      	ldr	r3, [sp, #12]
 8004244:	621a      	str	r2, [r3, #32]
 8004246:	e008      	b.n	800425a <_pal_lld_setgroupmode+0x13a>
        else
          port->AFRH = (port->AFRH & ~m4) | altrmask;
 8004248:	9b03      	ldr	r3, [sp, #12]
 800424a:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 800424c:	9b04      	ldr	r3, [sp, #16]
 800424e:	43db      	mvns	r3, r3
 8004250:	401a      	ands	r2, r3
 8004252:	9b07      	ldr	r3, [sp, #28]
 8004254:	431a      	orrs	r2, r3
 8004256:	9b03      	ldr	r3, [sp, #12]
 8004258:	625a      	str	r2, [r3, #36]	; 0x24
      }
    }
    mask >>= 1;
 800425a:	9b02      	ldr	r3, [sp, #8]
 800425c:	085b      	lsrs	r3, r3, #1
 800425e:	9302      	str	r3, [sp, #8]
    if (!mask)
 8004260:	9b02      	ldr	r3, [sp, #8]
 8004262:	2b00      	cmp	r3, #0
 8004264:	d00f      	beq.n	8004286 <_pal_lld_setgroupmode+0x166>
      return;
    otyper <<= 1;
 8004266:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8004268:	005b      	lsls	r3, r3, #1
 800426a:	930c      	str	r3, [sp, #48]	; 0x30
    ospeedr <<= 2;
 800426c:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 800426e:	009b      	lsls	r3, r3, #2
 8004270:	930b      	str	r3, [sp, #44]	; 0x2c
    pupdr <<= 2;
 8004272:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8004274:	009b      	lsls	r3, r3, #2
 8004276:	930a      	str	r3, [sp, #40]	; 0x28
    moder <<= 2;
 8004278:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 800427a:	009b      	lsls	r3, r3, #2
 800427c:	930d      	str	r3, [sp, #52]	; 0x34
    bit++;
 800427e:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8004280:	3301      	adds	r3, #1
 8004282:	9309      	str	r3, [sp, #36]	; 0x24
 8004284:	e76a      	b.n	800415c <_pal_lld_setgroupmode+0x3c>
  }
}
 8004286:	b00e      	add	sp, #56	; 0x38
 8004288:	4770      	bx	lr
 800428a:	bf00      	nop
 800428c:	0000      	movs	r0, r0
	...

08004290 <port_lock.lto_priv.294>:
static inline void port_lock(void) {
 8004290:	b082      	sub	sp, #8
 8004292:	2320      	movs	r3, #32
 8004294:	9301      	str	r3, [sp, #4]
 8004296:	9b01      	ldr	r3, [sp, #4]
 8004298:	f383 8811 	msr	BASEPRI, r3
}
 800429c:	b002      	add	sp, #8
 800429e:	4770      	bx	lr

080042a0 <port_unlock.lto_priv.253>:
static inline void port_unlock(void) {
 80042a0:	b082      	sub	sp, #8
 80042a2:	2300      	movs	r3, #0
 80042a4:	9301      	str	r3, [sp, #4]
 80042a6:	9b01      	ldr	r3, [sp, #4]
 80042a8:	f383 8811 	msr	BASEPRI, r3
}
 80042ac:	b002      	add	sp, #8
 80042ae:	4770      	bx	lr

080042b0 <port_lock_from_isr.lto_priv.548>:
static inline void port_lock_from_isr(void) {
 80042b0:	b508      	push	{r3, lr}
  port_lock();
 80042b2:	f7ff ffed 	bl	8004290 <port_lock.lto_priv.294>
}
 80042b6:	bd08      	pop	{r3, pc}
	...

080042c0 <port_unlock_from_isr.lto_priv.536>:
static inline void port_unlock_from_isr(void) {
 80042c0:	b508      	push	{r3, lr}
  port_unlock();
 80042c2:	f7ff ffed 	bl	80042a0 <port_unlock.lto_priv.253>
}
 80042c6:	bd08      	pop	{r3, pc}
	...

080042d0 <chSysLockFromISR.lto_priv.521>:
static inline void chSysLockFromISR(void) {
 80042d0:	b508      	push	{r3, lr}
  port_lock_from_isr();
 80042d2:	f7ff ffed 	bl	80042b0 <port_lock_from_isr.lto_priv.548>
  _dbg_check_lock_from_isr();
 80042d6:	f002 f8db 	bl	8006490 <_dbg_check_lock_from_isr>
}
 80042da:	bd08      	pop	{r3, pc}
 80042dc:	0000      	movs	r0, r0
	...

080042e0 <chSysUnlockFromISR.lto_priv.512>:
static inline void chSysUnlockFromISR(void) {
 80042e0:	b508      	push	{r3, lr}
  _dbg_check_unlock_from_isr();
 80042e2:	f002 f8ed 	bl	80064c0 <_dbg_check_unlock_from_isr>
  port_unlock_from_isr();
 80042e6:	f7ff ffeb 	bl	80042c0 <port_unlock_from_isr.lto_priv.536>
}
 80042ea:	bd08      	pop	{r3, pc}
 80042ec:	0000      	movs	r0, r0
	...

080042f0 <osalSysLockFromISR.lto_priv.669>:
static inline void osalSysLockFromISR(void) {
 80042f0:	b508      	push	{r3, lr}
  chSysLockFromISR();
 80042f2:	f7ff ffed 	bl	80042d0 <chSysLockFromISR.lto_priv.521>
}
 80042f6:	bd08      	pop	{r3, pc}
	...

08004300 <osalSysUnlockFromISR.lto_priv.663>:
static inline void osalSysUnlockFromISR(void) {
 8004300:	b508      	push	{r3, lr}
  chSysUnlockFromISR();
 8004302:	f7ff ffed 	bl	80042e0 <chSysUnlockFromISR.lto_priv.512>
}
 8004306:	bd08      	pop	{r3, pc}
	...

08004310 <osalSysPolledDelayX>:
static inline void osalSysPolledDelayX(rtcnt_t cycles) {
 8004310:	b500      	push	{lr}
 8004312:	b083      	sub	sp, #12
 8004314:	9001      	str	r0, [sp, #4]
  chSysPolledDelayX(cycles);
 8004316:	9801      	ldr	r0, [sp, #4]
 8004318:	f002 f83a 	bl	8006390 <chSysPolledDelayX>
}
 800431c:	b003      	add	sp, #12
 800431e:	f85d fb04 	ldr.w	pc, [sp], #4
 8004322:	bf00      	nop
	...

08004330 <otg_core_reset>:

/*===========================================================================*/
/* Driver local functions.                                                   */
/*===========================================================================*/

static void otg_core_reset(USBDriver *usbp) {
 8004330:	b500      	push	{lr}
 8004332:	b085      	sub	sp, #20
 8004334:	9001      	str	r0, [sp, #4]
  stm32_otg_t *otgp = usbp->otg;
 8004336:	9b01      	ldr	r3, [sp, #4]
 8004338:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 800433a:	9303      	str	r3, [sp, #12]

  /* Wait AHB idle condition.*/
  while ((otgp->GRSTCTL & GRSTCTL_AHBIDL) == 0)
 800433c:	9b03      	ldr	r3, [sp, #12]
 800433e:	691b      	ldr	r3, [r3, #16]
 8004340:	2b00      	cmp	r3, #0
 8004342:	dafb      	bge.n	800433c <otg_core_reset+0xc>
    ;

  /* Core reset and delay of at least 3 PHY cycles.*/
  otgp->GRSTCTL = GRSTCTL_CSRST;
 8004344:	9b03      	ldr	r3, [sp, #12]
 8004346:	2201      	movs	r2, #1
 8004348:	611a      	str	r2, [r3, #16]
  osalSysPolledDelayX(12);
 800434a:	200c      	movs	r0, #12
 800434c:	f7ff ffe0 	bl	8004310 <osalSysPolledDelayX>
  while ((otgp->GRSTCTL & GRSTCTL_CSRST) != 0)
 8004350:	9b03      	ldr	r3, [sp, #12]
 8004352:	691b      	ldr	r3, [r3, #16]
 8004354:	f003 0301 	and.w	r3, r3, #1
 8004358:	2b00      	cmp	r3, #0
 800435a:	d1f9      	bne.n	8004350 <otg_core_reset+0x20>
    ;

  osalSysPolledDelayX(18);
 800435c:	2012      	movs	r0, #18
 800435e:	f7ff ffd7 	bl	8004310 <osalSysPolledDelayX>

  /* Wait AHB idle condition again.*/
  while ((otgp->GRSTCTL & GRSTCTL_AHBIDL) == 0)
 8004362:	9b03      	ldr	r3, [sp, #12]
 8004364:	691b      	ldr	r3, [r3, #16]
 8004366:	2b00      	cmp	r3, #0
 8004368:	dafb      	bge.n	8004362 <otg_core_reset+0x32>
    ;
}
 800436a:	b005      	add	sp, #20
 800436c:	f85d fb04 	ldr.w	pc, [sp], #4

08004370 <otg_disable_ep>:

static void otg_disable_ep(USBDriver *usbp) {
 8004370:	b084      	sub	sp, #16
 8004372:	9001      	str	r0, [sp, #4]
  stm32_otg_t *otgp = usbp->otg;
 8004374:	9b01      	ldr	r3, [sp, #4]
 8004376:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 8004378:	9302      	str	r3, [sp, #8]
  unsigned i;

  for (i = 0; i <= usbp->otgparams->num_endpoints; i++) {
 800437a:	2300      	movs	r3, #0
 800437c:	9303      	str	r3, [sp, #12]
 800437e:	e032      	b.n	80043e6 <otg_disable_ep+0x76>
    otgp->ie[i].DIEPCTL = 0;
 8004380:	9a02      	ldr	r2, [sp, #8]
 8004382:	9b03      	ldr	r3, [sp, #12]
 8004384:	3348      	adds	r3, #72	; 0x48
 8004386:	015b      	lsls	r3, r3, #5
 8004388:	4413      	add	r3, r2
 800438a:	2200      	movs	r2, #0
 800438c:	601a      	str	r2, [r3, #0]
    otgp->ie[i].DIEPTSIZ = 0;
 800438e:	9a02      	ldr	r2, [sp, #8]
 8004390:	9b03      	ldr	r3, [sp, #12]
 8004392:	015b      	lsls	r3, r3, #5
 8004394:	4413      	add	r3, r2
 8004396:	f503 6311 	add.w	r3, r3, #2320	; 0x910
 800439a:	2200      	movs	r2, #0
 800439c:	601a      	str	r2, [r3, #0]
    otgp->ie[i].DIEPINT = 0xFFFFFFFF;
 800439e:	9a02      	ldr	r2, [sp, #8]
 80043a0:	9b03      	ldr	r3, [sp, #12]
 80043a2:	015b      	lsls	r3, r3, #5
 80043a4:	4413      	add	r3, r2
 80043a6:	f603 1308 	addw	r3, r3, #2312	; 0x908
 80043aa:	f04f 32ff 	mov.w	r2, #4294967295
 80043ae:	601a      	str	r2, [r3, #0]

    otgp->oe[i].DOEPCTL = 0;
 80043b0:	9a02      	ldr	r2, [sp, #8]
 80043b2:	9b03      	ldr	r3, [sp, #12]
 80043b4:	3358      	adds	r3, #88	; 0x58
 80043b6:	015b      	lsls	r3, r3, #5
 80043b8:	4413      	add	r3, r2
 80043ba:	2200      	movs	r2, #0
 80043bc:	601a      	str	r2, [r3, #0]
    otgp->oe[i].DOEPTSIZ = 0;
 80043be:	9a02      	ldr	r2, [sp, #8]
 80043c0:	9b03      	ldr	r3, [sp, #12]
 80043c2:	015b      	lsls	r3, r3, #5
 80043c4:	4413      	add	r3, r2
 80043c6:	f503 6331 	add.w	r3, r3, #2832	; 0xb10
 80043ca:	2200      	movs	r2, #0
 80043cc:	601a      	str	r2, [r3, #0]
    otgp->oe[i].DOEPINT = 0xFFFFFFFF;
 80043ce:	9a02      	ldr	r2, [sp, #8]
 80043d0:	9b03      	ldr	r3, [sp, #12]
 80043d2:	015b      	lsls	r3, r3, #5
 80043d4:	4413      	add	r3, r2
 80043d6:	f603 3308 	addw	r3, r3, #2824	; 0xb08
 80043da:	f04f 32ff 	mov.w	r2, #4294967295
 80043de:	601a      	str	r2, [r3, #0]
  for (i = 0; i <= usbp->otgparams->num_endpoints; i++) {
 80043e0:	9b03      	ldr	r3, [sp, #12]
 80043e2:	3301      	adds	r3, #1
 80043e4:	9303      	str	r3, [sp, #12]
 80043e6:	9b01      	ldr	r3, [sp, #4]
 80043e8:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 80043ea:	689b      	ldr	r3, [r3, #8]
 80043ec:	9a03      	ldr	r2, [sp, #12]
 80043ee:	429a      	cmp	r2, r3
 80043f0:	d9c6      	bls.n	8004380 <otg_disable_ep+0x10>
  }
  otgp->DAINTMSK = DAINTMSK_OEPM(0) | DAINTMSK_IEPM(0);
 80043f2:	9b02      	ldr	r3, [sp, #8]
 80043f4:	f04f 1201 	mov.w	r2, #65537	; 0x10001
 80043f8:	f8c3 281c 	str.w	r2, [r3, #2076]	; 0x81c
}
 80043fc:	b004      	add	sp, #16
 80043fe:	4770      	bx	lr

08004400 <otg_rxfifo_flush>:

static void otg_rxfifo_flush(USBDriver *usbp) {
 8004400:	b500      	push	{lr}
 8004402:	b085      	sub	sp, #20
 8004404:	9001      	str	r0, [sp, #4]
  stm32_otg_t *otgp = usbp->otg;
 8004406:	9b01      	ldr	r3, [sp, #4]
 8004408:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 800440a:	9303      	str	r3, [sp, #12]

  otgp->GRSTCTL = GRSTCTL_RXFFLSH;
 800440c:	9b03      	ldr	r3, [sp, #12]
 800440e:	2210      	movs	r2, #16
 8004410:	611a      	str	r2, [r3, #16]
  while ((otgp->GRSTCTL & GRSTCTL_RXFFLSH) != 0)
 8004412:	9b03      	ldr	r3, [sp, #12]
 8004414:	691b      	ldr	r3, [r3, #16]
 8004416:	f003 0310 	and.w	r3, r3, #16
 800441a:	2b00      	cmp	r3, #0
 800441c:	d1f9      	bne.n	8004412 <otg_rxfifo_flush+0x12>
    ;
  /* Wait for 3 PHY Clocks.*/
  osalSysPolledDelayX(18);
 800441e:	2012      	movs	r0, #18
 8004420:	f7ff ff76 	bl	8004310 <osalSysPolledDelayX>
}
 8004424:	b005      	add	sp, #20
 8004426:	f85d fb04 	ldr.w	pc, [sp], #4
 800442a:	bf00      	nop
 800442c:	0000      	movs	r0, r0
	...

08004430 <otg_txfifo_flush>:

static void otg_txfifo_flush(USBDriver *usbp, uint32_t fifo) {
 8004430:	b500      	push	{lr}
 8004432:	b085      	sub	sp, #20
 8004434:	9001      	str	r0, [sp, #4]
 8004436:	9100      	str	r1, [sp, #0]
  stm32_otg_t *otgp = usbp->otg;
 8004438:	9b01      	ldr	r3, [sp, #4]
 800443a:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 800443c:	9303      	str	r3, [sp, #12]

  otgp->GRSTCTL = GRSTCTL_TXFNUM(fifo) | GRSTCTL_TXFFLSH;
 800443e:	9b00      	ldr	r3, [sp, #0]
 8004440:	019b      	lsls	r3, r3, #6
 8004442:	f043 0220 	orr.w	r2, r3, #32
 8004446:	9b03      	ldr	r3, [sp, #12]
 8004448:	611a      	str	r2, [r3, #16]
  while ((otgp->GRSTCTL & GRSTCTL_TXFFLSH) != 0)
 800444a:	9b03      	ldr	r3, [sp, #12]
 800444c:	691b      	ldr	r3, [r3, #16]
 800444e:	f003 0320 	and.w	r3, r3, #32
 8004452:	2b00      	cmp	r3, #0
 8004454:	d1f9      	bne.n	800444a <otg_txfifo_flush+0x1a>
    ;
  /* Wait for 3 PHY Clocks.*/
  osalSysPolledDelayX(18);
 8004456:	2012      	movs	r0, #18
 8004458:	f7ff ff5a 	bl	8004310 <osalSysPolledDelayX>
}
 800445c:	b005      	add	sp, #20
 800445e:	f85d fb04 	ldr.w	pc, [sp], #4
 8004462:	bf00      	nop
	...

08004470 <otg_ram_reset>:
 *
 * @param[in] usbp      pointer to the @p USBDriver object
 *
 * @notapi
 */
static void otg_ram_reset(USBDriver *usbp) {
 8004470:	b082      	sub	sp, #8
 8004472:	9001      	str	r0, [sp, #4]

  usbp->pmnext = usbp->otgparams->rx_fifo_size;
 8004474:	9b01      	ldr	r3, [sp, #4]
 8004476:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 8004478:	681a      	ldr	r2, [r3, #0]
 800447a:	9b01      	ldr	r3, [sp, #4]
 800447c:	675a      	str	r2, [r3, #116]	; 0x74
}
 800447e:	b002      	add	sp, #8
 8004480:	4770      	bx	lr
 8004482:	bf00      	nop
	...

08004490 <otg_ram_alloc>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] size      size of the packet buffer to allocate in words
 *
 * @notapi
 */
static uint32_t otg_ram_alloc(USBDriver *usbp, size_t size) {
 8004490:	b500      	push	{lr}
 8004492:	b085      	sub	sp, #20
 8004494:	9001      	str	r0, [sp, #4]
 8004496:	9100      	str	r1, [sp, #0]
  uint32_t next;

  next = usbp->pmnext;
 8004498:	9b01      	ldr	r3, [sp, #4]
 800449a:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 800449c:	9303      	str	r3, [sp, #12]
  usbp->pmnext += size;
 800449e:	9b01      	ldr	r3, [sp, #4]
 80044a0:	6f5a      	ldr	r2, [r3, #116]	; 0x74
 80044a2:	9b00      	ldr	r3, [sp, #0]
 80044a4:	441a      	add	r2, r3
 80044a6:	9b01      	ldr	r3, [sp, #4]
 80044a8:	675a      	str	r2, [r3, #116]	; 0x74
  osalDbgAssert(usbp->pmnext <= usbp->otgparams->otg_ram_size,
 80044aa:	9b01      	ldr	r3, [sp, #4]
 80044ac:	6f5a      	ldr	r2, [r3, #116]	; 0x74
 80044ae:	9b01      	ldr	r3, [sp, #4]
 80044b0:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 80044b2:	685b      	ldr	r3, [r3, #4]
 80044b4:	429a      	cmp	r2, r3
 80044b6:	d902      	bls.n	80044be <otg_ram_alloc+0x2e>
 80044b8:	4803      	ldr	r0, [pc, #12]	; (80044c8 <otg_ram_alloc+0x38>)
 80044ba:	f001 ff39 	bl	8006330 <chSysHalt>
                "OTG FIFO memory overflow");
  return next;
 80044be:	9b03      	ldr	r3, [sp, #12]
}
 80044c0:	4618      	mov	r0, r3
 80044c2:	b005      	add	sp, #20
 80044c4:	f85d fb04 	ldr.w	pc, [sp], #4
 80044c8:	08008ac0 	.word	0x08008ac0
 80044cc:	00000000 	.word	0x00000000

080044d0 <otg_fifo_write_from_buffer>:
 *
 * @notapi
 */
static void otg_fifo_write_from_buffer(volatile uint32_t *fifop,
                                       const uint8_t *buf,
                                       size_t n) {
 80044d0:	b500      	push	{lr}
 80044d2:	b085      	sub	sp, #20
 80044d4:	9003      	str	r0, [sp, #12]
 80044d6:	9102      	str	r1, [sp, #8]
 80044d8:	9201      	str	r2, [sp, #4]

  osalDbgAssert(n > 0, "is zero");
 80044da:	9b01      	ldr	r3, [sp, #4]
 80044dc:	2b00      	cmp	r3, #0
 80044de:	d102      	bne.n	80044e6 <otg_fifo_write_from_buffer+0x16>
 80044e0:	4809      	ldr	r0, [pc, #36]	; (8004508 <otg_fifo_write_from_buffer+0x38>)
 80044e2:	f001 ff25 	bl	8006330 <chSysHalt>

  while (true) {
    *fifop = *((uint32_t *)buf);
 80044e6:	9b02      	ldr	r3, [sp, #8]
 80044e8:	681a      	ldr	r2, [r3, #0]
 80044ea:	9b03      	ldr	r3, [sp, #12]
 80044ec:	601a      	str	r2, [r3, #0]
    if (n <= 4) {
 80044ee:	9b01      	ldr	r3, [sp, #4]
 80044f0:	2b04      	cmp	r3, #4
 80044f2:	d906      	bls.n	8004502 <otg_fifo_write_from_buffer+0x32>
      break;
    }
    n -= 4;
 80044f4:	9b01      	ldr	r3, [sp, #4]
 80044f6:	3b04      	subs	r3, #4
 80044f8:	9301      	str	r3, [sp, #4]
    buf += 4;
 80044fa:	9b02      	ldr	r3, [sp, #8]
 80044fc:	3304      	adds	r3, #4
 80044fe:	9302      	str	r3, [sp, #8]
 8004500:	e7f1      	b.n	80044e6 <otg_fifo_write_from_buffer+0x16>
  }
}
 8004502:	b005      	add	sp, #20
 8004504:	f85d fb04 	ldr.w	pc, [sp], #4
 8004508:	08008ad0 	.word	0x08008ad0
 800450c:	00000000 	.word	0x00000000

08004510 <otg_fifo_read_to_buffer>:
 * @notapi
 */
static void otg_fifo_read_to_buffer(volatile uint32_t *fifop,
                                    uint8_t *buf,
                                    size_t n,
                                    size_t max) {
 8004510:	b086      	sub	sp, #24
 8004512:	9003      	str	r0, [sp, #12]
 8004514:	9102      	str	r1, [sp, #8]
 8004516:	9201      	str	r2, [sp, #4]
 8004518:	9300      	str	r3, [sp, #0]
  uint32_t w = 0;
 800451a:	2300      	movs	r3, #0
 800451c:	9305      	str	r3, [sp, #20]
  size_t i = 0;
 800451e:	2300      	movs	r3, #0
 8004520:	9304      	str	r3, [sp, #16]
 8004522:	e017      	b.n	8004554 <otg_fifo_read_to_buffer+0x44>

  while (i < n) {
    if ((i & 3) == 0){
 8004524:	9b04      	ldr	r3, [sp, #16]
 8004526:	f003 0303 	and.w	r3, r3, #3
 800452a:	2b00      	cmp	r3, #0
 800452c:	d102      	bne.n	8004534 <otg_fifo_read_to_buffer+0x24>
      w = *fifop;
 800452e:	9b03      	ldr	r3, [sp, #12]
 8004530:	681b      	ldr	r3, [r3, #0]
 8004532:	9305      	str	r3, [sp, #20]
    }
    if (i < max) {
 8004534:	9a04      	ldr	r2, [sp, #16]
 8004536:	9b00      	ldr	r3, [sp, #0]
 8004538:	429a      	cmp	r2, r3
 800453a:	d208      	bcs.n	800454e <otg_fifo_read_to_buffer+0x3e>
      *buf++ = (uint8_t)w;
 800453c:	9b02      	ldr	r3, [sp, #8]
 800453e:	1c5a      	adds	r2, r3, #1
 8004540:	9202      	str	r2, [sp, #8]
 8004542:	9a05      	ldr	r2, [sp, #20]
 8004544:	b2d2      	uxtb	r2, r2
 8004546:	701a      	strb	r2, [r3, #0]
      w >>= 8;
 8004548:	9b05      	ldr	r3, [sp, #20]
 800454a:	0a1b      	lsrs	r3, r3, #8
 800454c:	9305      	str	r3, [sp, #20]
    }
    i++;
 800454e:	9b04      	ldr	r3, [sp, #16]
 8004550:	3301      	adds	r3, #1
 8004552:	9304      	str	r3, [sp, #16]
  while (i < n) {
 8004554:	9a04      	ldr	r2, [sp, #16]
 8004556:	9b01      	ldr	r3, [sp, #4]
 8004558:	429a      	cmp	r2, r3
 800455a:	d3e3      	bcc.n	8004524 <otg_fifo_read_to_buffer+0x14>
  }
}
 800455c:	b006      	add	sp, #24
 800455e:	4770      	bx	lr

08004560 <otg_rxfifo_handler>:
 *
 * @param[in] usbp      pointer to the @p USBDriver object
 *
 * @notapi
 */
static void otg_rxfifo_handler(USBDriver *usbp) {
 8004560:	b510      	push	{r4, lr}
 8004562:	b086      	sub	sp, #24
 8004564:	9001      	str	r0, [sp, #4]
  uint32_t sts, cnt, ep;

  /* Popping the event word out of the RX FIFO.*/
  sts = usbp->otg->GRXSTSP;
 8004566:	9b01      	ldr	r3, [sp, #4]
 8004568:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 800456a:	6a1b      	ldr	r3, [r3, #32]
 800456c:	9305      	str	r3, [sp, #20]

  /* Event details.*/
  cnt = (sts & GRXSTSP_BCNT_MASK) >> GRXSTSP_BCNT_OFF;
 800456e:	9b05      	ldr	r3, [sp, #20]
 8004570:	091b      	lsrs	r3, r3, #4
 8004572:	f3c3 030a 	ubfx	r3, r3, #0, #11
 8004576:	9304      	str	r3, [sp, #16]
  ep  = (sts & GRXSTSP_EPNUM_MASK) >> GRXSTSP_EPNUM_OFF;
 8004578:	9b05      	ldr	r3, [sp, #20]
 800457a:	f003 030f 	and.w	r3, r3, #15
 800457e:	9303      	str	r3, [sp, #12]

  switch (sts & GRXSTSP_PKTSTS_MASK) {
 8004580:	9b05      	ldr	r3, [sp, #20]
 8004582:	f403 13f0 	and.w	r3, r3, #1966080	; 0x1e0000
 8004586:	f5b3 2fc0 	cmp.w	r3, #393216	; 0x60000
 800458a:	d065      	beq.n	8004658 <otg_rxfifo_handler+0xf8>
 800458c:	f5b3 2fc0 	cmp.w	r3, #393216	; 0x60000
 8004590:	d806      	bhi.n	80045a0 <otg_rxfifo_handler+0x40>
 8004592:	f5b3 3f00 	cmp.w	r3, #131072	; 0x20000
 8004596:	d061      	beq.n	800465c <otg_rxfifo_handler+0xfc>
 8004598:	f5b3 2f80 	cmp.w	r3, #262144	; 0x40000
 800459c:	d016      	beq.n	80045cc <otg_rxfifo_handler+0x6c>
 800459e:	e060      	b.n	8004662 <otg_rxfifo_handler+0x102>
 80045a0:	f5b3 2f00 	cmp.w	r3, #524288	; 0x80000
 80045a4:	d05c      	beq.n	8004660 <otg_rxfifo_handler+0x100>
 80045a6:	f5b3 2f40 	cmp.w	r3, #786432	; 0xc0000
 80045aa:	d15a      	bne.n	8004662 <otg_rxfifo_handler+0x102>
  case GRXSTSP_SETUP_DATA:
    otg_fifo_read_to_buffer(usbp->otg->FIFO[0], usbp->epc[ep]->setup_buf,
 80045ac:	9b01      	ldr	r3, [sp, #4]
 80045ae:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 80045b0:	f503 5080 	add.w	r0, r3, #4096	; 0x1000
 80045b4:	9a01      	ldr	r2, [sp, #4]
 80045b6:	9b03      	ldr	r3, [sp, #12]
 80045b8:	3302      	adds	r3, #2
 80045ba:	009b      	lsls	r3, r3, #2
 80045bc:	4413      	add	r3, r2
 80045be:	685b      	ldr	r3, [r3, #4]
 80045c0:	6a19      	ldr	r1, [r3, #32]
 80045c2:	2308      	movs	r3, #8
 80045c4:	9a04      	ldr	r2, [sp, #16]
 80045c6:	f7ff ffa3 	bl	8004510 <otg_fifo_read_to_buffer>
 80045ca:	e04a      	b.n	8004662 <otg_rxfifo_handler+0x102>
                            cnt, 8);
    break;
  case GRXSTSP_SETUP_COMP:
    break;
  case GRXSTSP_OUT_DATA:
    otg_fifo_read_to_buffer(usbp->otg->FIFO[0],
 80045cc:	9b01      	ldr	r3, [sp, #4]
 80045ce:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 80045d0:	f503 5080 	add.w	r0, r3, #4096	; 0x1000
                            usbp->epc[ep]->out_state->rxbuf,
 80045d4:	9a01      	ldr	r2, [sp, #4]
 80045d6:	9b03      	ldr	r3, [sp, #12]
 80045d8:	3302      	adds	r3, #2
 80045da:	009b      	lsls	r3, r3, #2
 80045dc:	4413      	add	r3, r2
 80045de:	685b      	ldr	r3, [r3, #4]
 80045e0:	699b      	ldr	r3, [r3, #24]
    otg_fifo_read_to_buffer(usbp->otg->FIFO[0],
 80045e2:	689c      	ldr	r4, [r3, #8]
                            cnt,
                            usbp->epc[ep]->out_state->rxsize -
 80045e4:	9a01      	ldr	r2, [sp, #4]
 80045e6:	9b03      	ldr	r3, [sp, #12]
 80045e8:	3302      	adds	r3, #2
 80045ea:	009b      	lsls	r3, r3, #2
 80045ec:	4413      	add	r3, r2
 80045ee:	685b      	ldr	r3, [r3, #4]
 80045f0:	699b      	ldr	r3, [r3, #24]
 80045f2:	681a      	ldr	r2, [r3, #0]
                            usbp->epc[ep]->out_state->rxcnt);
 80045f4:	9901      	ldr	r1, [sp, #4]
 80045f6:	9b03      	ldr	r3, [sp, #12]
 80045f8:	3302      	adds	r3, #2
 80045fa:	009b      	lsls	r3, r3, #2
 80045fc:	440b      	add	r3, r1
 80045fe:	685b      	ldr	r3, [r3, #4]
 8004600:	699b      	ldr	r3, [r3, #24]
 8004602:	685b      	ldr	r3, [r3, #4]
    otg_fifo_read_to_buffer(usbp->otg->FIFO[0],
 8004604:	1ad3      	subs	r3, r2, r3
 8004606:	9a04      	ldr	r2, [sp, #16]
 8004608:	4621      	mov	r1, r4
 800460a:	f7ff ff81 	bl	8004510 <otg_fifo_read_to_buffer>
    usbp->epc[ep]->out_state->rxbuf += cnt;
 800460e:	9a01      	ldr	r2, [sp, #4]
 8004610:	9b03      	ldr	r3, [sp, #12]
 8004612:	3302      	adds	r3, #2
 8004614:	009b      	lsls	r3, r3, #2
 8004616:	4413      	add	r3, r2
 8004618:	685b      	ldr	r3, [r3, #4]
 800461a:	699b      	ldr	r3, [r3, #24]
 800461c:	6899      	ldr	r1, [r3, #8]
 800461e:	9a01      	ldr	r2, [sp, #4]
 8004620:	9b03      	ldr	r3, [sp, #12]
 8004622:	3302      	adds	r3, #2
 8004624:	009b      	lsls	r3, r3, #2
 8004626:	4413      	add	r3, r2
 8004628:	685b      	ldr	r3, [r3, #4]
 800462a:	699b      	ldr	r3, [r3, #24]
 800462c:	9a04      	ldr	r2, [sp, #16]
 800462e:	440a      	add	r2, r1
 8004630:	609a      	str	r2, [r3, #8]
    usbp->epc[ep]->out_state->rxcnt += cnt;
 8004632:	9a01      	ldr	r2, [sp, #4]
 8004634:	9b03      	ldr	r3, [sp, #12]
 8004636:	3302      	adds	r3, #2
 8004638:	009b      	lsls	r3, r3, #2
 800463a:	4413      	add	r3, r2
 800463c:	685b      	ldr	r3, [r3, #4]
 800463e:	699b      	ldr	r3, [r3, #24]
 8004640:	6859      	ldr	r1, [r3, #4]
 8004642:	9a01      	ldr	r2, [sp, #4]
 8004644:	9b03      	ldr	r3, [sp, #12]
 8004646:	3302      	adds	r3, #2
 8004648:	009b      	lsls	r3, r3, #2
 800464a:	4413      	add	r3, r2
 800464c:	685b      	ldr	r3, [r3, #4]
 800464e:	699b      	ldr	r3, [r3, #24]
 8004650:	9a04      	ldr	r2, [sp, #16]
 8004652:	440a      	add	r2, r1
 8004654:	605a      	str	r2, [r3, #4]
 8004656:	e004      	b.n	8004662 <otg_rxfifo_handler+0x102>
    break;
  case GRXSTSP_OUT_COMP:
 8004658:	bf00      	nop
 800465a:	e002      	b.n	8004662 <otg_rxfifo_handler+0x102>
    break;
  case GRXSTSP_OUT_GLOBAL_NAK:
 800465c:	bf00      	nop
 800465e:	e000      	b.n	8004662 <otg_rxfifo_handler+0x102>
  case GRXSTSP_SETUP_COMP:
 8004660:	bf00      	nop
    break;
  default:
    break;
  }
}
 8004662:	b006      	add	sp, #24
 8004664:	bd10      	pop	{r4, pc}
 8004666:	bf00      	nop
	...

08004670 <otg_txfifo_handler>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number
 *
 * @notapi
 */
static bool otg_txfifo_handler(USBDriver *usbp, usbep_t ep) {
 8004670:	b500      	push	{lr}
 8004672:	b085      	sub	sp, #20
 8004674:	9001      	str	r0, [sp, #4]
 8004676:	460b      	mov	r3, r1
 8004678:	f88d 3003 	strb.w	r3, [sp, #3]
  /* The TXFIFO is filled until there is space and data to be transmitted.*/
  while (true) {
    uint32_t n;

    /* Transaction end condition.*/
    if (usbp->epc[ep]->in_state->txcnt >= usbp->epc[ep]->in_state->txsize) {
 800467c:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8004680:	9a01      	ldr	r2, [sp, #4]
 8004682:	3302      	adds	r3, #2
 8004684:	009b      	lsls	r3, r3, #2
 8004686:	4413      	add	r3, r2
 8004688:	685b      	ldr	r3, [r3, #4]
 800468a:	695b      	ldr	r3, [r3, #20]
 800468c:	685a      	ldr	r2, [r3, #4]
 800468e:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8004692:	9901      	ldr	r1, [sp, #4]
 8004694:	3302      	adds	r3, #2
 8004696:	009b      	lsls	r3, r3, #2
 8004698:	440b      	add	r3, r1
 800469a:	685b      	ldr	r3, [r3, #4]
 800469c:	695b      	ldr	r3, [r3, #20]
 800469e:	681b      	ldr	r3, [r3, #0]
 80046a0:	429a      	cmp	r2, r3
 80046a2:	d310      	bcc.n	80046c6 <otg_txfifo_handler+0x56>
#if 1
      usbp->otg->DIEPEMPMSK &= ~DIEPEMPMSK_INEPTXFEM(ep);
 80046a4:	9b01      	ldr	r3, [sp, #4]
 80046a6:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 80046a8:	f8d3 1834 	ldr.w	r1, [r3, #2100]	; 0x834
 80046ac:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80046b0:	2201      	movs	r2, #1
 80046b2:	fa02 f303 	lsl.w	r3, r2, r3
 80046b6:	43da      	mvns	r2, r3
 80046b8:	9b01      	ldr	r3, [sp, #4]
 80046ba:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 80046bc:	400a      	ands	r2, r1
 80046be:	f8c3 2834 	str.w	r2, [r3, #2100]	; 0x834
#endif
      return true;
 80046c2:	2301      	movs	r3, #1
 80046c4:	e075      	b.n	80047b2 <otg_txfifo_handler+0x142>
    }

    /* Number of bytes remaining in current transaction.*/
    n = usbp->epc[ep]->in_state->txsize - usbp->epc[ep]->in_state->txcnt;
 80046c6:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80046ca:	9a01      	ldr	r2, [sp, #4]
 80046cc:	3302      	adds	r3, #2
 80046ce:	009b      	lsls	r3, r3, #2
 80046d0:	4413      	add	r3, r2
 80046d2:	685b      	ldr	r3, [r3, #4]
 80046d4:	695b      	ldr	r3, [r3, #20]
 80046d6:	681a      	ldr	r2, [r3, #0]
 80046d8:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80046dc:	9901      	ldr	r1, [sp, #4]
 80046de:	3302      	adds	r3, #2
 80046e0:	009b      	lsls	r3, r3, #2
 80046e2:	440b      	add	r3, r1
 80046e4:	685b      	ldr	r3, [r3, #4]
 80046e6:	695b      	ldr	r3, [r3, #20]
 80046e8:	685b      	ldr	r3, [r3, #4]
 80046ea:	1ad3      	subs	r3, r2, r3
 80046ec:	9303      	str	r3, [sp, #12]
    if (n > usbp->epc[ep]->in_maxsize)
 80046ee:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80046f2:	9a01      	ldr	r2, [sp, #4]
 80046f4:	3302      	adds	r3, #2
 80046f6:	009b      	lsls	r3, r3, #2
 80046f8:	4413      	add	r3, r2
 80046fa:	685b      	ldr	r3, [r3, #4]
 80046fc:	8a1b      	ldrh	r3, [r3, #16]
 80046fe:	461a      	mov	r2, r3
 8004700:	9b03      	ldr	r3, [sp, #12]
 8004702:	4293      	cmp	r3, r2
 8004704:	d908      	bls.n	8004718 <otg_txfifo_handler+0xa8>
      n = usbp->epc[ep]->in_maxsize;
 8004706:	f89d 3003 	ldrb.w	r3, [sp, #3]
 800470a:	9a01      	ldr	r2, [sp, #4]
 800470c:	3302      	adds	r3, #2
 800470e:	009b      	lsls	r3, r3, #2
 8004710:	4413      	add	r3, r2
 8004712:	685b      	ldr	r3, [r3, #4]
 8004714:	8a1b      	ldrh	r3, [r3, #16]
 8004716:	9303      	str	r3, [sp, #12]

    /* Checks if in the TXFIFO there is enough space to accommodate the
       next packet.*/
    if (((usbp->otg->ie[ep].DTXFSTS & DTXFSTS_INEPTFSAV_MASK) * 4) < n)
 8004718:	9b01      	ldr	r3, [sp, #4]
 800471a:	6eda      	ldr	r2, [r3, #108]	; 0x6c
 800471c:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8004720:	015b      	lsls	r3, r3, #5
 8004722:	4413      	add	r3, r2
 8004724:	f603 1318 	addw	r3, r3, #2328	; 0x918
 8004728:	681b      	ldr	r3, [r3, #0]
 800472a:	b29b      	uxth	r3, r3
 800472c:	009b      	lsls	r3, r3, #2
 800472e:	9a03      	ldr	r2, [sp, #12]
 8004730:	429a      	cmp	r2, r3
 8004732:	d901      	bls.n	8004738 <otg_txfifo_handler+0xc8>
      return false;
 8004734:	2300      	movs	r3, #0
 8004736:	e03c      	b.n	80047b2 <otg_txfifo_handler+0x142>

#if STM32_USB_OTGFIFO_FILL_BASEPRI
    __set_BASEPRI(CORTEX_PRIO_MASK(STM32_USB_OTGFIFO_FILL_BASEPRI));
#endif
    otg_fifo_write_from_buffer(usbp->otg->FIFO[ep],
 8004738:	9b01      	ldr	r3, [sp, #4]
 800473a:	6eda      	ldr	r2, [r3, #108]	; 0x6c
 800473c:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8004740:	3301      	adds	r3, #1
 8004742:	031b      	lsls	r3, r3, #12
 8004744:	18d0      	adds	r0, r2, r3
                               usbp->epc[ep]->in_state->txbuf,
 8004746:	f89d 3003 	ldrb.w	r3, [sp, #3]
 800474a:	9a01      	ldr	r2, [sp, #4]
 800474c:	3302      	adds	r3, #2
 800474e:	009b      	lsls	r3, r3, #2
 8004750:	4413      	add	r3, r2
 8004752:	685b      	ldr	r3, [r3, #4]
 8004754:	695b      	ldr	r3, [r3, #20]
    otg_fifo_write_from_buffer(usbp->otg->FIFO[ep],
 8004756:	689b      	ldr	r3, [r3, #8]
 8004758:	9a03      	ldr	r2, [sp, #12]
 800475a:	4619      	mov	r1, r3
 800475c:	f7ff feb8 	bl	80044d0 <otg_fifo_write_from_buffer>
                               n);
    usbp->epc[ep]->in_state->txbuf += n;
 8004760:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8004764:	9a01      	ldr	r2, [sp, #4]
 8004766:	3302      	adds	r3, #2
 8004768:	009b      	lsls	r3, r3, #2
 800476a:	4413      	add	r3, r2
 800476c:	685b      	ldr	r3, [r3, #4]
 800476e:	695b      	ldr	r3, [r3, #20]
 8004770:	6899      	ldr	r1, [r3, #8]
 8004772:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8004776:	9a01      	ldr	r2, [sp, #4]
 8004778:	3302      	adds	r3, #2
 800477a:	009b      	lsls	r3, r3, #2
 800477c:	4413      	add	r3, r2
 800477e:	685b      	ldr	r3, [r3, #4]
 8004780:	695b      	ldr	r3, [r3, #20]
 8004782:	9a03      	ldr	r2, [sp, #12]
 8004784:	440a      	add	r2, r1
 8004786:	609a      	str	r2, [r3, #8]
    usbp->epc[ep]->in_state->txcnt += n;
 8004788:	f89d 3003 	ldrb.w	r3, [sp, #3]
 800478c:	9a01      	ldr	r2, [sp, #4]
 800478e:	3302      	adds	r3, #2
 8004790:	009b      	lsls	r3, r3, #2
 8004792:	4413      	add	r3, r2
 8004794:	685b      	ldr	r3, [r3, #4]
 8004796:	695b      	ldr	r3, [r3, #20]
 8004798:	6859      	ldr	r1, [r3, #4]
 800479a:	f89d 3003 	ldrb.w	r3, [sp, #3]
 800479e:	9a01      	ldr	r2, [sp, #4]
 80047a0:	3302      	adds	r3, #2
 80047a2:	009b      	lsls	r3, r3, #2
 80047a4:	4413      	add	r3, r2
 80047a6:	685b      	ldr	r3, [r3, #4]
 80047a8:	695b      	ldr	r3, [r3, #20]
 80047aa:	9a03      	ldr	r2, [sp, #12]
 80047ac:	440a      	add	r2, r1
 80047ae:	605a      	str	r2, [r3, #4]
 80047b0:	e764      	b.n	800467c <otg_txfifo_handler+0xc>
#if STM32_USB_OTGFIFO_FILL_BASEPRI
  __set_BASEPRI(0);
#endif
  }
}
 80047b2:	4618      	mov	r0, r3
 80047b4:	b005      	add	sp, #20
 80047b6:	f85d fb04 	ldr.w	pc, [sp], #4
 80047ba:	bf00      	nop
 80047bc:	0000      	movs	r0, r0
	...

080047c0 <otg_epin_handler>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number
 *
 * @notapi
 */
static void otg_epin_handler(USBDriver *usbp, usbep_t ep) {
 80047c0:	b500      	push	{lr}
 80047c2:	b087      	sub	sp, #28
 80047c4:	9001      	str	r0, [sp, #4]
 80047c6:	460b      	mov	r3, r1
 80047c8:	f88d 3003 	strb.w	r3, [sp, #3]
  stm32_otg_t *otgp = usbp->otg;
 80047cc:	9b01      	ldr	r3, [sp, #4]
 80047ce:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 80047d0:	9305      	str	r3, [sp, #20]
  uint32_t epint = otgp->ie[ep].DIEPINT;
 80047d2:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80047d6:	9a05      	ldr	r2, [sp, #20]
 80047d8:	015b      	lsls	r3, r3, #5
 80047da:	4413      	add	r3, r2
 80047dc:	f603 1308 	addw	r3, r3, #2312	; 0x908
 80047e0:	681b      	ldr	r3, [r3, #0]
 80047e2:	9304      	str	r3, [sp, #16]

  otgp->ie[ep].DIEPINT = epint;
 80047e4:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80047e8:	9a05      	ldr	r2, [sp, #20]
 80047ea:	015b      	lsls	r3, r3, #5
 80047ec:	4413      	add	r3, r2
 80047ee:	f603 1308 	addw	r3, r3, #2312	; 0x908
 80047f2:	9a04      	ldr	r2, [sp, #16]
 80047f4:	601a      	str	r2, [r3, #0]

  if (epint & DIEPINT_TOC) {
    /* Timeouts not handled yet, not sure how to handle.*/
  }
  if ((epint & DIEPINT_XFRC) && (otgp->DIEPMSK & DIEPMSK_XFRCM)) {
 80047f6:	9b04      	ldr	r3, [sp, #16]
 80047f8:	f003 0301 	and.w	r3, r3, #1
 80047fc:	2b00      	cmp	r3, #0
 80047fe:	d051      	beq.n	80048a4 <otg_epin_handler+0xe4>
 8004800:	9b05      	ldr	r3, [sp, #20]
 8004802:	f8d3 3810 	ldr.w	r3, [r3, #2064]	; 0x810
 8004806:	f003 0301 	and.w	r3, r3, #1
 800480a:	2b00      	cmp	r3, #0
 800480c:	d04a      	beq.n	80048a4 <otg_epin_handler+0xe4>
    /* Transmit transfer complete.*/
    USBInEndpointState *isp = usbp->epc[ep]->in_state;
 800480e:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8004812:	9a01      	ldr	r2, [sp, #4]
 8004814:	3302      	adds	r3, #2
 8004816:	009b      	lsls	r3, r3, #2
 8004818:	4413      	add	r3, r2
 800481a:	685b      	ldr	r3, [r3, #4]
 800481c:	695b      	ldr	r3, [r3, #20]
 800481e:	9303      	str	r3, [sp, #12]

    if (isp->txsize < isp->totsize) {
 8004820:	9b03      	ldr	r3, [sp, #12]
 8004822:	681a      	ldr	r2, [r3, #0]
 8004824:	9b03      	ldr	r3, [sp, #12]
 8004826:	68db      	ldr	r3, [r3, #12]
 8004828:	429a      	cmp	r2, r3
 800482a:	d214      	bcs.n	8004856 <otg_epin_handler+0x96>
      /* In case the transaction covered only part of the total transfer
         then another transaction is immediately started in order to
         cover the remaining.*/
      isp->txsize = isp->totsize - isp->txsize;
 800482c:	9b03      	ldr	r3, [sp, #12]
 800482e:	68da      	ldr	r2, [r3, #12]
 8004830:	9b03      	ldr	r3, [sp, #12]
 8004832:	681b      	ldr	r3, [r3, #0]
 8004834:	1ad2      	subs	r2, r2, r3
 8004836:	9b03      	ldr	r3, [sp, #12]
 8004838:	601a      	str	r2, [r3, #0]
      isp->txcnt  = 0;
 800483a:	9b03      	ldr	r3, [sp, #12]
 800483c:	2200      	movs	r2, #0
 800483e:	605a      	str	r2, [r3, #4]
      osalSysLockFromISR();
 8004840:	f7ff fd56 	bl	80042f0 <osalSysLockFromISR.lto_priv.669>
      usb_lld_start_in(usbp, ep);
 8004844:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8004848:	4619      	mov	r1, r3
 800484a:	9801      	ldr	r0, [sp, #4]
 800484c:	f000 feb0 	bl	80055b0 <usb_lld_start_in>
      osalSysUnlockFromISR();
 8004850:	f7ff fd56 	bl	8004300 <osalSysUnlockFromISR.lto_priv.663>
 8004854:	e026      	b.n	80048a4 <otg_epin_handler+0xe4>
    }
    else {
      /* End on IN transfer.*/
      _usb_isr_invoke_in_cb(usbp, ep);
 8004856:	9b01      	ldr	r3, [sp, #4]
 8004858:	891b      	ldrh	r3, [r3, #8]
 800485a:	b21a      	sxth	r2, r3
 800485c:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8004860:	2101      	movs	r1, #1
 8004862:	fa01 f303 	lsl.w	r3, r1, r3
 8004866:	b21b      	sxth	r3, r3
 8004868:	43db      	mvns	r3, r3
 800486a:	b21b      	sxth	r3, r3
 800486c:	4013      	ands	r3, r2
 800486e:	b21b      	sxth	r3, r3
 8004870:	b29a      	uxth	r2, r3
 8004872:	9b01      	ldr	r3, [sp, #4]
 8004874:	811a      	strh	r2, [r3, #8]
 8004876:	f89d 3003 	ldrb.w	r3, [sp, #3]
 800487a:	9a01      	ldr	r2, [sp, #4]
 800487c:	3302      	adds	r3, #2
 800487e:	009b      	lsls	r3, r3, #2
 8004880:	4413      	add	r3, r2
 8004882:	685b      	ldr	r3, [r3, #4]
 8004884:	689b      	ldr	r3, [r3, #8]
 8004886:	2b00      	cmp	r3, #0
 8004888:	d00c      	beq.n	80048a4 <otg_epin_handler+0xe4>
 800488a:	f89d 3003 	ldrb.w	r3, [sp, #3]
 800488e:	9a01      	ldr	r2, [sp, #4]
 8004890:	3302      	adds	r3, #2
 8004892:	009b      	lsls	r3, r3, #2
 8004894:	4413      	add	r3, r2
 8004896:	685b      	ldr	r3, [r3, #4]
 8004898:	689b      	ldr	r3, [r3, #8]
 800489a:	f89d 2003 	ldrb.w	r2, [sp, #3]
 800489e:	4611      	mov	r1, r2
 80048a0:	9801      	ldr	r0, [sp, #4]
 80048a2:	4798      	blx	r3
    }
  }
  if ((epint & DIEPINT_TXFE) &&
 80048a4:	9b04      	ldr	r3, [sp, #16]
 80048a6:	f003 0380 	and.w	r3, r3, #128	; 0x80
 80048aa:	2b00      	cmp	r3, #0
 80048ac:	d010      	beq.n	80048d0 <otg_epin_handler+0x110>
      (otgp->DIEPEMPMSK & DIEPEMPMSK_INEPTXFEM(ep))) {
 80048ae:	9b05      	ldr	r3, [sp, #20]
 80048b0:	f8d3 2834 	ldr.w	r2, [r3, #2100]	; 0x834
 80048b4:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80048b8:	2101      	movs	r1, #1
 80048ba:	fa01 f303 	lsl.w	r3, r1, r3
 80048be:	4013      	ands	r3, r2
  if ((epint & DIEPINT_TXFE) &&
 80048c0:	2b00      	cmp	r3, #0
 80048c2:	d005      	beq.n	80048d0 <otg_epin_handler+0x110>
    /* TX FIFO empty or emptying.*/
    otg_txfifo_handler(usbp, ep);
 80048c4:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80048c8:	4619      	mov	r1, r3
 80048ca:	9801      	ldr	r0, [sp, #4]
 80048cc:	f7ff fed0 	bl	8004670 <otg_txfifo_handler>
  }
}
 80048d0:	b007      	add	sp, #28
 80048d2:	f85d fb04 	ldr.w	pc, [sp], #4
 80048d6:	bf00      	nop
	...

080048e0 <otg_epout_handler>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number
 *
 * @notapi
 */
static void otg_epout_handler(USBDriver *usbp, usbep_t ep) {
 80048e0:	b500      	push	{lr}
 80048e2:	b087      	sub	sp, #28
 80048e4:	9001      	str	r0, [sp, #4]
 80048e6:	460b      	mov	r3, r1
 80048e8:	f88d 3003 	strb.w	r3, [sp, #3]
  stm32_otg_t *otgp = usbp->otg;
 80048ec:	9b01      	ldr	r3, [sp, #4]
 80048ee:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 80048f0:	9305      	str	r3, [sp, #20]
  uint32_t epint = otgp->oe[ep].DOEPINT;
 80048f2:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80048f6:	9a05      	ldr	r2, [sp, #20]
 80048f8:	015b      	lsls	r3, r3, #5
 80048fa:	4413      	add	r3, r2
 80048fc:	f603 3308 	addw	r3, r3, #2824	; 0xb08
 8004900:	681b      	ldr	r3, [r3, #0]
 8004902:	9304      	str	r3, [sp, #16]

  /* Resets all EP IRQ sources.*/
  otgp->oe[ep].DOEPINT = epint;
 8004904:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8004908:	9a05      	ldr	r2, [sp, #20]
 800490a:	015b      	lsls	r3, r3, #5
 800490c:	4413      	add	r3, r2
 800490e:	f603 3308 	addw	r3, r3, #2824	; 0xb08
 8004912:	9a04      	ldr	r2, [sp, #16]
 8004914:	601a      	str	r2, [r3, #0]

  if ((epint & DOEPINT_STUP) && (otgp->DOEPMSK & DOEPMSK_STUPM)) {
 8004916:	9b04      	ldr	r3, [sp, #16]
 8004918:	f003 0308 	and.w	r3, r3, #8
 800491c:	2b00      	cmp	r3, #0
 800491e:	d013      	beq.n	8004948 <otg_epout_handler+0x68>
 8004920:	9b05      	ldr	r3, [sp, #20]
 8004922:	f8d3 3814 	ldr.w	r3, [r3, #2068]	; 0x814
 8004926:	f003 0308 	and.w	r3, r3, #8
 800492a:	2b00      	cmp	r3, #0
 800492c:	d00c      	beq.n	8004948 <otg_epout_handler+0x68>
    /* Setup packets handling, setup packets are handled using a
       specific callback.*/
    _usb_isr_invoke_setup_cb(usbp, ep);
 800492e:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8004932:	9a01      	ldr	r2, [sp, #4]
 8004934:	3302      	adds	r3, #2
 8004936:	009b      	lsls	r3, r3, #2
 8004938:	4413      	add	r3, r2
 800493a:	685b      	ldr	r3, [r3, #4]
 800493c:	685b      	ldr	r3, [r3, #4]
 800493e:	f89d 2003 	ldrb.w	r2, [sp, #3]
 8004942:	4611      	mov	r1, r2
 8004944:	9801      	ldr	r0, [sp, #4]
 8004946:	4798      	blx	r3
  }

  if ((epint & DOEPINT_XFRC) && (otgp->DOEPMSK & DOEPMSK_XFRCM)) {
 8004948:	9b04      	ldr	r3, [sp, #16]
 800494a:	f003 0301 	and.w	r3, r3, #1
 800494e:	2b00      	cmp	r3, #0
 8004950:	d066      	beq.n	8004a20 <otg_epout_handler+0x140>
 8004952:	9b05      	ldr	r3, [sp, #20]
 8004954:	f8d3 3814 	ldr.w	r3, [r3, #2068]	; 0x814
 8004958:	f003 0301 	and.w	r3, r3, #1
 800495c:	2b00      	cmp	r3, #0
 800495e:	d05f      	beq.n	8004a20 <otg_epout_handler+0x140>
    USBOutEndpointState *osp;

    /* OUT state structure pointer for this endpoint.*/
    osp = usbp->epc[ep]->out_state;
 8004960:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8004964:	9a01      	ldr	r2, [sp, #4]
 8004966:	3302      	adds	r3, #2
 8004968:	009b      	lsls	r3, r3, #2
 800496a:	4413      	add	r3, r2
 800496c:	685b      	ldr	r3, [r3, #4]
 800496e:	699b      	ldr	r3, [r3, #24]
 8004970:	9303      	str	r3, [sp, #12]

    /* EP0 requires special handling.*/
    if (ep == 0) {
 8004972:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8004976:	2b00      	cmp	r3, #0
 8004978:	d12b      	bne.n	80049d2 <otg_epout_handler+0xf2>
#endif

      /* In case the transaction covered only part of the total transfer
         then another transaction is immediately started in order to
         cover the remaining.*/
      if (((osp->rxcnt % usbp->epc[ep]->out_maxsize) == 0) &&
 800497a:	9b03      	ldr	r3, [sp, #12]
 800497c:	685a      	ldr	r2, [r3, #4]
 800497e:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8004982:	9901      	ldr	r1, [sp, #4]
 8004984:	3302      	adds	r3, #2
 8004986:	009b      	lsls	r3, r3, #2
 8004988:	440b      	add	r3, r1
 800498a:	685b      	ldr	r3, [r3, #4]
 800498c:	8a5b      	ldrh	r3, [r3, #18]
 800498e:	fbb2 f1f3 	udiv	r1, r2, r3
 8004992:	fb03 f301 	mul.w	r3, r3, r1
 8004996:	1ad3      	subs	r3, r2, r3
 8004998:	2b00      	cmp	r3, #0
 800499a:	d11a      	bne.n	80049d2 <otg_epout_handler+0xf2>
          (osp->rxsize < osp->totsize)) {
 800499c:	9b03      	ldr	r3, [sp, #12]
 800499e:	681a      	ldr	r2, [r3, #0]
 80049a0:	9b03      	ldr	r3, [sp, #12]
 80049a2:	68db      	ldr	r3, [r3, #12]
      if (((osp->rxcnt % usbp->epc[ep]->out_maxsize) == 0) &&
 80049a4:	429a      	cmp	r2, r3
 80049a6:	d214      	bcs.n	80049d2 <otg_epout_handler+0xf2>
        osp->rxsize = osp->totsize - osp->rxsize;
 80049a8:	9b03      	ldr	r3, [sp, #12]
 80049aa:	68da      	ldr	r2, [r3, #12]
 80049ac:	9b03      	ldr	r3, [sp, #12]
 80049ae:	681b      	ldr	r3, [r3, #0]
 80049b0:	1ad2      	subs	r2, r2, r3
 80049b2:	9b03      	ldr	r3, [sp, #12]
 80049b4:	601a      	str	r2, [r3, #0]
        osp->rxcnt  = 0;
 80049b6:	9b03      	ldr	r3, [sp, #12]
 80049b8:	2200      	movs	r2, #0
 80049ba:	605a      	str	r2, [r3, #4]
        osalSysLockFromISR();
 80049bc:	f7ff fc98 	bl	80042f0 <osalSysLockFromISR.lto_priv.669>
        usb_lld_start_out(usbp, ep);
 80049c0:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80049c4:	4619      	mov	r1, r3
 80049c6:	9801      	ldr	r0, [sp, #4]
 80049c8:	f000 fd52 	bl	8005470 <usb_lld_start_out>
        osalSysUnlockFromISR();
 80049cc:	f7ff fc98 	bl	8004300 <osalSysUnlockFromISR.lto_priv.663>
 80049d0:	e026      	b.n	8004a20 <otg_epout_handler+0x140>
        return;
      }
    }

    /* End on OUT transfer.*/
    _usb_isr_invoke_out_cb(usbp, ep);
 80049d2:	9b01      	ldr	r3, [sp, #4]
 80049d4:	895b      	ldrh	r3, [r3, #10]
 80049d6:	b21a      	sxth	r2, r3
 80049d8:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80049dc:	2101      	movs	r1, #1
 80049de:	fa01 f303 	lsl.w	r3, r1, r3
 80049e2:	b21b      	sxth	r3, r3
 80049e4:	43db      	mvns	r3, r3
 80049e6:	b21b      	sxth	r3, r3
 80049e8:	4013      	ands	r3, r2
 80049ea:	b21b      	sxth	r3, r3
 80049ec:	b29a      	uxth	r2, r3
 80049ee:	9b01      	ldr	r3, [sp, #4]
 80049f0:	815a      	strh	r2, [r3, #10]
 80049f2:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80049f6:	9a01      	ldr	r2, [sp, #4]
 80049f8:	3302      	adds	r3, #2
 80049fa:	009b      	lsls	r3, r3, #2
 80049fc:	4413      	add	r3, r2
 80049fe:	685b      	ldr	r3, [r3, #4]
 8004a00:	68db      	ldr	r3, [r3, #12]
 8004a02:	2b00      	cmp	r3, #0
 8004a04:	d00c      	beq.n	8004a20 <otg_epout_handler+0x140>
 8004a06:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8004a0a:	9a01      	ldr	r2, [sp, #4]
 8004a0c:	3302      	adds	r3, #2
 8004a0e:	009b      	lsls	r3, r3, #2
 8004a10:	4413      	add	r3, r2
 8004a12:	685b      	ldr	r3, [r3, #4]
 8004a14:	68db      	ldr	r3, [r3, #12]
 8004a16:	f89d 2003 	ldrb.w	r2, [sp, #3]
 8004a1a:	4611      	mov	r1, r2
 8004a1c:	9801      	ldr	r0, [sp, #4]
 8004a1e:	4798      	blx	r3
  }
}
 8004a20:	b007      	add	sp, #28
 8004a22:	f85d fb04 	ldr.w	pc, [sp], #4
 8004a26:	bf00      	nop
	...

08004a30 <otg_isoc_in_failed_handler>:
 *
 * @param[in] usbp      pointer to the @p USBDriver object
 *
 * @notapi
 */
static void otg_isoc_in_failed_handler(USBDriver *usbp) {
 8004a30:	b500      	push	{lr}
 8004a32:	b085      	sub	sp, #20
 8004a34:	9001      	str	r0, [sp, #4]
  usbep_t ep;
  stm32_otg_t *otgp = usbp->otg;
 8004a36:	9b01      	ldr	r3, [sp, #4]
 8004a38:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 8004a3a:	9302      	str	r3, [sp, #8]

  for (ep = 0; ep <= usbp->otgparams->num_endpoints; ep++) {
 8004a3c:	2300      	movs	r3, #0
 8004a3e:	f88d 300f 	strb.w	r3, [sp, #15]
 8004a42:	e065      	b.n	8004b10 <otg_isoc_in_failed_handler+0xe0>
    if (((otgp->ie[ep].DIEPCTL & DIEPCTL_EPTYP_MASK) == DIEPCTL_EPTYP_ISO) &&
 8004a44:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8004a48:	9a02      	ldr	r2, [sp, #8]
 8004a4a:	3348      	adds	r3, #72	; 0x48
 8004a4c:	015b      	lsls	r3, r3, #5
 8004a4e:	4413      	add	r3, r2
 8004a50:	681b      	ldr	r3, [r3, #0]
 8004a52:	f403 2340 	and.w	r3, r3, #786432	; 0xc0000
 8004a56:	f5b3 2f80 	cmp.w	r3, #262144	; 0x40000
 8004a5a:	d154      	bne.n	8004b06 <otg_isoc_in_failed_handler+0xd6>
        ((otgp->ie[ep].DIEPCTL & DIEPCTL_EPENA) != 0)) {
 8004a5c:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8004a60:	9a02      	ldr	r2, [sp, #8]
 8004a62:	3348      	adds	r3, #72	; 0x48
 8004a64:	015b      	lsls	r3, r3, #5
 8004a66:	4413      	add	r3, r2
 8004a68:	681b      	ldr	r3, [r3, #0]
    if (((otgp->ie[ep].DIEPCTL & DIEPCTL_EPTYP_MASK) == DIEPCTL_EPTYP_ISO) &&
 8004a6a:	2b00      	cmp	r3, #0
 8004a6c:	da4b      	bge.n	8004b06 <otg_isoc_in_failed_handler+0xd6>
      /* Endpoint enabled -> ISOC IN transfer failed */
      /* Disable endpoint */
      otgp->ie[ep].DIEPCTL |= (DIEPCTL_EPDIS | DIEPCTL_SNAK);
 8004a6e:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8004a72:	9a02      	ldr	r2, [sp, #8]
 8004a74:	3348      	adds	r3, #72	; 0x48
 8004a76:	015b      	lsls	r3, r3, #5
 8004a78:	4413      	add	r3, r2
 8004a7a:	681a      	ldr	r2, [r3, #0]
 8004a7c:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8004a80:	f042 4290 	orr.w	r2, r2, #1207959552	; 0x48000000
 8004a84:	9902      	ldr	r1, [sp, #8]
 8004a86:	3348      	adds	r3, #72	; 0x48
 8004a88:	015b      	lsls	r3, r3, #5
 8004a8a:	440b      	add	r3, r1
 8004a8c:	601a      	str	r2, [r3, #0]
      while (otgp->ie[ep].DIEPCTL & DIEPCTL_EPENA)
 8004a8e:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8004a92:	9a02      	ldr	r2, [sp, #8]
 8004a94:	3348      	adds	r3, #72	; 0x48
 8004a96:	015b      	lsls	r3, r3, #5
 8004a98:	4413      	add	r3, r2
 8004a9a:	681b      	ldr	r3, [r3, #0]
 8004a9c:	2b00      	cmp	r3, #0
 8004a9e:	dbf6      	blt.n	8004a8e <otg_isoc_in_failed_handler+0x5e>
        ;

      /* Flush FIFO */
      otg_txfifo_flush(usbp, ep);
 8004aa0:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8004aa4:	4619      	mov	r1, r3
 8004aa6:	9801      	ldr	r0, [sp, #4]
 8004aa8:	f7ff fcc2 	bl	8004430 <otg_txfifo_flush>

      /* Prepare data for next frame */
      _usb_isr_invoke_in_cb(usbp, ep);
 8004aac:	9b01      	ldr	r3, [sp, #4]
 8004aae:	891b      	ldrh	r3, [r3, #8]
 8004ab0:	b21a      	sxth	r2, r3
 8004ab2:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8004ab6:	2101      	movs	r1, #1
 8004ab8:	fa01 f303 	lsl.w	r3, r1, r3
 8004abc:	b21b      	sxth	r3, r3
 8004abe:	43db      	mvns	r3, r3
 8004ac0:	b21b      	sxth	r3, r3
 8004ac2:	4013      	ands	r3, r2
 8004ac4:	b21b      	sxth	r3, r3
 8004ac6:	b29a      	uxth	r2, r3
 8004ac8:	9b01      	ldr	r3, [sp, #4]
 8004aca:	811a      	strh	r2, [r3, #8]
 8004acc:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8004ad0:	9a01      	ldr	r2, [sp, #4]
 8004ad2:	3302      	adds	r3, #2
 8004ad4:	009b      	lsls	r3, r3, #2
 8004ad6:	4413      	add	r3, r2
 8004ad8:	685b      	ldr	r3, [r3, #4]
 8004ada:	689b      	ldr	r3, [r3, #8]
 8004adc:	2b00      	cmp	r3, #0
 8004ade:	d00c      	beq.n	8004afa <otg_isoc_in_failed_handler+0xca>
 8004ae0:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8004ae4:	9a01      	ldr	r2, [sp, #4]
 8004ae6:	3302      	adds	r3, #2
 8004ae8:	009b      	lsls	r3, r3, #2
 8004aea:	4413      	add	r3, r2
 8004aec:	685b      	ldr	r3, [r3, #4]
 8004aee:	689b      	ldr	r3, [r3, #8]
 8004af0:	f89d 200f 	ldrb.w	r2, [sp, #15]
 8004af4:	4611      	mov	r1, r2
 8004af6:	9801      	ldr	r0, [sp, #4]
 8004af8:	4798      	blx	r3

      /* TX FIFO empty or emptying.*/
      otg_txfifo_handler(usbp, ep);
 8004afa:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8004afe:	4619      	mov	r1, r3
 8004b00:	9801      	ldr	r0, [sp, #4]
 8004b02:	f7ff fdb5 	bl	8004670 <otg_txfifo_handler>
  for (ep = 0; ep <= usbp->otgparams->num_endpoints; ep++) {
 8004b06:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8004b0a:	3301      	adds	r3, #1
 8004b0c:	f88d 300f 	strb.w	r3, [sp, #15]
 8004b10:	f89d 200f 	ldrb.w	r2, [sp, #15]
 8004b14:	9b01      	ldr	r3, [sp, #4]
 8004b16:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 8004b18:	689b      	ldr	r3, [r3, #8]
 8004b1a:	429a      	cmp	r2, r3
 8004b1c:	d992      	bls.n	8004a44 <otg_isoc_in_failed_handler+0x14>
    }
  }
}
 8004b1e:	b005      	add	sp, #20
 8004b20:	f85d fb04 	ldr.w	pc, [sp], #4
	...

08004b30 <otg_isoc_out_failed_handler>:
 *
 * @param[in] usbp      pointer to the @p USBDriver object
 *
 * @notapi
 */
static void otg_isoc_out_failed_handler(USBDriver *usbp) {
 8004b30:	b500      	push	{lr}
 8004b32:	b085      	sub	sp, #20
 8004b34:	9001      	str	r0, [sp, #4]
  usbep_t ep;
  stm32_otg_t *otgp = usbp->otg;
 8004b36:	9b01      	ldr	r3, [sp, #4]
 8004b38:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 8004b3a:	9302      	str	r3, [sp, #8]

  for (ep = 0; ep <= usbp->otgparams->num_endpoints; ep++) {
 8004b3c:	2300      	movs	r3, #0
 8004b3e:	f88d 300f 	strb.w	r3, [sp, #15]
 8004b42:	e040      	b.n	8004bc6 <otg_isoc_out_failed_handler+0x96>
    if (((otgp->oe[ep].DOEPCTL & DOEPCTL_EPTYP_MASK) == DOEPCTL_EPTYP_ISO) &&
 8004b44:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8004b48:	9a02      	ldr	r2, [sp, #8]
 8004b4a:	3358      	adds	r3, #88	; 0x58
 8004b4c:	015b      	lsls	r3, r3, #5
 8004b4e:	4413      	add	r3, r2
 8004b50:	681b      	ldr	r3, [r3, #0]
 8004b52:	f403 2340 	and.w	r3, r3, #786432	; 0xc0000
 8004b56:	f5b3 2f80 	cmp.w	r3, #262144	; 0x40000
 8004b5a:	d12f      	bne.n	8004bbc <otg_isoc_out_failed_handler+0x8c>
        ((otgp->oe[ep].DOEPCTL & DOEPCTL_EPENA) != 0)) {
 8004b5c:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8004b60:	9a02      	ldr	r2, [sp, #8]
 8004b62:	3358      	adds	r3, #88	; 0x58
 8004b64:	015b      	lsls	r3, r3, #5
 8004b66:	4413      	add	r3, r2
 8004b68:	681b      	ldr	r3, [r3, #0]
    if (((otgp->oe[ep].DOEPCTL & DOEPCTL_EPTYP_MASK) == DOEPCTL_EPTYP_ISO) &&
 8004b6a:	2b00      	cmp	r3, #0
 8004b6c:	da26      	bge.n	8004bbc <otg_isoc_out_failed_handler+0x8c>
      /* FIXME: Core stucks here */
      /*otgp->oe[ep].DOEPCTL |= (DOEPCTL_EPDIS | DOEPCTL_SNAK);
      while (otgp->oe[ep].DOEPCTL & DOEPCTL_EPENA)
        ;*/
      /* Prepare transfer for next frame */
      _usb_isr_invoke_out_cb(usbp, ep);
 8004b6e:	9b01      	ldr	r3, [sp, #4]
 8004b70:	895b      	ldrh	r3, [r3, #10]
 8004b72:	b21a      	sxth	r2, r3
 8004b74:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8004b78:	2101      	movs	r1, #1
 8004b7a:	fa01 f303 	lsl.w	r3, r1, r3
 8004b7e:	b21b      	sxth	r3, r3
 8004b80:	43db      	mvns	r3, r3
 8004b82:	b21b      	sxth	r3, r3
 8004b84:	4013      	ands	r3, r2
 8004b86:	b21b      	sxth	r3, r3
 8004b88:	b29a      	uxth	r2, r3
 8004b8a:	9b01      	ldr	r3, [sp, #4]
 8004b8c:	815a      	strh	r2, [r3, #10]
 8004b8e:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8004b92:	9a01      	ldr	r2, [sp, #4]
 8004b94:	3302      	adds	r3, #2
 8004b96:	009b      	lsls	r3, r3, #2
 8004b98:	4413      	add	r3, r2
 8004b9a:	685b      	ldr	r3, [r3, #4]
 8004b9c:	68db      	ldr	r3, [r3, #12]
 8004b9e:	2b00      	cmp	r3, #0
 8004ba0:	d00c      	beq.n	8004bbc <otg_isoc_out_failed_handler+0x8c>
 8004ba2:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8004ba6:	9a01      	ldr	r2, [sp, #4]
 8004ba8:	3302      	adds	r3, #2
 8004baa:	009b      	lsls	r3, r3, #2
 8004bac:	4413      	add	r3, r2
 8004bae:	685b      	ldr	r3, [r3, #4]
 8004bb0:	68db      	ldr	r3, [r3, #12]
 8004bb2:	f89d 200f 	ldrb.w	r2, [sp, #15]
 8004bb6:	4611      	mov	r1, r2
 8004bb8:	9801      	ldr	r0, [sp, #4]
 8004bba:	4798      	blx	r3
  for (ep = 0; ep <= usbp->otgparams->num_endpoints; ep++) {
 8004bbc:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8004bc0:	3301      	adds	r3, #1
 8004bc2:	f88d 300f 	strb.w	r3, [sp, #15]
 8004bc6:	f89d 200f 	ldrb.w	r2, [sp, #15]
 8004bca:	9b01      	ldr	r3, [sp, #4]
 8004bcc:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 8004bce:	689b      	ldr	r3, [r3, #8]
 8004bd0:	429a      	cmp	r2, r3
 8004bd2:	d9b7      	bls.n	8004b44 <otg_isoc_out_failed_handler+0x14>
    }
  }
}
 8004bd4:	b005      	add	sp, #20
 8004bd6:	f85d fb04 	ldr.w	pc, [sp], #4
 8004bda:	bf00      	nop
 8004bdc:	0000      	movs	r0, r0
	...

08004be0 <usb_lld_serve_interrupt>:
 *
 * @param[in] usbp      pointer to the @p USBDriver object
 *
 * @notapi
 */
static void usb_lld_serve_interrupt(USBDriver *usbp) {
 8004be0:	b500      	push	{lr}
 8004be2:	b087      	sub	sp, #28
 8004be4:	9001      	str	r0, [sp, #4]
  stm32_otg_t *otgp = usbp->otg;
 8004be6:	9b01      	ldr	r3, [sp, #4]
 8004be8:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 8004bea:	9305      	str	r3, [sp, #20]
  uint32_t sts, src;

  sts  = otgp->GINTSTS;
 8004bec:	9b05      	ldr	r3, [sp, #20]
 8004bee:	695b      	ldr	r3, [r3, #20]
 8004bf0:	9304      	str	r3, [sp, #16]
  sts &= otgp->GINTMSK;
 8004bf2:	9b05      	ldr	r3, [sp, #20]
 8004bf4:	699b      	ldr	r3, [r3, #24]
 8004bf6:	9a04      	ldr	r2, [sp, #16]
 8004bf8:	4013      	ands	r3, r2
 8004bfa:	9304      	str	r3, [sp, #16]
  otgp->GINTSTS = sts;
 8004bfc:	9b05      	ldr	r3, [sp, #20]
 8004bfe:	9a04      	ldr	r2, [sp, #16]
 8004c00:	615a      	str	r2, [r3, #20]

  /* Reset interrupt handling.*/
  if (sts & GINTSTS_USBRST) {
 8004c02:	9b04      	ldr	r3, [sp, #16]
 8004c04:	f403 5380 	and.w	r3, r3, #4096	; 0x1000
 8004c08:	2b00      	cmp	r3, #0
 8004c0a:	d003      	beq.n	8004c14 <usb_lld_serve_interrupt+0x34>
    /* Default reset action.*/
    _usb_reset(usbp);
 8004c0c:	9801      	ldr	r0, [sp, #4]
 8004c0e:	f7fe fb97 	bl	8003340 <_usb_reset>
 8004c12:	e0e2      	b.n	8004dda <usb_lld_serve_interrupt+0x1fa>
    /* Preventing execution of more handlers, the core has been reset.*/
    return;
  }

  /* Wake-up handling.*/
  if (sts & GINTSTS_WKUPINT) {
 8004c14:	9b04      	ldr	r3, [sp, #16]
 8004c16:	2b00      	cmp	r3, #0
 8004c18:	da19      	bge.n	8004c4e <usb_lld_serve_interrupt+0x6e>
    /* If clocks are gated off, turn them back on (may be the case if
       coming out of suspend mode).*/
    if (otgp->PCGCCTL & (PCGCCTL_STPPCLK | PCGCCTL_GATEHCLK)) {
 8004c1a:	9b05      	ldr	r3, [sp, #20]
 8004c1c:	f8d3 3e00 	ldr.w	r3, [r3, #3584]	; 0xe00
 8004c20:	f003 0303 	and.w	r3, r3, #3
 8004c24:	2b00      	cmp	r3, #0
 8004c26:	d007      	beq.n	8004c38 <usb_lld_serve_interrupt+0x58>
      /* Set to zero to un-gate the USB core clocks.*/
      otgp->PCGCCTL &= ~(PCGCCTL_STPPCLK | PCGCCTL_GATEHCLK);
 8004c28:	9b05      	ldr	r3, [sp, #20]
 8004c2a:	f8d3 3e00 	ldr.w	r3, [r3, #3584]	; 0xe00
 8004c2e:	f023 0203 	bic.w	r2, r3, #3
 8004c32:	9b05      	ldr	r3, [sp, #20]
 8004c34:	f8c3 2e00 	str.w	r2, [r3, #3584]	; 0xe00
    }

    /* Clear the Remote Wake-up Signaling.*/
    otgp->DCTL &= ~DCTL_RWUSIG;
 8004c38:	9b05      	ldr	r3, [sp, #20]
 8004c3a:	f8d3 3804 	ldr.w	r3, [r3, #2052]	; 0x804
 8004c3e:	f023 0201 	bic.w	r2, r3, #1
 8004c42:	9b05      	ldr	r3, [sp, #20]
 8004c44:	f8c3 2804 	str.w	r2, [r3, #2052]	; 0x804

    _usb_wakeup(usbp);
 8004c48:	9801      	ldr	r0, [sp, #4]
 8004c4a:	f7fe fbd9 	bl	8003400 <_usb_wakeup>
  }

  /* Suspend handling.*/
  if (sts & GINTSTS_USBSUSP) {
 8004c4e:	9b04      	ldr	r3, [sp, #16]
 8004c50:	f403 6300 	and.w	r3, r3, #2048	; 0x800
 8004c54:	2b00      	cmp	r3, #0
 8004c56:	d002      	beq.n	8004c5e <usb_lld_serve_interrupt+0x7e>
    /* Default suspend action.*/
    _usb_suspend(usbp);
 8004c58:	9801      	ldr	r0, [sp, #4]
 8004c5a:	f7fe fbb1 	bl	80033c0 <_usb_suspend>
  }

  /* Enumeration done.*/
  if (sts & GINTSTS_ENUMDNE) {
 8004c5e:	9b04      	ldr	r3, [sp, #16]
 8004c60:	f403 5300 	and.w	r3, r3, #8192	; 0x2000
 8004c64:	2b00      	cmp	r3, #0
 8004c66:	d017      	beq.n	8004c98 <usb_lld_serve_interrupt+0xb8>
    /* Full or High speed timing selection.*/
    if ((otgp->DSTS & DSTS_ENUMSPD_MASK) == DSTS_ENUMSPD_HS_480) {
 8004c68:	9b05      	ldr	r3, [sp, #20]
 8004c6a:	f8d3 3808 	ldr.w	r3, [r3, #2056]	; 0x808
 8004c6e:	f003 0306 	and.w	r3, r3, #6
 8004c72:	2b00      	cmp	r3, #0
 8004c74:	d108      	bne.n	8004c88 <usb_lld_serve_interrupt+0xa8>
      otgp->GUSBCFG = (otgp->GUSBCFG & ~(GUSBCFG_TRDT_MASK)) |
 8004c76:	9b05      	ldr	r3, [sp, #20]
 8004c78:	68db      	ldr	r3, [r3, #12]
 8004c7a:	f423 5370 	bic.w	r3, r3, #15360	; 0x3c00
 8004c7e:	f443 5210 	orr.w	r2, r3, #9216	; 0x2400
 8004c82:	9b05      	ldr	r3, [sp, #20]
 8004c84:	60da      	str	r2, [r3, #12]
 8004c86:	e007      	b.n	8004c98 <usb_lld_serve_interrupt+0xb8>
                      GUSBCFG_TRDT(TRDT_VALUE_HS);
    }
    else {
      otgp->GUSBCFG = (otgp->GUSBCFG & ~(GUSBCFG_TRDT_MASK)) |
 8004c88:	9b05      	ldr	r3, [sp, #20]
 8004c8a:	68db      	ldr	r3, [r3, #12]
 8004c8c:	f423 5370 	bic.w	r3, r3, #15360	; 0x3c00
 8004c90:	f443 52a0 	orr.w	r2, r3, #5120	; 0x1400
 8004c94:	9b05      	ldr	r3, [sp, #20]
 8004c96:	60da      	str	r2, [r3, #12]
                      GUSBCFG_TRDT(TRDT_VALUE_FS);
    }
  }

  /* SOF interrupt handling.*/
  if (sts & GINTSTS_SOF) {
 8004c98:	9b04      	ldr	r3, [sp, #16]
 8004c9a:	f003 0308 	and.w	r3, r3, #8
 8004c9e:	2b00      	cmp	r3, #0
 8004ca0:	d009      	beq.n	8004cb6 <usb_lld_serve_interrupt+0xd6>
    _usb_isr_invoke_sof_cb(usbp);
 8004ca2:	9b01      	ldr	r3, [sp, #4]
 8004ca4:	685b      	ldr	r3, [r3, #4]
 8004ca6:	68db      	ldr	r3, [r3, #12]
 8004ca8:	2b00      	cmp	r3, #0
 8004caa:	d004      	beq.n	8004cb6 <usb_lld_serve_interrupt+0xd6>
 8004cac:	9b01      	ldr	r3, [sp, #4]
 8004cae:	685b      	ldr	r3, [r3, #4]
 8004cb0:	68db      	ldr	r3, [r3, #12]
 8004cb2:	9801      	ldr	r0, [sp, #4]
 8004cb4:	4798      	blx	r3
  }

  /* Isochronous IN failed handling */
  if (sts & GINTSTS_IISOIXFR) {
 8004cb6:	9b04      	ldr	r3, [sp, #16]
 8004cb8:	f403 1380 	and.w	r3, r3, #1048576	; 0x100000
 8004cbc:	2b00      	cmp	r3, #0
 8004cbe:	d002      	beq.n	8004cc6 <usb_lld_serve_interrupt+0xe6>
    otg_isoc_in_failed_handler(usbp);
 8004cc0:	9801      	ldr	r0, [sp, #4]
 8004cc2:	f7ff feb5 	bl	8004a30 <otg_isoc_in_failed_handler>
  }

  /* Isochronous OUT failed handling */
  if (sts & GINTSTS_IISOOXFR) {
 8004cc6:	9b04      	ldr	r3, [sp, #16]
 8004cc8:	f403 1300 	and.w	r3, r3, #2097152	; 0x200000
 8004ccc:	2b00      	cmp	r3, #0
 8004cce:	d002      	beq.n	8004cd6 <usb_lld_serve_interrupt+0xf6>
    otg_isoc_out_failed_handler(usbp);
 8004cd0:	9801      	ldr	r0, [sp, #4]
 8004cd2:	f7ff ff2d 	bl	8004b30 <otg_isoc_out_failed_handler>
  }

  /* Performing the whole FIFO emptying in the ISR, it is advised to keep
     this IRQ at a very low priority level.*/
  if ((sts & GINTSTS_RXFLVL) != 0U) {
 8004cd6:	9b04      	ldr	r3, [sp, #16]
 8004cd8:	f003 0310 	and.w	r3, r3, #16
 8004cdc:	2b00      	cmp	r3, #0
 8004cde:	d002      	beq.n	8004ce6 <usb_lld_serve_interrupt+0x106>
    otg_rxfifo_handler(usbp);
 8004ce0:	9801      	ldr	r0, [sp, #4]
 8004ce2:	f7ff fc3d 	bl	8004560 <otg_rxfifo_handler>
  }

  /* IN/OUT endpoints event handling.*/
  src = otgp->DAINT;
 8004ce6:	9b05      	ldr	r3, [sp, #20]
 8004ce8:	f8d3 3818 	ldr.w	r3, [r3, #2072]	; 0x818
 8004cec:	9303      	str	r3, [sp, #12]
  if (sts & GINTSTS_OEPINT) {
 8004cee:	9b04      	ldr	r3, [sp, #16]
 8004cf0:	f403 2300 	and.w	r3, r3, #524288	; 0x80000
 8004cf4:	2b00      	cmp	r3, #0
 8004cf6:	d035      	beq.n	8004d64 <usb_lld_serve_interrupt+0x184>
    if (src & (1 << 16))
 8004cf8:	9b03      	ldr	r3, [sp, #12]
 8004cfa:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
 8004cfe:	2b00      	cmp	r3, #0
 8004d00:	d003      	beq.n	8004d0a <usb_lld_serve_interrupt+0x12a>
      otg_epout_handler(usbp, 0);
 8004d02:	2100      	movs	r1, #0
 8004d04:	9801      	ldr	r0, [sp, #4]
 8004d06:	f7ff fdeb 	bl	80048e0 <otg_epout_handler>
    if (src & (1 << 17))
 8004d0a:	9b03      	ldr	r3, [sp, #12]
 8004d0c:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 8004d10:	2b00      	cmp	r3, #0
 8004d12:	d003      	beq.n	8004d1c <usb_lld_serve_interrupt+0x13c>
      otg_epout_handler(usbp, 1);
 8004d14:	2101      	movs	r1, #1
 8004d16:	9801      	ldr	r0, [sp, #4]
 8004d18:	f7ff fde2 	bl	80048e0 <otg_epout_handler>
    if (src & (1 << 18))
 8004d1c:	9b03      	ldr	r3, [sp, #12]
 8004d1e:	f403 2380 	and.w	r3, r3, #262144	; 0x40000
 8004d22:	2b00      	cmp	r3, #0
 8004d24:	d003      	beq.n	8004d2e <usb_lld_serve_interrupt+0x14e>
      otg_epout_handler(usbp, 2);
 8004d26:	2102      	movs	r1, #2
 8004d28:	9801      	ldr	r0, [sp, #4]
 8004d2a:	f7ff fdd9 	bl	80048e0 <otg_epout_handler>
    if (src & (1 << 19))
 8004d2e:	9b03      	ldr	r3, [sp, #12]
 8004d30:	f403 2300 	and.w	r3, r3, #524288	; 0x80000
 8004d34:	2b00      	cmp	r3, #0
 8004d36:	d003      	beq.n	8004d40 <usb_lld_serve_interrupt+0x160>
      otg_epout_handler(usbp, 3);
 8004d38:	2103      	movs	r1, #3
 8004d3a:	9801      	ldr	r0, [sp, #4]
 8004d3c:	f7ff fdd0 	bl	80048e0 <otg_epout_handler>
#if USB_MAX_ENDPOINTS >= 4
    if (src & (1 << 20))
 8004d40:	9b03      	ldr	r3, [sp, #12]
 8004d42:	f403 1380 	and.w	r3, r3, #1048576	; 0x100000
 8004d46:	2b00      	cmp	r3, #0
 8004d48:	d003      	beq.n	8004d52 <usb_lld_serve_interrupt+0x172>
      otg_epout_handler(usbp, 4);
 8004d4a:	2104      	movs	r1, #4
 8004d4c:	9801      	ldr	r0, [sp, #4]
 8004d4e:	f7ff fdc7 	bl	80048e0 <otg_epout_handler>
#endif
#if USB_MAX_ENDPOINTS >= 5
    if (src & (1 << 21))
 8004d52:	9b03      	ldr	r3, [sp, #12]
 8004d54:	f403 1300 	and.w	r3, r3, #2097152	; 0x200000
 8004d58:	2b00      	cmp	r3, #0
 8004d5a:	d003      	beq.n	8004d64 <usb_lld_serve_interrupt+0x184>
      otg_epout_handler(usbp, 5);
 8004d5c:	2105      	movs	r1, #5
 8004d5e:	9801      	ldr	r0, [sp, #4]
 8004d60:	f7ff fdbe 	bl	80048e0 <otg_epout_handler>
#if USB_MAX_ENDPOINTS >= 8
    if (src & (1 << 24))
      otg_epout_handler(usbp, 8);
#endif
  }
  if (sts & GINTSTS_IEPINT) {
 8004d64:	9b04      	ldr	r3, [sp, #16]
 8004d66:	f403 2380 	and.w	r3, r3, #262144	; 0x40000
 8004d6a:	2b00      	cmp	r3, #0
 8004d6c:	d035      	beq.n	8004dda <usb_lld_serve_interrupt+0x1fa>
    if (src & (1 << 0))
 8004d6e:	9b03      	ldr	r3, [sp, #12]
 8004d70:	f003 0301 	and.w	r3, r3, #1
 8004d74:	2b00      	cmp	r3, #0
 8004d76:	d003      	beq.n	8004d80 <usb_lld_serve_interrupt+0x1a0>
      otg_epin_handler(usbp, 0);
 8004d78:	2100      	movs	r1, #0
 8004d7a:	9801      	ldr	r0, [sp, #4]
 8004d7c:	f7ff fd20 	bl	80047c0 <otg_epin_handler>
    if (src & (1 << 1))
 8004d80:	9b03      	ldr	r3, [sp, #12]
 8004d82:	f003 0302 	and.w	r3, r3, #2
 8004d86:	2b00      	cmp	r3, #0
 8004d88:	d003      	beq.n	8004d92 <usb_lld_serve_interrupt+0x1b2>
      otg_epin_handler(usbp, 1);
 8004d8a:	2101      	movs	r1, #1
 8004d8c:	9801      	ldr	r0, [sp, #4]
 8004d8e:	f7ff fd17 	bl	80047c0 <otg_epin_handler>
    if (src & (1 << 2))
 8004d92:	9b03      	ldr	r3, [sp, #12]
 8004d94:	f003 0304 	and.w	r3, r3, #4
 8004d98:	2b00      	cmp	r3, #0
 8004d9a:	d003      	beq.n	8004da4 <usb_lld_serve_interrupt+0x1c4>
      otg_epin_handler(usbp, 2);
 8004d9c:	2102      	movs	r1, #2
 8004d9e:	9801      	ldr	r0, [sp, #4]
 8004da0:	f7ff fd0e 	bl	80047c0 <otg_epin_handler>
    if (src & (1 << 3))
 8004da4:	9b03      	ldr	r3, [sp, #12]
 8004da6:	f003 0308 	and.w	r3, r3, #8
 8004daa:	2b00      	cmp	r3, #0
 8004dac:	d003      	beq.n	8004db6 <usb_lld_serve_interrupt+0x1d6>
      otg_epin_handler(usbp, 3);
 8004dae:	2103      	movs	r1, #3
 8004db0:	9801      	ldr	r0, [sp, #4]
 8004db2:	f7ff fd05 	bl	80047c0 <otg_epin_handler>
#if USB_MAX_ENDPOINTS >= 4
    if (src & (1 << 4))
 8004db6:	9b03      	ldr	r3, [sp, #12]
 8004db8:	f003 0310 	and.w	r3, r3, #16
 8004dbc:	2b00      	cmp	r3, #0
 8004dbe:	d003      	beq.n	8004dc8 <usb_lld_serve_interrupt+0x1e8>
      otg_epin_handler(usbp, 4);
 8004dc0:	2104      	movs	r1, #4
 8004dc2:	9801      	ldr	r0, [sp, #4]
 8004dc4:	f7ff fcfc 	bl	80047c0 <otg_epin_handler>
#endif
#if USB_MAX_ENDPOINTS >= 5
    if (src & (1 << 5))
 8004dc8:	9b03      	ldr	r3, [sp, #12]
 8004dca:	f003 0320 	and.w	r3, r3, #32
 8004dce:	2b00      	cmp	r3, #0
 8004dd0:	d003      	beq.n	8004dda <usb_lld_serve_interrupt+0x1fa>
      otg_epin_handler(usbp, 5);
 8004dd2:	2105      	movs	r1, #5
 8004dd4:	9801      	ldr	r0, [sp, #4]
 8004dd6:	f7ff fcf3 	bl	80047c0 <otg_epin_handler>
#if USB_MAX_ENDPOINTS >= 8
    if (src & (1 << 8))
      otg_epin_handler(usbp, 8);
#endif
  }
}
 8004dda:	b007      	add	sp, #28
 8004ddc:	f85d fb04 	ldr.w	pc, [sp], #4

08004de0 <Vector14C>:
/**
 * @brief   OTG1 interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_OTG1_HANDLER) {
 8004de0:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();
 8004de2:	4808      	ldr	r0, [pc, #32]	; (8004e04 <Vector14C+0x24>)
 8004de4:	f001 fcb4 	bl	8006750 <_trace_isr_enter>
 8004de8:	f001 fb82 	bl	80064f0 <_dbg_check_enter_isr>

  usb_lld_serve_interrupt(&USBD1);
 8004dec:	4806      	ldr	r0, [pc, #24]	; (8004e08 <Vector14C+0x28>)
 8004dee:	f7ff fef7 	bl	8004be0 <usb_lld_serve_interrupt>

  OSAL_IRQ_EPILOGUE();
 8004df2:	f001 fb9d 	bl	8006530 <_dbg_check_leave_isr>
 8004df6:	4803      	ldr	r0, [pc, #12]	; (8004e04 <Vector14C+0x24>)
 8004df8:	f001 fcd2 	bl	80067a0 <_trace_isr_leave>
 8004dfc:	f003 fb10 	bl	8008420 <_port_irq_epilogue>
}
 8004e00:	bd08      	pop	{r3, pc}
 8004e02:	bf00      	nop
 8004e04:	08008aec 	.word	0x08008aec
 8004e08:	2000088c 	.word	0x2000088c
 8004e0c:	00000000 	.word	0x00000000

08004e10 <Vector174>:
/**
 * @brief   OTG2 interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_OTG2_HANDLER) {
 8004e10:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();
 8004e12:	4808      	ldr	r0, [pc, #32]	; (8004e34 <Vector174+0x24>)
 8004e14:	f001 fc9c 	bl	8006750 <_trace_isr_enter>
 8004e18:	f001 fb6a 	bl	80064f0 <_dbg_check_enter_isr>

  usb_lld_serve_interrupt(&USBD2);
 8004e1c:	4806      	ldr	r0, [pc, #24]	; (8004e38 <Vector174+0x28>)
 8004e1e:	f7ff fedf 	bl	8004be0 <usb_lld_serve_interrupt>

  OSAL_IRQ_EPILOGUE();
 8004e22:	f001 fb85 	bl	8006530 <_dbg_check_leave_isr>
 8004e26:	4803      	ldr	r0, [pc, #12]	; (8004e34 <Vector174+0x24>)
 8004e28:	f001 fcba 	bl	80067a0 <_trace_isr_leave>
 8004e2c:	f003 faf8 	bl	8008420 <_port_irq_epilogue>
}
 8004e30:	bd08      	pop	{r3, pc}
 8004e32:	bf00      	nop
 8004e34:	08008af8 	.word	0x08008af8
 8004e38:	20000904 	.word	0x20000904
 8004e3c:	00000000 	.word	0x00000000

08004e40 <usb_lld_init>:
/**
 * @brief   Low level USB driver initialization.
 *
 * @notapi
 */
void usb_lld_init(void) {
 8004e40:	b508      	push	{r3, lr}

  /* Driver initialization.*/
#if STM32_USB_USE_OTG1
  usbObjectInit(&USBD1);
 8004e42:	480a      	ldr	r0, [pc, #40]	; (8004e6c <usb_lld_init+0x2c>)
 8004e44:	f7fe f8ec 	bl	8003020 <usbObjectInit>
  USBD1.otg       = OTG_FS;
 8004e48:	4b08      	ldr	r3, [pc, #32]	; (8004e6c <usb_lld_init+0x2c>)
 8004e4a:	f04f 42a0 	mov.w	r2, #1342177280	; 0x50000000
 8004e4e:	66da      	str	r2, [r3, #108]	; 0x6c
  USBD1.otgparams = &fsparams;
 8004e50:	4b06      	ldr	r3, [pc, #24]	; (8004e6c <usb_lld_init+0x2c>)
 8004e52:	4a07      	ldr	r2, [pc, #28]	; (8004e70 <usb_lld_init+0x30>)
 8004e54:	671a      	str	r2, [r3, #112]	; 0x70

#endif

#if STM32_USB_USE_OTG2
  usbObjectInit(&USBD2);
 8004e56:	4807      	ldr	r0, [pc, #28]	; (8004e74 <usb_lld_init+0x34>)
 8004e58:	f7fe f8e2 	bl	8003020 <usbObjectInit>
  USBD2.otg       = OTG_HS;
 8004e5c:	4b05      	ldr	r3, [pc, #20]	; (8004e74 <usb_lld_init+0x34>)
 8004e5e:	4a06      	ldr	r2, [pc, #24]	; (8004e78 <usb_lld_init+0x38>)
 8004e60:	66da      	str	r2, [r3, #108]	; 0x6c
  USBD2.otgparams = &hsparams;
 8004e62:	4b04      	ldr	r3, [pc, #16]	; (8004e74 <usb_lld_init+0x34>)
 8004e64:	4a05      	ldr	r2, [pc, #20]	; (8004e7c <usb_lld_init+0x3c>)
 8004e66:	671a      	str	r2, [r3, #112]	; 0x70
#endif
}
 8004e68:	bd08      	pop	{r3, pc}
 8004e6a:	bf00      	nop
 8004e6c:	2000088c 	.word	0x2000088c
 8004e70:	08008aa8 	.word	0x08008aa8
 8004e74:	20000904 	.word	0x20000904
 8004e78:	40040000 	.word	0x40040000
 8004e7c:	08008ab4 	.word	0x08008ab4

08004e80 <usb_lld_start>:
 *
 * @param[in] usbp      pointer to the @p USBDriver object
 *
 * @notapi
 */
void usb_lld_start(USBDriver *usbp) {
 8004e80:	b500      	push	{lr}
 8004e82:	b085      	sub	sp, #20
 8004e84:	9001      	str	r0, [sp, #4]
  stm32_otg_t *otgp = usbp->otg;
 8004e86:	9b01      	ldr	r3, [sp, #4]
 8004e88:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 8004e8a:	9303      	str	r3, [sp, #12]

  if (usbp->state == USB_STOP) {
 8004e8c:	9b01      	ldr	r3, [sp, #4]
 8004e8e:	781b      	ldrb	r3, [r3, #0]
 8004e90:	2b01      	cmp	r3, #1
 8004e92:	f040 809a 	bne.w	8004fca <usb_lld_start+0x14a>
    /* Clock activation.*/

#if STM32_USB_USE_OTG1
    if (&USBD1 == usbp) {
 8004e96:	9b01      	ldr	r3, [sp, #4]
 8004e98:	4a4d      	ldr	r2, [pc, #308]	; (8004fd0 <usb_lld_start+0x150>)
 8004e9a:	4293      	cmp	r3, r2
 8004e9c:	d126      	bne.n	8004eec <usb_lld_start+0x6c>
      /* OTG FS clock enable and reset.*/
      rccEnableOTG_FS(true);
 8004e9e:	4b4d      	ldr	r3, [pc, #308]	; (8004fd4 <usb_lld_start+0x154>)
 8004ea0:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8004ea2:	4a4c      	ldr	r2, [pc, #304]	; (8004fd4 <usb_lld_start+0x154>)
 8004ea4:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8004ea8:	6353      	str	r3, [r2, #52]	; 0x34
 8004eaa:	4b4a      	ldr	r3, [pc, #296]	; (8004fd4 <usb_lld_start+0x154>)
 8004eac:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8004eae:	4a49      	ldr	r2, [pc, #292]	; (8004fd4 <usb_lld_start+0x154>)
 8004eb0:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8004eb4:	6553      	str	r3, [r2, #84]	; 0x54
 8004eb6:	4b47      	ldr	r3, [pc, #284]	; (8004fd4 <usb_lld_start+0x154>)
 8004eb8:	6d5b      	ldr	r3, [r3, #84]	; 0x54
      rccResetOTG_FS();
 8004eba:	4b46      	ldr	r3, [pc, #280]	; (8004fd4 <usb_lld_start+0x154>)
 8004ebc:	695b      	ldr	r3, [r3, #20]
 8004ebe:	4a45      	ldr	r2, [pc, #276]	; (8004fd4 <usb_lld_start+0x154>)
 8004ec0:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8004ec4:	6153      	str	r3, [r2, #20]
 8004ec6:	4b43      	ldr	r3, [pc, #268]	; (8004fd4 <usb_lld_start+0x154>)
 8004ec8:	695b      	ldr	r3, [r3, #20]
 8004eca:	4a42      	ldr	r2, [pc, #264]	; (8004fd4 <usb_lld_start+0x154>)
 8004ecc:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 8004ed0:	6153      	str	r3, [r2, #20]
 8004ed2:	4b40      	ldr	r3, [pc, #256]	; (8004fd4 <usb_lld_start+0x154>)
 8004ed4:	695b      	ldr	r3, [r3, #20]

      /* Enables IRQ vector.*/
      nvicEnableVector(STM32_OTG1_NUMBER, STM32_USB_OTG1_IRQ_PRIORITY);
 8004ed6:	210e      	movs	r1, #14
 8004ed8:	2043      	movs	r0, #67	; 0x43
 8004eda:	f7fe fc81 	bl	80037e0 <nvicEnableVector>

      /* - Forced device mode.
         - USB turn-around time = TRDT_VALUE_FS.
         - Full Speed 1.1 PHY.*/
      otgp->GUSBCFG = GUSBCFG_FDMOD | GUSBCFG_TRDT(TRDT_VALUE_FS) |
 8004ede:	9b03      	ldr	r3, [sp, #12]
 8004ee0:	4a3d      	ldr	r2, [pc, #244]	; (8004fd8 <usb_lld_start+0x158>)
 8004ee2:	60da      	str	r2, [r3, #12]
                      GUSBCFG_PHYSEL;

      /* 48MHz 1.1 PHY.*/
      otgp->DCFG = 0x02200000 | DCFG_DSPD_FS11;
 8004ee4:	9b03      	ldr	r3, [sp, #12]
 8004ee6:	4a3d      	ldr	r2, [pc, #244]	; (8004fdc <usb_lld_start+0x15c>)
 8004ee8:	f8c3 2800 	str.w	r2, [r3, #2048]	; 0x800
    }
#endif

#if STM32_USB_USE_OTG2
    if (&USBD2 == usbp) {
 8004eec:	9b01      	ldr	r3, [sp, #4]
 8004eee:	4a3c      	ldr	r2, [pc, #240]	; (8004fe0 <usb_lld_start+0x160>)
 8004ef0:	4293      	cmp	r3, r2
 8004ef2:	d134      	bne.n	8004f5e <usb_lld_start+0xde>
      /* OTG HS clock enable and reset.*/
      rccEnableOTG_HS(true);
 8004ef4:	4b37      	ldr	r3, [pc, #220]	; (8004fd4 <usb_lld_start+0x154>)
 8004ef6:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8004ef8:	4a36      	ldr	r2, [pc, #216]	; (8004fd4 <usb_lld_start+0x154>)
 8004efa:	f043 5300 	orr.w	r3, r3, #536870912	; 0x20000000
 8004efe:	6313      	str	r3, [r2, #48]	; 0x30
 8004f00:	4b34      	ldr	r3, [pc, #208]	; (8004fd4 <usb_lld_start+0x154>)
 8004f02:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 8004f04:	4a33      	ldr	r2, [pc, #204]	; (8004fd4 <usb_lld_start+0x154>)
 8004f06:	f043 5300 	orr.w	r3, r3, #536870912	; 0x20000000
 8004f0a:	6513      	str	r3, [r2, #80]	; 0x50
 8004f0c:	4b31      	ldr	r3, [pc, #196]	; (8004fd4 <usb_lld_start+0x154>)
 8004f0e:	6d1b      	ldr	r3, [r3, #80]	; 0x50
      rccResetOTG_HS();
 8004f10:	4b30      	ldr	r3, [pc, #192]	; (8004fd4 <usb_lld_start+0x154>)
 8004f12:	691b      	ldr	r3, [r3, #16]
 8004f14:	4a2f      	ldr	r2, [pc, #188]	; (8004fd4 <usb_lld_start+0x154>)
 8004f16:	f043 5300 	orr.w	r3, r3, #536870912	; 0x20000000
 8004f1a:	6113      	str	r3, [r2, #16]
 8004f1c:	4b2d      	ldr	r3, [pc, #180]	; (8004fd4 <usb_lld_start+0x154>)
 8004f1e:	691b      	ldr	r3, [r3, #16]
 8004f20:	4a2c      	ldr	r2, [pc, #176]	; (8004fd4 <usb_lld_start+0x154>)
 8004f22:	f023 5300 	bic.w	r3, r3, #536870912	; 0x20000000
 8004f26:	6113      	str	r3, [r2, #16]
 8004f28:	4b2a      	ldr	r3, [pc, #168]	; (8004fd4 <usb_lld_start+0x154>)
 8004f2a:	691b      	ldr	r3, [r3, #16]
#if defined(BOARD_OTG2_USES_ULPI)
      rccEnableOTG_HSULPI(true);
#else
      /* Workaround for the problem described here:
         http://forum.chibios.org/phpbb/viewtopic.php?f=16&t=1798.*/
      rccDisableOTG_HSULPI();
 8004f2c:	4b29      	ldr	r3, [pc, #164]	; (8004fd4 <usb_lld_start+0x154>)
 8004f2e:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8004f30:	4a28      	ldr	r2, [pc, #160]	; (8004fd4 <usb_lld_start+0x154>)
 8004f32:	f023 4380 	bic.w	r3, r3, #1073741824	; 0x40000000
 8004f36:	6313      	str	r3, [r2, #48]	; 0x30
 8004f38:	4b26      	ldr	r3, [pc, #152]	; (8004fd4 <usb_lld_start+0x154>)
 8004f3a:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 8004f3c:	4a25      	ldr	r2, [pc, #148]	; (8004fd4 <usb_lld_start+0x154>)
 8004f3e:	f023 4380 	bic.w	r3, r3, #1073741824	; 0x40000000
 8004f42:	6513      	str	r3, [r2, #80]	; 0x50
 8004f44:	4b23      	ldr	r3, [pc, #140]	; (8004fd4 <usb_lld_start+0x154>)
 8004f46:	6d1b      	ldr	r3, [r3, #80]	; 0x50
#endif

      /* Enables IRQ vector.*/
      nvicEnableVector(STM32_OTG2_NUMBER, STM32_USB_OTG2_IRQ_PRIORITY);
 8004f48:	210e      	movs	r1, #14
 8004f4a:	204d      	movs	r0, #77	; 0x4d
 8004f4c:	f7fe fc48 	bl	80037e0 <nvicEnableVector>
#if defined(BOARD_OTG2_USES_ULPI)
      /* High speed ULPI PHY.*/
      otgp->GUSBCFG = GUSBCFG_FDMOD | GUSBCFG_TRDT(TRDT_VALUE_HS) |
                      GUSBCFG_SRPCAP | GUSBCFG_HNPCAP;
#else
      otgp->GUSBCFG = GUSBCFG_FDMOD | GUSBCFG_TRDT(TRDT_VALUE_FS) |
 8004f50:	9b03      	ldr	r3, [sp, #12]
 8004f52:	4a21      	ldr	r2, [pc, #132]	; (8004fd8 <usb_lld_start+0x158>)
 8004f54:	60da      	str	r2, [r3, #12]
      /* USB 2.0 High Speed PHY in FS mode.*/
      otgp->DCFG = 0x02200000 | DCFG_DSPD_HS_FS;
#endif
#else
      /* 48MHz 1.1 PHY.*/
      otgp->DCFG = 0x02200000 | DCFG_DSPD_FS11;
 8004f56:	9b03      	ldr	r3, [sp, #12]
 8004f58:	4a20      	ldr	r2, [pc, #128]	; (8004fdc <usb_lld_start+0x15c>)
 8004f5a:	f8c3 2800 	str.w	r2, [r3, #2048]	; 0x800
#endif
    }
#endif

    /* PHY enabled.*/
    otgp->PCGCCTL = 0;
 8004f5e:	9b03      	ldr	r3, [sp, #12]
 8004f60:	2200      	movs	r2, #0
 8004f62:	f8c3 2e00 	str.w	r2, [r3, #3584]	; 0xe00

    /* VBUS sensing and transceiver enabled.*/
    otgp->GOTGCTL = GOTGCTL_BVALOEN | GOTGCTL_BVALOVAL;
 8004f66:	9b03      	ldr	r3, [sp, #12]
 8004f68:	22c0      	movs	r2, #192	; 0xc0
 8004f6a:	601a      	str	r2, [r3, #0]
    if (&USBD2 == usbp) {
      otgp->GCCFG = 0;
    }
#endif
#else
    otgp->GCCFG = GCCFG_INIT_VALUE;
 8004f6c:	9b03      	ldr	r3, [sp, #12]
 8004f6e:	f44f 2250 	mov.w	r2, #851968	; 0xd0000
 8004f72:	639a      	str	r2, [r3, #56]	; 0x38
#endif

    /* Soft core reset.*/
    otg_core_reset(usbp);
 8004f74:	9801      	ldr	r0, [sp, #4]
 8004f76:	f7ff f9db 	bl	8004330 <otg_core_reset>

    /* Interrupts on TXFIFOs half empty.*/
    otgp->GAHBCFG = 0;
 8004f7a:	9b03      	ldr	r3, [sp, #12]
 8004f7c:	2200      	movs	r2, #0
 8004f7e:	609a      	str	r2, [r3, #8]

    /* Endpoints re-initialization.*/
    otg_disable_ep(usbp);
 8004f80:	9801      	ldr	r0, [sp, #4]
 8004f82:	f7ff f9f5 	bl	8004370 <otg_disable_ep>

    /* Clear all pending Device Interrupts, only the USB Reset interrupt
       is required initially.*/
    otgp->DIEPMSK  = 0;
 8004f86:	9b03      	ldr	r3, [sp, #12]
 8004f88:	2200      	movs	r2, #0
 8004f8a:	f8c3 2810 	str.w	r2, [r3, #2064]	; 0x810
    otgp->DOEPMSK  = 0;
 8004f8e:	9b03      	ldr	r3, [sp, #12]
 8004f90:	2200      	movs	r2, #0
 8004f92:	f8c3 2814 	str.w	r2, [r3, #2068]	; 0x814
    otgp->DAINTMSK = 0;
 8004f96:	9b03      	ldr	r3, [sp, #12]
 8004f98:	2200      	movs	r2, #0
 8004f9a:	f8c3 281c 	str.w	r2, [r3, #2076]	; 0x81c
    if (usbp->config->sof_cb == NULL)
 8004f9e:	9b01      	ldr	r3, [sp, #4]
 8004fa0:	685b      	ldr	r3, [r3, #4]
 8004fa2:	68db      	ldr	r3, [r3, #12]
 8004fa4:	2b00      	cmp	r3, #0
 8004fa6:	d103      	bne.n	8004fb0 <usb_lld_start+0x130>
      otgp->GINTMSK  = GINTMSK_ENUMDNEM | GINTMSK_USBRSTM | GINTMSK_USBSUSPM |
 8004fa8:	9b03      	ldr	r3, [sp, #12]
 8004faa:	4a0e      	ldr	r2, [pc, #56]	; (8004fe4 <usb_lld_start+0x164>)
 8004fac:	619a      	str	r2, [r3, #24]
 8004fae:	e002      	b.n	8004fb6 <usb_lld_start+0x136>
                       GINTMSK_ESUSPM | GINTMSK_SRQM | GINTMSK_WKUM |
                       GINTMSK_IISOIXFRM | GINTMSK_IISOOXFRM;
    else
      otgp->GINTMSK  = GINTMSK_ENUMDNEM | GINTMSK_USBRSTM | GINTMSK_USBSUSPM |
 8004fb0:	9b03      	ldr	r3, [sp, #12]
 8004fb2:	4a0d      	ldr	r2, [pc, #52]	; (8004fe8 <usb_lld_start+0x168>)
 8004fb4:	619a      	str	r2, [r3, #24]
                       GINTMSK_ESUSPM | GINTMSK_SRQM | GINTMSK_WKUM |
                       GINTMSK_IISOIXFRM | GINTMSK_IISOOXFRM |
                       GINTMSK_SOFM;

    /* Clears all pending IRQs, if any. */
    otgp->GINTSTS  = 0xFFFFFFFF;
 8004fb6:	9b03      	ldr	r3, [sp, #12]
 8004fb8:	f04f 32ff 	mov.w	r2, #4294967295
 8004fbc:	615a      	str	r2, [r3, #20]

    /* Global interrupts enable.*/
    otgp->GAHBCFG |= GAHBCFG_GINTMSK;
 8004fbe:	9b03      	ldr	r3, [sp, #12]
 8004fc0:	689b      	ldr	r3, [r3, #8]
 8004fc2:	f043 0201 	orr.w	r2, r3, #1
 8004fc6:	9b03      	ldr	r3, [sp, #12]
 8004fc8:	609a      	str	r2, [r3, #8]
  }
}
 8004fca:	b005      	add	sp, #20
 8004fcc:	f85d fb04 	ldr.w	pc, [sp], #4
 8004fd0:	2000088c 	.word	0x2000088c
 8004fd4:	40023800 	.word	0x40023800
 8004fd8:	40001440 	.word	0x40001440
 8004fdc:	02200003 	.word	0x02200003
 8004fe0:	20000904 	.word	0x20000904
 8004fe4:	c0303c00 	.word	0xc0303c00
 8004fe8:	c0303c08 	.word	0xc0303c08
 8004fec:	00000000 	.word	0x00000000

08004ff0 <usb_lld_reset>:
 *
 * @param[in] usbp      pointer to the @p USBDriver object
 *
 * @notapi
 */
void usb_lld_reset(USBDriver *usbp) {
 8004ff0:	b510      	push	{r4, lr}
 8004ff2:	b084      	sub	sp, #16
 8004ff4:	9001      	str	r0, [sp, #4]
  unsigned i;
  stm32_otg_t *otgp = usbp->otg;
 8004ff6:	9b01      	ldr	r3, [sp, #4]
 8004ff8:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 8004ffa:	9302      	str	r3, [sp, #8]

  /* Flush the Tx FIFO.*/
  otg_txfifo_flush(usbp, 0);
 8004ffc:	2100      	movs	r1, #0
 8004ffe:	9801      	ldr	r0, [sp, #4]
 8005000:	f7ff fa16 	bl	8004430 <otg_txfifo_flush>

  /* Endpoint interrupts all disabled and cleared.*/
  otgp->DIEPEMPMSK = 0;
 8005004:	9b02      	ldr	r3, [sp, #8]
 8005006:	2200      	movs	r2, #0
 8005008:	f8c3 2834 	str.w	r2, [r3, #2100]	; 0x834
  otgp->DAINTMSK   = DAINTMSK_OEPM(0) | DAINTMSK_IEPM(0);
 800500c:	9b02      	ldr	r3, [sp, #8]
 800500e:	f04f 1201 	mov.w	r2, #65537	; 0x10001
 8005012:	f8c3 281c 	str.w	r2, [r3, #2076]	; 0x81c

  /* All endpoints in NAK mode, interrupts cleared.*/
  for (i = 0; i <= usbp->otgparams->num_endpoints; i++) {
 8005016:	2300      	movs	r3, #0
 8005018:	9303      	str	r3, [sp, #12]
 800501a:	e024      	b.n	8005066 <usb_lld_reset+0x76>
    otgp->ie[i].DIEPCTL = DIEPCTL_SNAK;
 800501c:	9a02      	ldr	r2, [sp, #8]
 800501e:	9b03      	ldr	r3, [sp, #12]
 8005020:	3348      	adds	r3, #72	; 0x48
 8005022:	015b      	lsls	r3, r3, #5
 8005024:	4413      	add	r3, r2
 8005026:	f04f 6200 	mov.w	r2, #134217728	; 0x8000000
 800502a:	601a      	str	r2, [r3, #0]
    otgp->oe[i].DOEPCTL = DOEPCTL_SNAK;
 800502c:	9a02      	ldr	r2, [sp, #8]
 800502e:	9b03      	ldr	r3, [sp, #12]
 8005030:	3358      	adds	r3, #88	; 0x58
 8005032:	015b      	lsls	r3, r3, #5
 8005034:	4413      	add	r3, r2
 8005036:	f04f 6200 	mov.w	r2, #134217728	; 0x8000000
 800503a:	601a      	str	r2, [r3, #0]
    otgp->ie[i].DIEPINT = 0xFFFFFFFF;
 800503c:	9a02      	ldr	r2, [sp, #8]
 800503e:	9b03      	ldr	r3, [sp, #12]
 8005040:	015b      	lsls	r3, r3, #5
 8005042:	4413      	add	r3, r2
 8005044:	f603 1308 	addw	r3, r3, #2312	; 0x908
 8005048:	f04f 32ff 	mov.w	r2, #4294967295
 800504c:	601a      	str	r2, [r3, #0]
    otgp->oe[i].DOEPINT = 0xFFFFFFFF;
 800504e:	9a02      	ldr	r2, [sp, #8]
 8005050:	9b03      	ldr	r3, [sp, #12]
 8005052:	015b      	lsls	r3, r3, #5
 8005054:	4413      	add	r3, r2
 8005056:	f603 3308 	addw	r3, r3, #2824	; 0xb08
 800505a:	f04f 32ff 	mov.w	r2, #4294967295
 800505e:	601a      	str	r2, [r3, #0]
  for (i = 0; i <= usbp->otgparams->num_endpoints; i++) {
 8005060:	9b03      	ldr	r3, [sp, #12]
 8005062:	3301      	adds	r3, #1
 8005064:	9303      	str	r3, [sp, #12]
 8005066:	9b01      	ldr	r3, [sp, #4]
 8005068:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 800506a:	689b      	ldr	r3, [r3, #8]
 800506c:	9a03      	ldr	r2, [sp, #12]
 800506e:	429a      	cmp	r2, r3
 8005070:	d9d4      	bls.n	800501c <usb_lld_reset+0x2c>
  }

  /* Resets the FIFO memory allocator.*/
  otg_ram_reset(usbp);
 8005072:	9801      	ldr	r0, [sp, #4]
 8005074:	f7ff f9fc 	bl	8004470 <otg_ram_reset>

  /* Receive FIFO size initialization, the address is always zero.*/
  otgp->GRXFSIZ = usbp->otgparams->rx_fifo_size;
 8005078:	9b01      	ldr	r3, [sp, #4]
 800507a:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 800507c:	681a      	ldr	r2, [r3, #0]
 800507e:	9b02      	ldr	r3, [sp, #8]
 8005080:	625a      	str	r2, [r3, #36]	; 0x24
  otg_rxfifo_flush(usbp);
 8005082:	9801      	ldr	r0, [sp, #4]
 8005084:	f7ff f9bc 	bl	8004400 <otg_rxfifo_flush>

  /* Resets the device address to zero.*/
  otgp->DCFG = (otgp->DCFG & ~DCFG_DAD_MASK) | DCFG_DAD(0);
 8005088:	9b02      	ldr	r3, [sp, #8]
 800508a:	f8d3 3800 	ldr.w	r3, [r3, #2048]	; 0x800
 800508e:	f423 62fe 	bic.w	r2, r3, #2032	; 0x7f0
 8005092:	9b02      	ldr	r3, [sp, #8]
 8005094:	f8c3 2800 	str.w	r2, [r3, #2048]	; 0x800

  /* Enables also EP-related interrupt sources.*/
  otgp->GINTMSK  |= GINTMSK_RXFLVLM | GINTMSK_OEPM  | GINTMSK_IEPM;
 8005098:	9b02      	ldr	r3, [sp, #8]
 800509a:	699b      	ldr	r3, [r3, #24]
 800509c:	f443 2340 	orr.w	r3, r3, #786432	; 0xc0000
 80050a0:	f043 0310 	orr.w	r3, r3, #16
 80050a4:	9a02      	ldr	r2, [sp, #8]
 80050a6:	6193      	str	r3, [r2, #24]
  otgp->DIEPMSK   = DIEPMSK_TOCM    | DIEPMSK_XFRCM;
 80050a8:	9b02      	ldr	r3, [sp, #8]
 80050aa:	2209      	movs	r2, #9
 80050ac:	f8c3 2810 	str.w	r2, [r3, #2064]	; 0x810
  otgp->DOEPMSK   = DOEPMSK_STUPM   | DOEPMSK_XFRCM;
 80050b0:	9b02      	ldr	r3, [sp, #8]
 80050b2:	2209      	movs	r2, #9
 80050b4:	f8c3 2814 	str.w	r2, [r3, #2068]	; 0x814

  /* EP0 initialization, it is a special case.*/
  usbp->epc[0] = &ep0config;
 80050b8:	9b01      	ldr	r3, [sp, #4]
 80050ba:	4a17      	ldr	r2, [pc, #92]	; (8005118 <usb_lld_reset+0x128>)
 80050bc:	60da      	str	r2, [r3, #12]
  otgp->oe[0].DOEPTSIZ = DOEPTSIZ_STUPCNT(3);
 80050be:	9b02      	ldr	r3, [sp, #8]
 80050c0:	f04f 42c0 	mov.w	r2, #1610612736	; 0x60000000
 80050c4:	f8c3 2b10 	str.w	r2, [r3, #2832]	; 0xb10
  otgp->oe[0].DOEPCTL = DOEPCTL_SD0PID | DOEPCTL_USBAEP | DOEPCTL_EPTYP_CTRL |
                        DOEPCTL_MPSIZ(ep0config.out_maxsize);
 80050c8:	2340      	movs	r3, #64	; 0x40
  otgp->oe[0].DOEPCTL = DOEPCTL_SD0PID | DOEPCTL_USBAEP | DOEPCTL_EPTYP_CTRL |
 80050ca:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 80050ce:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 80050d2:	9a02      	ldr	r2, [sp, #8]
 80050d4:	f8c2 3b00 	str.w	r3, [r2, #2816]	; 0xb00
  otgp->ie[0].DIEPTSIZ = 0;
 80050d8:	9b02      	ldr	r3, [sp, #8]
 80050da:	2200      	movs	r2, #0
 80050dc:	f8c3 2910 	str.w	r2, [r3, #2320]	; 0x910
  otgp->ie[0].DIEPCTL = DIEPCTL_SD0PID | DIEPCTL_USBAEP | DIEPCTL_EPTYP_CTRL |
                        DIEPCTL_TXFNUM(0) | DIEPCTL_MPSIZ(ep0config.in_maxsize);
 80050e0:	2340      	movs	r3, #64	; 0x40
 80050e2:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 80050e6:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
  otgp->ie[0].DIEPCTL = DIEPCTL_SD0PID | DIEPCTL_USBAEP | DIEPCTL_EPTYP_CTRL |
 80050ea:	9a02      	ldr	r2, [sp, #8]
 80050ec:	f8c2 3900 	str.w	r3, [r2, #2304]	; 0x900
  otgp->DIEPTXF0 = DIEPTXF_INEPTXFD(ep0config.in_maxsize / 4) |
 80050f0:	2340      	movs	r3, #64	; 0x40
 80050f2:	089b      	lsrs	r3, r3, #2
 80050f4:	b29b      	uxth	r3, r3
 80050f6:	041b      	lsls	r3, r3, #16
 80050f8:	461c      	mov	r4, r3
                   DIEPTXF_INEPTXSA(otg_ram_alloc(usbp,
 80050fa:	2340      	movs	r3, #64	; 0x40
 80050fc:	089b      	lsrs	r3, r3, #2
 80050fe:	b29b      	uxth	r3, r3
 8005100:	4619      	mov	r1, r3
 8005102:	9801      	ldr	r0, [sp, #4]
 8005104:	f7ff f9c4 	bl	8004490 <otg_ram_alloc>
 8005108:	4603      	mov	r3, r0
  otgp->DIEPTXF0 = DIEPTXF_INEPTXFD(ep0config.in_maxsize / 4) |
 800510a:	ea44 0203 	orr.w	r2, r4, r3
 800510e:	9b02      	ldr	r3, [sp, #8]
 8005110:	629a      	str	r2, [r3, #40]	; 0x28
                                                  ep0config.in_maxsize / 4));
}
 8005112:	b004      	add	sp, #16
 8005114:	bd10      	pop	{r4, pc}
 8005116:	bf00      	nop
 8005118:	08008a84 	.word	0x08008a84
 800511c:	00000000 	.word	0x00000000

08005120 <usb_lld_set_address>:
 *
 * @param[in] usbp      pointer to the @p USBDriver object
 *
 * @notapi
 */
void usb_lld_set_address(USBDriver *usbp) {
 8005120:	b084      	sub	sp, #16
 8005122:	9001      	str	r0, [sp, #4]
  stm32_otg_t *otgp = usbp->otg;
 8005124:	9b01      	ldr	r3, [sp, #4]
 8005126:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 8005128:	9303      	str	r3, [sp, #12]

  otgp->DCFG = (otgp->DCFG & ~DCFG_DAD_MASK) | DCFG_DAD(usbp->address);
 800512a:	9b03      	ldr	r3, [sp, #12]
 800512c:	f8d3 3800 	ldr.w	r3, [r3, #2048]	; 0x800
 8005130:	f423 63fe 	bic.w	r3, r3, #2032	; 0x7f0
 8005134:	9a01      	ldr	r2, [sp, #4]
 8005136:	f892 2066 	ldrb.w	r2, [r2, #102]	; 0x66
 800513a:	0112      	lsls	r2, r2, #4
 800513c:	431a      	orrs	r2, r3
 800513e:	9b03      	ldr	r3, [sp, #12]
 8005140:	f8c3 2800 	str.w	r2, [r3, #2048]	; 0x800
}
 8005144:	b004      	add	sp, #16
 8005146:	4770      	bx	lr
	...

08005150 <usb_lld_init_endpoint>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number
 *
 * @notapi
 */
void usb_lld_init_endpoint(USBDriver *usbp, usbep_t ep) {
 8005150:	b510      	push	{r4, lr}
 8005152:	b086      	sub	sp, #24
 8005154:	9001      	str	r0, [sp, #4]
 8005156:	460b      	mov	r3, r1
 8005158:	f88d 3003 	strb.w	r3, [sp, #3]
  uint32_t ctl, fsize;
  stm32_otg_t *otgp = usbp->otg;
 800515c:	9b01      	ldr	r3, [sp, #4]
 800515e:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 8005160:	9303      	str	r3, [sp, #12]

  /* IN and OUT common parameters.*/
  switch (usbp->epc[ep]->ep_mode & USB_EP_MODE_TYPE) {
 8005162:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8005166:	9a01      	ldr	r2, [sp, #4]
 8005168:	3302      	adds	r3, #2
 800516a:	009b      	lsls	r3, r3, #2
 800516c:	4413      	add	r3, r2
 800516e:	685b      	ldr	r3, [r3, #4]
 8005170:	681b      	ldr	r3, [r3, #0]
 8005172:	f003 0303 	and.w	r3, r3, #3
 8005176:	2b03      	cmp	r3, #3
 8005178:	f200 8104 	bhi.w	8005384 <usb_lld_init_endpoint+0x234>
 800517c:	a201      	add	r2, pc, #4	; (adr r2, 8005184 <usb_lld_init_endpoint+0x34>)
 800517e:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8005182:	bf00      	nop
 8005184:	08005195 	.word	0x08005195
 8005188:	0800519b 	.word	0x0800519b
 800518c:	080051a1 	.word	0x080051a1
 8005190:	080051a7 	.word	0x080051a7
  case USB_EP_MODE_TYPE_CTRL:
    ctl = DIEPCTL_SD0PID | DIEPCTL_USBAEP | DIEPCTL_EPTYP_CTRL;
 8005194:	4b7d      	ldr	r3, [pc, #500]	; (800538c <usb_lld_init_endpoint+0x23c>)
 8005196:	9305      	str	r3, [sp, #20]
 8005198:	e007      	b.n	80051aa <usb_lld_init_endpoint+0x5a>
    break;
  case USB_EP_MODE_TYPE_ISOC:
    ctl = DIEPCTL_SD0PID | DIEPCTL_USBAEP | DIEPCTL_EPTYP_ISO;
 800519a:	4b7d      	ldr	r3, [pc, #500]	; (8005390 <usb_lld_init_endpoint+0x240>)
 800519c:	9305      	str	r3, [sp, #20]
 800519e:	e004      	b.n	80051aa <usb_lld_init_endpoint+0x5a>
    break;
  case USB_EP_MODE_TYPE_BULK:
    ctl = DIEPCTL_SD0PID | DIEPCTL_USBAEP | DIEPCTL_EPTYP_BULK;
 80051a0:	4b7c      	ldr	r3, [pc, #496]	; (8005394 <usb_lld_init_endpoint+0x244>)
 80051a2:	9305      	str	r3, [sp, #20]
 80051a4:	e001      	b.n	80051aa <usb_lld_init_endpoint+0x5a>
    break;
  case USB_EP_MODE_TYPE_INTR:
    ctl = DIEPCTL_SD0PID | DIEPCTL_USBAEP | DIEPCTL_EPTYP_INTR;
 80051a6:	4b7c      	ldr	r3, [pc, #496]	; (8005398 <usb_lld_init_endpoint+0x248>)
 80051a8:	9305      	str	r3, [sp, #20]
  default:
    return;
  }

  /* OUT endpoint activation or deactivation.*/
  otgp->oe[ep].DOEPTSIZ = 0;
 80051aa:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80051ae:	9a03      	ldr	r2, [sp, #12]
 80051b0:	015b      	lsls	r3, r3, #5
 80051b2:	4413      	add	r3, r2
 80051b4:	f503 6331 	add.w	r3, r3, #2832	; 0xb10
 80051b8:	2200      	movs	r2, #0
 80051ba:	601a      	str	r2, [r3, #0]
  if (usbp->epc[ep]->out_state != NULL) {
 80051bc:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80051c0:	9a01      	ldr	r2, [sp, #4]
 80051c2:	3302      	adds	r3, #2
 80051c4:	009b      	lsls	r3, r3, #2
 80051c6:	4413      	add	r3, r2
 80051c8:	685b      	ldr	r3, [r3, #4]
 80051ca:	699b      	ldr	r3, [r3, #24]
 80051cc:	2b00      	cmp	r3, #0
 80051ce:	d01f      	beq.n	8005210 <usb_lld_init_endpoint+0xc0>
    otgp->oe[ep].DOEPCTL = ctl | DOEPCTL_MPSIZ(usbp->epc[ep]->out_maxsize);
 80051d0:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80051d4:	9a01      	ldr	r2, [sp, #4]
 80051d6:	3302      	adds	r3, #2
 80051d8:	009b      	lsls	r3, r3, #2
 80051da:	4413      	add	r3, r2
 80051dc:	685b      	ldr	r3, [r3, #4]
 80051de:	8a5b      	ldrh	r3, [r3, #18]
 80051e0:	4619      	mov	r1, r3
 80051e2:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80051e6:	9a05      	ldr	r2, [sp, #20]
 80051e8:	430a      	orrs	r2, r1
 80051ea:	9903      	ldr	r1, [sp, #12]
 80051ec:	3358      	adds	r3, #88	; 0x58
 80051ee:	015b      	lsls	r3, r3, #5
 80051f0:	440b      	add	r3, r1
 80051f2:	601a      	str	r2, [r3, #0]
    otgp->DAINTMSK |= DAINTMSK_OEPM(ep);
 80051f4:	9b03      	ldr	r3, [sp, #12]
 80051f6:	f8d3 281c 	ldr.w	r2, [r3, #2076]	; 0x81c
 80051fa:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80051fe:	3310      	adds	r3, #16
 8005200:	2101      	movs	r1, #1
 8005202:	fa01 f303 	lsl.w	r3, r1, r3
 8005206:	431a      	orrs	r2, r3
 8005208:	9b03      	ldr	r3, [sp, #12]
 800520a:	f8c3 281c 	str.w	r2, [r3, #2076]	; 0x81c
 800520e:	e01d      	b.n	800524c <usb_lld_init_endpoint+0xfc>
  }
  else {
    otgp->oe[ep].DOEPCTL &= ~DOEPCTL_USBAEP;
 8005210:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8005214:	9a03      	ldr	r2, [sp, #12]
 8005216:	3358      	adds	r3, #88	; 0x58
 8005218:	015b      	lsls	r3, r3, #5
 800521a:	4413      	add	r3, r2
 800521c:	681a      	ldr	r2, [r3, #0]
 800521e:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8005222:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
 8005226:	9903      	ldr	r1, [sp, #12]
 8005228:	3358      	adds	r3, #88	; 0x58
 800522a:	015b      	lsls	r3, r3, #5
 800522c:	440b      	add	r3, r1
 800522e:	601a      	str	r2, [r3, #0]
    otgp->DAINTMSK &= ~DAINTMSK_OEPM(ep);
 8005230:	9b03      	ldr	r3, [sp, #12]
 8005232:	f8d3 281c 	ldr.w	r2, [r3, #2076]	; 0x81c
 8005236:	f89d 3003 	ldrb.w	r3, [sp, #3]
 800523a:	3310      	adds	r3, #16
 800523c:	2101      	movs	r1, #1
 800523e:	fa01 f303 	lsl.w	r3, r1, r3
 8005242:	43db      	mvns	r3, r3
 8005244:	401a      	ands	r2, r3
 8005246:	9b03      	ldr	r3, [sp, #12]
 8005248:	f8c3 281c 	str.w	r2, [r3, #2076]	; 0x81c
  }

  /* IN endpoint activation or deactivation.*/
  otgp->ie[ep].DIEPTSIZ = 0;
 800524c:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8005250:	9a03      	ldr	r2, [sp, #12]
 8005252:	015b      	lsls	r3, r3, #5
 8005254:	4413      	add	r3, r2
 8005256:	f503 6311 	add.w	r3, r3, #2320	; 0x910
 800525a:	2200      	movs	r2, #0
 800525c:	601a      	str	r2, [r3, #0]
  if (usbp->epc[ep]->in_state != NULL) {
 800525e:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8005262:	9a01      	ldr	r2, [sp, #4]
 8005264:	3302      	adds	r3, #2
 8005266:	009b      	lsls	r3, r3, #2
 8005268:	4413      	add	r3, r2
 800526a:	685b      	ldr	r3, [r3, #4]
 800526c:	695b      	ldr	r3, [r3, #20]
 800526e:	2b00      	cmp	r3, #0
 8005270:	d05b      	beq.n	800532a <usb_lld_init_endpoint+0x1da>
    /* FIFO allocation for the IN endpoint.*/
    fsize = usbp->epc[ep]->in_maxsize / 4;
 8005272:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8005276:	9a01      	ldr	r2, [sp, #4]
 8005278:	3302      	adds	r3, #2
 800527a:	009b      	lsls	r3, r3, #2
 800527c:	4413      	add	r3, r2
 800527e:	685b      	ldr	r3, [r3, #4]
 8005280:	8a1b      	ldrh	r3, [r3, #16]
 8005282:	089b      	lsrs	r3, r3, #2
 8005284:	b29b      	uxth	r3, r3
 8005286:	9304      	str	r3, [sp, #16]
    if (usbp->epc[ep]->in_multiplier > 1)
 8005288:	f89d 3003 	ldrb.w	r3, [sp, #3]
 800528c:	9a01      	ldr	r2, [sp, #4]
 800528e:	3302      	adds	r3, #2
 8005290:	009b      	lsls	r3, r3, #2
 8005292:	4413      	add	r3, r2
 8005294:	685b      	ldr	r3, [r3, #4]
 8005296:	8b9b      	ldrh	r3, [r3, #28]
 8005298:	2b01      	cmp	r3, #1
 800529a:	d90c      	bls.n	80052b6 <usb_lld_init_endpoint+0x166>
      fsize *= usbp->epc[ep]->in_multiplier;
 800529c:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80052a0:	9a01      	ldr	r2, [sp, #4]
 80052a2:	3302      	adds	r3, #2
 80052a4:	009b      	lsls	r3, r3, #2
 80052a6:	4413      	add	r3, r2
 80052a8:	685b      	ldr	r3, [r3, #4]
 80052aa:	8b9b      	ldrh	r3, [r3, #28]
 80052ac:	461a      	mov	r2, r3
 80052ae:	9b04      	ldr	r3, [sp, #16]
 80052b0:	fb02 f303 	mul.w	r3, r2, r3
 80052b4:	9304      	str	r3, [sp, #16]
    otgp->DIEPTXF[ep - 1] = DIEPTXF_INEPTXFD(fsize) |
 80052b6:	9b04      	ldr	r3, [sp, #16]
 80052b8:	041c      	lsls	r4, r3, #16
                            DIEPTXF_INEPTXSA(otg_ram_alloc(usbp, fsize));
 80052ba:	9904      	ldr	r1, [sp, #16]
 80052bc:	9801      	ldr	r0, [sp, #4]
 80052be:	f7ff f8e7 	bl	8004490 <otg_ram_alloc>
 80052c2:	4602      	mov	r2, r0
    otgp->DIEPTXF[ep - 1] = DIEPTXF_INEPTXFD(fsize) |
 80052c4:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80052c8:	3b01      	subs	r3, #1
 80052ca:	4322      	orrs	r2, r4
 80052cc:	9903      	ldr	r1, [sp, #12]
 80052ce:	3340      	adds	r3, #64	; 0x40
 80052d0:	009b      	lsls	r3, r3, #2
 80052d2:	440b      	add	r3, r1
 80052d4:	605a      	str	r2, [r3, #4]
    otg_txfifo_flush(usbp, ep);
 80052d6:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80052da:	4619      	mov	r1, r3
 80052dc:	9801      	ldr	r0, [sp, #4]
 80052de:	f7ff f8a7 	bl	8004430 <otg_txfifo_flush>

    otgp->ie[ep].DIEPCTL = ctl |
                           DIEPCTL_TXFNUM(ep) |
 80052e2:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80052e6:	059b      	lsls	r3, r3, #22
 80052e8:	461a      	mov	r2, r3
    otgp->ie[ep].DIEPCTL = ctl |
 80052ea:	9b05      	ldr	r3, [sp, #20]
 80052ec:	431a      	orrs	r2, r3
                           DIEPCTL_MPSIZ(usbp->epc[ep]->in_maxsize);
 80052ee:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80052f2:	9901      	ldr	r1, [sp, #4]
 80052f4:	3302      	adds	r3, #2
 80052f6:	009b      	lsls	r3, r3, #2
 80052f8:	440b      	add	r3, r1
 80052fa:	685b      	ldr	r3, [r3, #4]
 80052fc:	8a1b      	ldrh	r3, [r3, #16]
 80052fe:	4619      	mov	r1, r3
    otgp->ie[ep].DIEPCTL = ctl |
 8005300:	f89d 3003 	ldrb.w	r3, [sp, #3]
                           DIEPCTL_TXFNUM(ep) |
 8005304:	430a      	orrs	r2, r1
    otgp->ie[ep].DIEPCTL = ctl |
 8005306:	9903      	ldr	r1, [sp, #12]
 8005308:	3348      	adds	r3, #72	; 0x48
 800530a:	015b      	lsls	r3, r3, #5
 800530c:	440b      	add	r3, r1
 800530e:	601a      	str	r2, [r3, #0]
    otgp->DAINTMSK |= DAINTMSK_IEPM(ep);
 8005310:	9b03      	ldr	r3, [sp, #12]
 8005312:	f8d3 281c 	ldr.w	r2, [r3, #2076]	; 0x81c
 8005316:	f89d 3003 	ldrb.w	r3, [sp, #3]
 800531a:	2101      	movs	r1, #1
 800531c:	fa01 f303 	lsl.w	r3, r1, r3
 8005320:	431a      	orrs	r2, r3
 8005322:	9b03      	ldr	r3, [sp, #12]
 8005324:	f8c3 281c 	str.w	r2, [r3, #2076]	; 0x81c
 8005328:	e02d      	b.n	8005386 <usb_lld_init_endpoint+0x236>
  }
  else {
    otgp->DIEPTXF[ep - 1] = 0x02000400; /* Reset value.*/
 800532a:	f89d 3003 	ldrb.w	r3, [sp, #3]
 800532e:	3b01      	subs	r3, #1
 8005330:	9a03      	ldr	r2, [sp, #12]
 8005332:	3340      	adds	r3, #64	; 0x40
 8005334:	009b      	lsls	r3, r3, #2
 8005336:	4413      	add	r3, r2
 8005338:	4a18      	ldr	r2, [pc, #96]	; (800539c <usb_lld_init_endpoint+0x24c>)
 800533a:	605a      	str	r2, [r3, #4]
    otg_txfifo_flush(usbp, ep);
 800533c:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8005340:	4619      	mov	r1, r3
 8005342:	9801      	ldr	r0, [sp, #4]
 8005344:	f7ff f874 	bl	8004430 <otg_txfifo_flush>
    otgp->ie[ep].DIEPCTL &= ~DIEPCTL_USBAEP;
 8005348:	f89d 3003 	ldrb.w	r3, [sp, #3]
 800534c:	9a03      	ldr	r2, [sp, #12]
 800534e:	3348      	adds	r3, #72	; 0x48
 8005350:	015b      	lsls	r3, r3, #5
 8005352:	4413      	add	r3, r2
 8005354:	681a      	ldr	r2, [r3, #0]
 8005356:	f89d 3003 	ldrb.w	r3, [sp, #3]
 800535a:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
 800535e:	9903      	ldr	r1, [sp, #12]
 8005360:	3348      	adds	r3, #72	; 0x48
 8005362:	015b      	lsls	r3, r3, #5
 8005364:	440b      	add	r3, r1
 8005366:	601a      	str	r2, [r3, #0]
    otgp->DAINTMSK &= ~DAINTMSK_IEPM(ep);
 8005368:	9b03      	ldr	r3, [sp, #12]
 800536a:	f8d3 281c 	ldr.w	r2, [r3, #2076]	; 0x81c
 800536e:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8005372:	2101      	movs	r1, #1
 8005374:	fa01 f303 	lsl.w	r3, r1, r3
 8005378:	43db      	mvns	r3, r3
 800537a:	401a      	ands	r2, r3
 800537c:	9b03      	ldr	r3, [sp, #12]
 800537e:	f8c3 281c 	str.w	r2, [r3, #2076]	; 0x81c
 8005382:	e000      	b.n	8005386 <usb_lld_init_endpoint+0x236>
  default:
 8005384:	bf00      	nop
  }
}
 8005386:	b006      	add	sp, #24
 8005388:	bd10      	pop	{r4, pc}
 800538a:	bf00      	nop
 800538c:	10008000 	.word	0x10008000
 8005390:	10048000 	.word	0x10048000
 8005394:	10088000 	.word	0x10088000
 8005398:	100c8000 	.word	0x100c8000
 800539c:	02000400 	.word	0x02000400

080053a0 <usb_lld_disable_endpoints>:
 *
 * @param[in] usbp      pointer to the @p USBDriver object
 *
 * @notapi
 */
void usb_lld_disable_endpoints(USBDriver *usbp) {
 80053a0:	b500      	push	{lr}
 80053a2:	b083      	sub	sp, #12
 80053a4:	9001      	str	r0, [sp, #4]

  /* Resets the FIFO memory allocator.*/
  otg_ram_reset(usbp);
 80053a6:	9801      	ldr	r0, [sp, #4]
 80053a8:	f7ff f862 	bl	8004470 <otg_ram_reset>

  /* Disabling all endpoints.*/
  otg_disable_ep(usbp);
 80053ac:	9801      	ldr	r0, [sp, #4]
 80053ae:	f7fe ffdf 	bl	8004370 <otg_disable_ep>
}
 80053b2:	b003      	add	sp, #12
 80053b4:	f85d fb04 	ldr.w	pc, [sp], #4
	...

080053c0 <usb_lld_get_status_out>:
 * @retval EP_STATUS_STALLED  The endpoint is stalled.
 * @retval EP_STATUS_ACTIVE   The endpoint is active.
 *
 * @notapi
 */
usbepstatus_t usb_lld_get_status_out(USBDriver *usbp, usbep_t ep) {
 80053c0:	b084      	sub	sp, #16
 80053c2:	9001      	str	r0, [sp, #4]
 80053c4:	460b      	mov	r3, r1
 80053c6:	f88d 3003 	strb.w	r3, [sp, #3]
  uint32_t ctl;

  (void)usbp;

  ctl = usbp->otg->oe[ep].DOEPCTL;
 80053ca:	9b01      	ldr	r3, [sp, #4]
 80053cc:	6eda      	ldr	r2, [r3, #108]	; 0x6c
 80053ce:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80053d2:	3358      	adds	r3, #88	; 0x58
 80053d4:	015b      	lsls	r3, r3, #5
 80053d6:	4413      	add	r3, r2
 80053d8:	681b      	ldr	r3, [r3, #0]
 80053da:	9303      	str	r3, [sp, #12]
  if (!(ctl & DOEPCTL_USBAEP))
 80053dc:	9b03      	ldr	r3, [sp, #12]
 80053de:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
 80053e2:	2b00      	cmp	r3, #0
 80053e4:	d101      	bne.n	80053ea <usb_lld_get_status_out+0x2a>
    return EP_STATUS_DISABLED;
 80053e6:	2300      	movs	r3, #0
 80053e8:	e007      	b.n	80053fa <usb_lld_get_status_out+0x3a>
  if (ctl & DOEPCTL_STALL)
 80053ea:	9b03      	ldr	r3, [sp, #12]
 80053ec:	f403 1300 	and.w	r3, r3, #2097152	; 0x200000
 80053f0:	2b00      	cmp	r3, #0
 80053f2:	d001      	beq.n	80053f8 <usb_lld_get_status_out+0x38>
    return EP_STATUS_STALLED;
 80053f4:	2301      	movs	r3, #1
 80053f6:	e000      	b.n	80053fa <usb_lld_get_status_out+0x3a>
  return EP_STATUS_ACTIVE;
 80053f8:	2302      	movs	r3, #2
}
 80053fa:	4618      	mov	r0, r3
 80053fc:	b004      	add	sp, #16
 80053fe:	4770      	bx	lr

08005400 <usb_lld_get_status_in>:
 * @retval EP_STATUS_STALLED  The endpoint is stalled.
 * @retval EP_STATUS_ACTIVE   The endpoint is active.
 *
 * @notapi
 */
usbepstatus_t usb_lld_get_status_in(USBDriver *usbp, usbep_t ep) {
 8005400:	b084      	sub	sp, #16
 8005402:	9001      	str	r0, [sp, #4]
 8005404:	460b      	mov	r3, r1
 8005406:	f88d 3003 	strb.w	r3, [sp, #3]
  uint32_t ctl;

  (void)usbp;

  ctl = usbp->otg->ie[ep].DIEPCTL;
 800540a:	9b01      	ldr	r3, [sp, #4]
 800540c:	6eda      	ldr	r2, [r3, #108]	; 0x6c
 800540e:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8005412:	3348      	adds	r3, #72	; 0x48
 8005414:	015b      	lsls	r3, r3, #5
 8005416:	4413      	add	r3, r2
 8005418:	681b      	ldr	r3, [r3, #0]
 800541a:	9303      	str	r3, [sp, #12]
  if (!(ctl & DIEPCTL_USBAEP))
 800541c:	9b03      	ldr	r3, [sp, #12]
 800541e:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
 8005422:	2b00      	cmp	r3, #0
 8005424:	d101      	bne.n	800542a <usb_lld_get_status_in+0x2a>
    return EP_STATUS_DISABLED;
 8005426:	2300      	movs	r3, #0
 8005428:	e007      	b.n	800543a <usb_lld_get_status_in+0x3a>
  if (ctl & DIEPCTL_STALL)
 800542a:	9b03      	ldr	r3, [sp, #12]
 800542c:	f403 1300 	and.w	r3, r3, #2097152	; 0x200000
 8005430:	2b00      	cmp	r3, #0
 8005432:	d001      	beq.n	8005438 <usb_lld_get_status_in+0x38>
    return EP_STATUS_STALLED;
 8005434:	2301      	movs	r3, #1
 8005436:	e000      	b.n	800543a <usb_lld_get_status_in+0x3a>
  return EP_STATUS_ACTIVE;
 8005438:	2302      	movs	r3, #2
}
 800543a:	4618      	mov	r0, r3
 800543c:	b004      	add	sp, #16
 800543e:	4770      	bx	lr

08005440 <usb_lld_read_setup>:
 * @param[in] ep        endpoint number
 * @param[out] buf      buffer where to copy the packet data
 *
 * @notapi
 */
void usb_lld_read_setup(USBDriver *usbp, usbep_t ep, uint8_t *buf) {
 8005440:	b500      	push	{lr}
 8005442:	b085      	sub	sp, #20
 8005444:	9003      	str	r0, [sp, #12]
 8005446:	460b      	mov	r3, r1
 8005448:	9201      	str	r2, [sp, #4]
 800544a:	f88d 300b 	strb.w	r3, [sp, #11]

  memcpy(buf, usbp->epc[ep]->setup_buf, 8);
 800544e:	f89d 300b 	ldrb.w	r3, [sp, #11]
 8005452:	9a03      	ldr	r2, [sp, #12]
 8005454:	3302      	adds	r3, #2
 8005456:	009b      	lsls	r3, r3, #2
 8005458:	4413      	add	r3, r2
 800545a:	685b      	ldr	r3, [r3, #4]
 800545c:	6a1b      	ldr	r3, [r3, #32]
 800545e:	2208      	movs	r2, #8
 8005460:	4619      	mov	r1, r3
 8005462:	9801      	ldr	r0, [sp, #4]
 8005464:	f7fa ff4e 	bl	8000304 <memcpy>
}
 8005468:	b005      	add	sp, #20
 800546a:	f85d fb04 	ldr.w	pc, [sp], #4
 800546e:	bf00      	nop

08005470 <usb_lld_start_out>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number
 *
 * @notapi
 */
void usb_lld_start_out(USBDriver *usbp, usbep_t ep) {
 8005470:	b086      	sub	sp, #24
 8005472:	9001      	str	r0, [sp, #4]
 8005474:	460b      	mov	r3, r1
 8005476:	f88d 3003 	strb.w	r3, [sp, #3]
  uint32_t pcnt, rxsize;
  USBOutEndpointState *osp = usbp->epc[ep]->out_state;
 800547a:	f89d 3003 	ldrb.w	r3, [sp, #3]
 800547e:	9a01      	ldr	r2, [sp, #4]
 8005480:	3302      	adds	r3, #2
 8005482:	009b      	lsls	r3, r3, #2
 8005484:	4413      	add	r3, r2
 8005486:	685b      	ldr	r3, [r3, #4]
 8005488:	699b      	ldr	r3, [r3, #24]
 800548a:	9305      	str	r3, [sp, #20]

  /* Transfer initialization.*/
  osp->totsize = osp->rxsize;
 800548c:	9b05      	ldr	r3, [sp, #20]
 800548e:	681a      	ldr	r2, [r3, #0]
 8005490:	9b05      	ldr	r3, [sp, #20]
 8005492:	60da      	str	r2, [r3, #12]
  if ((ep == 0) && (osp->rxsize > EP0_MAX_OUTSIZE))
 8005494:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8005498:	2b00      	cmp	r3, #0
 800549a:	d106      	bne.n	80054aa <usb_lld_start_out+0x3a>
 800549c:	9b05      	ldr	r3, [sp, #20]
 800549e:	681b      	ldr	r3, [r3, #0]
 80054a0:	2b40      	cmp	r3, #64	; 0x40
 80054a2:	d902      	bls.n	80054aa <usb_lld_start_out+0x3a>
      osp->rxsize = EP0_MAX_OUTSIZE;
 80054a4:	9b05      	ldr	r3, [sp, #20]
 80054a6:	2240      	movs	r2, #64	; 0x40
 80054a8:	601a      	str	r2, [r3, #0]
  /* Transaction size is rounded to a multiple of packet size because the
     following requirement in the RM:
     "For OUT transfers, the transfer size field in the endpoint's transfer
     size register must be a multiple of the maximum packet size of the
     endpoint, adjusted to the Word boundary".*/
  pcnt   = (osp->rxsize + usbp->epc[ep]->out_maxsize - 1U) /
 80054aa:	9b05      	ldr	r3, [sp, #20]
 80054ac:	681a      	ldr	r2, [r3, #0]
 80054ae:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80054b2:	9901      	ldr	r1, [sp, #4]
 80054b4:	3302      	adds	r3, #2
 80054b6:	009b      	lsls	r3, r3, #2
 80054b8:	440b      	add	r3, r1
 80054ba:	685b      	ldr	r3, [r3, #4]
 80054bc:	8a5b      	ldrh	r3, [r3, #18]
 80054be:	4413      	add	r3, r2
 80054c0:	1e5a      	subs	r2, r3, #1
           usbp->epc[ep]->out_maxsize;
 80054c2:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80054c6:	9901      	ldr	r1, [sp, #4]
 80054c8:	3302      	adds	r3, #2
 80054ca:	009b      	lsls	r3, r3, #2
 80054cc:	440b      	add	r3, r1
 80054ce:	685b      	ldr	r3, [r3, #4]
 80054d0:	8a5b      	ldrh	r3, [r3, #18]
  pcnt   = (osp->rxsize + usbp->epc[ep]->out_maxsize - 1U) /
 80054d2:	fbb2 f3f3 	udiv	r3, r2, r3
 80054d6:	9304      	str	r3, [sp, #16]
  rxsize = (pcnt * usbp->epc[ep]->out_maxsize + 3U) & 0xFFFFFFFCU;
 80054d8:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80054dc:	9a01      	ldr	r2, [sp, #4]
 80054de:	3302      	adds	r3, #2
 80054e0:	009b      	lsls	r3, r3, #2
 80054e2:	4413      	add	r3, r2
 80054e4:	685b      	ldr	r3, [r3, #4]
 80054e6:	8a5b      	ldrh	r3, [r3, #18]
 80054e8:	461a      	mov	r2, r3
 80054ea:	9b04      	ldr	r3, [sp, #16]
 80054ec:	fb03 f302 	mul.w	r3, r3, r2
 80054f0:	3303      	adds	r3, #3
 80054f2:	f023 0303 	bic.w	r3, r3, #3
 80054f6:	9303      	str	r3, [sp, #12]

  /*Setting up transaction parameters in DOEPTSIZ.*/
  usbp->otg->oe[ep].DOEPTSIZ = DOEPTSIZ_STUPCNT(3) | DOEPTSIZ_PKTCNT(pcnt) |
 80054f8:	9b04      	ldr	r3, [sp, #16]
 80054fa:	04da      	lsls	r2, r3, #19
 80054fc:	9b03      	ldr	r3, [sp, #12]
 80054fe:	431a      	orrs	r2, r3
 8005500:	9b01      	ldr	r3, [sp, #4]
 8005502:	6ed9      	ldr	r1, [r3, #108]	; 0x6c
 8005504:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8005508:	f042 42c0 	orr.w	r2, r2, #1610612736	; 0x60000000
 800550c:	015b      	lsls	r3, r3, #5
 800550e:	440b      	add	r3, r1
 8005510:	f503 6331 	add.w	r3, r3, #2832	; 0xb10
 8005514:	601a      	str	r2, [r3, #0]
                               DOEPTSIZ_XFRSIZ(rxsize);

  /* Special case of isochronous endpoint.*/
  if ((usbp->epc[ep]->ep_mode & USB_EP_MODE_TYPE) == USB_EP_MODE_TYPE_ISOC) {
 8005516:	f89d 3003 	ldrb.w	r3, [sp, #3]
 800551a:	9a01      	ldr	r2, [sp, #4]
 800551c:	3302      	adds	r3, #2
 800551e:	009b      	lsls	r3, r3, #2
 8005520:	4413      	add	r3, r2
 8005522:	685b      	ldr	r3, [r3, #4]
 8005524:	681b      	ldr	r3, [r3, #0]
 8005526:	f003 0303 	and.w	r3, r3, #3
 800552a:	2b01      	cmp	r3, #1
 800552c:	d12c      	bne.n	8005588 <usb_lld_start_out+0x118>
    /* Odd/even bit toggling for isochronous endpoint.*/
    if (usbp->otg->DSTS & DSTS_FNSOF_ODD)
 800552e:	9b01      	ldr	r3, [sp, #4]
 8005530:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 8005532:	f8d3 3808 	ldr.w	r3, [r3, #2056]	; 0x808
 8005536:	f403 7380 	and.w	r3, r3, #256	; 0x100
 800553a:	2b00      	cmp	r3, #0
 800553c:	d012      	beq.n	8005564 <usb_lld_start_out+0xf4>
      usbp->otg->oe[ep].DOEPCTL |= DOEPCTL_SEVNFRM;
 800553e:	9b01      	ldr	r3, [sp, #4]
 8005540:	6eda      	ldr	r2, [r3, #108]	; 0x6c
 8005542:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8005546:	3358      	adds	r3, #88	; 0x58
 8005548:	015b      	lsls	r3, r3, #5
 800554a:	4413      	add	r3, r2
 800554c:	681a      	ldr	r2, [r3, #0]
 800554e:	9b01      	ldr	r3, [sp, #4]
 8005550:	6ed9      	ldr	r1, [r3, #108]	; 0x6c
 8005552:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8005556:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 800555a:	3358      	adds	r3, #88	; 0x58
 800555c:	015b      	lsls	r3, r3, #5
 800555e:	440b      	add	r3, r1
 8005560:	601a      	str	r2, [r3, #0]
 8005562:	e011      	b.n	8005588 <usb_lld_start_out+0x118>
    else
      usbp->otg->oe[ep].DOEPCTL |= DOEPCTL_SODDFRM;
 8005564:	9b01      	ldr	r3, [sp, #4]
 8005566:	6eda      	ldr	r2, [r3, #108]	; 0x6c
 8005568:	f89d 3003 	ldrb.w	r3, [sp, #3]
 800556c:	3358      	adds	r3, #88	; 0x58
 800556e:	015b      	lsls	r3, r3, #5
 8005570:	4413      	add	r3, r2
 8005572:	681a      	ldr	r2, [r3, #0]
 8005574:	9b01      	ldr	r3, [sp, #4]
 8005576:	6ed9      	ldr	r1, [r3, #108]	; 0x6c
 8005578:	f89d 3003 	ldrb.w	r3, [sp, #3]
 800557c:	f042 5200 	orr.w	r2, r2, #536870912	; 0x20000000
 8005580:	3358      	adds	r3, #88	; 0x58
 8005582:	015b      	lsls	r3, r3, #5
 8005584:	440b      	add	r3, r1
 8005586:	601a      	str	r2, [r3, #0]
  }

  /* Starting operation.*/
  usbp->otg->oe[ep].DOEPCTL |= DOEPCTL_EPENA | DOEPCTL_CNAK;
 8005588:	9b01      	ldr	r3, [sp, #4]
 800558a:	6eda      	ldr	r2, [r3, #108]	; 0x6c
 800558c:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8005590:	3358      	adds	r3, #88	; 0x58
 8005592:	015b      	lsls	r3, r3, #5
 8005594:	4413      	add	r3, r2
 8005596:	681a      	ldr	r2, [r3, #0]
 8005598:	9b01      	ldr	r3, [sp, #4]
 800559a:	6ed9      	ldr	r1, [r3, #108]	; 0x6c
 800559c:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80055a0:	f042 4204 	orr.w	r2, r2, #2214592512	; 0x84000000
 80055a4:	3358      	adds	r3, #88	; 0x58
 80055a6:	015b      	lsls	r3, r3, #5
 80055a8:	440b      	add	r3, r1
 80055aa:	601a      	str	r2, [r3, #0]
}
 80055ac:	b006      	add	sp, #24
 80055ae:	4770      	bx	lr

080055b0 <usb_lld_start_in>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number
 *
 * @notapi
 */
void usb_lld_start_in(USBDriver *usbp, usbep_t ep) {
 80055b0:	b084      	sub	sp, #16
 80055b2:	9001      	str	r0, [sp, #4]
 80055b4:	460b      	mov	r3, r1
 80055b6:	f88d 3003 	strb.w	r3, [sp, #3]
  USBInEndpointState *isp = usbp->epc[ep]->in_state;
 80055ba:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80055be:	9a01      	ldr	r2, [sp, #4]
 80055c0:	3302      	adds	r3, #2
 80055c2:	009b      	lsls	r3, r3, #2
 80055c4:	4413      	add	r3, r2
 80055c6:	685b      	ldr	r3, [r3, #4]
 80055c8:	695b      	ldr	r3, [r3, #20]
 80055ca:	9303      	str	r3, [sp, #12]

  /* Transfer initialization.*/
  isp->totsize = isp->txsize;
 80055cc:	9b03      	ldr	r3, [sp, #12]
 80055ce:	681a      	ldr	r2, [r3, #0]
 80055d0:	9b03      	ldr	r3, [sp, #12]
 80055d2:	60da      	str	r2, [r3, #12]
  if (isp->txsize == 0) {
 80055d4:	9b03      	ldr	r3, [sp, #12]
 80055d6:	681b      	ldr	r3, [r3, #0]
 80055d8:	2b00      	cmp	r3, #0
 80055da:	d10b      	bne.n	80055f4 <usb_lld_start_in+0x44>
    /* Special case, sending zero size packet.*/
    usbp->otg->ie[ep].DIEPTSIZ = DIEPTSIZ_PKTCNT(1) | DIEPTSIZ_XFRSIZ(0);
 80055dc:	9b01      	ldr	r3, [sp, #4]
 80055de:	6eda      	ldr	r2, [r3, #108]	; 0x6c
 80055e0:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80055e4:	015b      	lsls	r3, r3, #5
 80055e6:	4413      	add	r3, r2
 80055e8:	f503 6311 	add.w	r3, r3, #2320	; 0x910
 80055ec:	f44f 2200 	mov.w	r2, #524288	; 0x80000
 80055f0:	601a      	str	r2, [r3, #0]
 80055f2:	e031      	b.n	8005658 <usb_lld_start_in+0xa8>
  }
  else {
    if ((ep == 0) && (isp->txsize > EP0_MAX_INSIZE))
 80055f4:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80055f8:	2b00      	cmp	r3, #0
 80055fa:	d106      	bne.n	800560a <usb_lld_start_in+0x5a>
 80055fc:	9b03      	ldr	r3, [sp, #12]
 80055fe:	681b      	ldr	r3, [r3, #0]
 8005600:	2b40      	cmp	r3, #64	; 0x40
 8005602:	d902      	bls.n	800560a <usb_lld_start_in+0x5a>
      isp->txsize = EP0_MAX_INSIZE;
 8005604:	9b03      	ldr	r3, [sp, #12]
 8005606:	2240      	movs	r2, #64	; 0x40
 8005608:	601a      	str	r2, [r3, #0]

    /* Normal case.*/
    uint32_t pcnt = (isp->txsize + usbp->epc[ep]->in_maxsize - 1) /
 800560a:	9b03      	ldr	r3, [sp, #12]
 800560c:	681a      	ldr	r2, [r3, #0]
 800560e:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8005612:	9901      	ldr	r1, [sp, #4]
 8005614:	3302      	adds	r3, #2
 8005616:	009b      	lsls	r3, r3, #2
 8005618:	440b      	add	r3, r1
 800561a:	685b      	ldr	r3, [r3, #4]
 800561c:	8a1b      	ldrh	r3, [r3, #16]
 800561e:	4413      	add	r3, r2
 8005620:	1e5a      	subs	r2, r3, #1
                    usbp->epc[ep]->in_maxsize;
 8005622:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8005626:	9901      	ldr	r1, [sp, #4]
 8005628:	3302      	adds	r3, #2
 800562a:	009b      	lsls	r3, r3, #2
 800562c:	440b      	add	r3, r1
 800562e:	685b      	ldr	r3, [r3, #4]
 8005630:	8a1b      	ldrh	r3, [r3, #16]
    uint32_t pcnt = (isp->txsize + usbp->epc[ep]->in_maxsize - 1) /
 8005632:	fbb2 f3f3 	udiv	r3, r2, r3
 8005636:	9302      	str	r3, [sp, #8]
    /* TODO: Support more than one packet per frame for isochronous transfers.*/
    usbp->otg->ie[ep].DIEPTSIZ = DIEPTSIZ_MCNT(1) | DIEPTSIZ_PKTCNT(pcnt) |
 8005638:	9b02      	ldr	r3, [sp, #8]
 800563a:	04da      	lsls	r2, r3, #19
                                 DIEPTSIZ_XFRSIZ(isp->txsize);
 800563c:	9b03      	ldr	r3, [sp, #12]
 800563e:	681b      	ldr	r3, [r3, #0]
    usbp->otg->ie[ep].DIEPTSIZ = DIEPTSIZ_MCNT(1) | DIEPTSIZ_PKTCNT(pcnt) |
 8005640:	431a      	orrs	r2, r3
 8005642:	9b01      	ldr	r3, [sp, #4]
 8005644:	6ed9      	ldr	r1, [r3, #108]	; 0x6c
 8005646:	f89d 3003 	ldrb.w	r3, [sp, #3]
 800564a:	f042 5200 	orr.w	r2, r2, #536870912	; 0x20000000
 800564e:	015b      	lsls	r3, r3, #5
 8005650:	440b      	add	r3, r1
 8005652:	f503 6311 	add.w	r3, r3, #2320	; 0x910
 8005656:	601a      	str	r2, [r3, #0]
  }

  /* Special case of isochronous endpoint.*/
  if ((usbp->epc[ep]->ep_mode & USB_EP_MODE_TYPE) == USB_EP_MODE_TYPE_ISOC) {
 8005658:	f89d 3003 	ldrb.w	r3, [sp, #3]
 800565c:	9a01      	ldr	r2, [sp, #4]
 800565e:	3302      	adds	r3, #2
 8005660:	009b      	lsls	r3, r3, #2
 8005662:	4413      	add	r3, r2
 8005664:	685b      	ldr	r3, [r3, #4]
 8005666:	681b      	ldr	r3, [r3, #0]
 8005668:	f003 0303 	and.w	r3, r3, #3
 800566c:	2b01      	cmp	r3, #1
 800566e:	d12c      	bne.n	80056ca <usb_lld_start_in+0x11a>
    /* Odd/even bit toggling.*/
    if (usbp->otg->DSTS & DSTS_FNSOF_ODD)
 8005670:	9b01      	ldr	r3, [sp, #4]
 8005672:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 8005674:	f8d3 3808 	ldr.w	r3, [r3, #2056]	; 0x808
 8005678:	f403 7380 	and.w	r3, r3, #256	; 0x100
 800567c:	2b00      	cmp	r3, #0
 800567e:	d012      	beq.n	80056a6 <usb_lld_start_in+0xf6>
      usbp->otg->ie[ep].DIEPCTL |= DIEPCTL_SEVNFRM;
 8005680:	9b01      	ldr	r3, [sp, #4]
 8005682:	6eda      	ldr	r2, [r3, #108]	; 0x6c
 8005684:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8005688:	3348      	adds	r3, #72	; 0x48
 800568a:	015b      	lsls	r3, r3, #5
 800568c:	4413      	add	r3, r2
 800568e:	681a      	ldr	r2, [r3, #0]
 8005690:	9b01      	ldr	r3, [sp, #4]
 8005692:	6ed9      	ldr	r1, [r3, #108]	; 0x6c
 8005694:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8005698:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 800569c:	3348      	adds	r3, #72	; 0x48
 800569e:	015b      	lsls	r3, r3, #5
 80056a0:	440b      	add	r3, r1
 80056a2:	601a      	str	r2, [r3, #0]
 80056a4:	e011      	b.n	80056ca <usb_lld_start_in+0x11a>
    else
      usbp->otg->ie[ep].DIEPCTL |= DIEPCTL_SODDFRM;
 80056a6:	9b01      	ldr	r3, [sp, #4]
 80056a8:	6eda      	ldr	r2, [r3, #108]	; 0x6c
 80056aa:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80056ae:	3348      	adds	r3, #72	; 0x48
 80056b0:	015b      	lsls	r3, r3, #5
 80056b2:	4413      	add	r3, r2
 80056b4:	681a      	ldr	r2, [r3, #0]
 80056b6:	9b01      	ldr	r3, [sp, #4]
 80056b8:	6ed9      	ldr	r1, [r3, #108]	; 0x6c
 80056ba:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80056be:	f042 5200 	orr.w	r2, r2, #536870912	; 0x20000000
 80056c2:	3348      	adds	r3, #72	; 0x48
 80056c4:	015b      	lsls	r3, r3, #5
 80056c6:	440b      	add	r3, r1
 80056c8:	601a      	str	r2, [r3, #0]
  }

  /* Starting operation.*/
  usbp->otg->ie[ep].DIEPCTL |= DIEPCTL_EPENA | DIEPCTL_CNAK;
 80056ca:	9b01      	ldr	r3, [sp, #4]
 80056cc:	6eda      	ldr	r2, [r3, #108]	; 0x6c
 80056ce:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80056d2:	3348      	adds	r3, #72	; 0x48
 80056d4:	015b      	lsls	r3, r3, #5
 80056d6:	4413      	add	r3, r2
 80056d8:	681a      	ldr	r2, [r3, #0]
 80056da:	9b01      	ldr	r3, [sp, #4]
 80056dc:	6ed9      	ldr	r1, [r3, #108]	; 0x6c
 80056de:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80056e2:	f042 4204 	orr.w	r2, r2, #2214592512	; 0x84000000
 80056e6:	3348      	adds	r3, #72	; 0x48
 80056e8:	015b      	lsls	r3, r3, #5
 80056ea:	440b      	add	r3, r1
 80056ec:	601a      	str	r2, [r3, #0]
  usbp->otg->DIEPEMPMSK |= DIEPEMPMSK_INEPTXFEM(ep);
 80056ee:	9b01      	ldr	r3, [sp, #4]
 80056f0:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 80056f2:	f8d3 1834 	ldr.w	r1, [r3, #2100]	; 0x834
 80056f6:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80056fa:	2201      	movs	r2, #1
 80056fc:	409a      	lsls	r2, r3
 80056fe:	9b01      	ldr	r3, [sp, #4]
 8005700:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 8005702:	430a      	orrs	r2, r1
 8005704:	f8c3 2834 	str.w	r2, [r3, #2100]	; 0x834
}
 8005708:	b004      	add	sp, #16
 800570a:	4770      	bx	lr
 800570c:	0000      	movs	r0, r0
	...

08005710 <usb_lld_stall_out>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number
 *
 * @notapi
 */
void usb_lld_stall_out(USBDriver *usbp, usbep_t ep) {
 8005710:	b082      	sub	sp, #8
 8005712:	9001      	str	r0, [sp, #4]
 8005714:	460b      	mov	r3, r1
 8005716:	f88d 3003 	strb.w	r3, [sp, #3]

  usbp->otg->oe[ep].DOEPCTL |= DOEPCTL_STALL;
 800571a:	9b01      	ldr	r3, [sp, #4]
 800571c:	6eda      	ldr	r2, [r3, #108]	; 0x6c
 800571e:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8005722:	3358      	adds	r3, #88	; 0x58
 8005724:	015b      	lsls	r3, r3, #5
 8005726:	4413      	add	r3, r2
 8005728:	681a      	ldr	r2, [r3, #0]
 800572a:	9b01      	ldr	r3, [sp, #4]
 800572c:	6ed9      	ldr	r1, [r3, #108]	; 0x6c
 800572e:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8005732:	f442 1200 	orr.w	r2, r2, #2097152	; 0x200000
 8005736:	3358      	adds	r3, #88	; 0x58
 8005738:	015b      	lsls	r3, r3, #5
 800573a:	440b      	add	r3, r1
 800573c:	601a      	str	r2, [r3, #0]
}
 800573e:	b002      	add	sp, #8
 8005740:	4770      	bx	lr
 8005742:	bf00      	nop
	...

08005750 <usb_lld_stall_in>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number
 *
 * @notapi
 */
void usb_lld_stall_in(USBDriver *usbp, usbep_t ep) {
 8005750:	b082      	sub	sp, #8
 8005752:	9001      	str	r0, [sp, #4]
 8005754:	460b      	mov	r3, r1
 8005756:	f88d 3003 	strb.w	r3, [sp, #3]

  usbp->otg->ie[ep].DIEPCTL |= DIEPCTL_STALL;
 800575a:	9b01      	ldr	r3, [sp, #4]
 800575c:	6eda      	ldr	r2, [r3, #108]	; 0x6c
 800575e:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8005762:	3348      	adds	r3, #72	; 0x48
 8005764:	015b      	lsls	r3, r3, #5
 8005766:	4413      	add	r3, r2
 8005768:	681a      	ldr	r2, [r3, #0]
 800576a:	9b01      	ldr	r3, [sp, #4]
 800576c:	6ed9      	ldr	r1, [r3, #108]	; 0x6c
 800576e:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8005772:	f442 1200 	orr.w	r2, r2, #2097152	; 0x200000
 8005776:	3348      	adds	r3, #72	; 0x48
 8005778:	015b      	lsls	r3, r3, #5
 800577a:	440b      	add	r3, r1
 800577c:	601a      	str	r2, [r3, #0]
}
 800577e:	b002      	add	sp, #8
 8005780:	4770      	bx	lr
 8005782:	bf00      	nop
	...

08005790 <usb_lld_clear_out>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number
 *
 * @notapi
 */
void usb_lld_clear_out(USBDriver *usbp, usbep_t ep) {
 8005790:	b082      	sub	sp, #8
 8005792:	9001      	str	r0, [sp, #4]
 8005794:	460b      	mov	r3, r1
 8005796:	f88d 3003 	strb.w	r3, [sp, #3]

  usbp->otg->oe[ep].DOEPCTL &= ~DOEPCTL_STALL;
 800579a:	9b01      	ldr	r3, [sp, #4]
 800579c:	6eda      	ldr	r2, [r3, #108]	; 0x6c
 800579e:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80057a2:	3358      	adds	r3, #88	; 0x58
 80057a4:	015b      	lsls	r3, r3, #5
 80057a6:	4413      	add	r3, r2
 80057a8:	681a      	ldr	r2, [r3, #0]
 80057aa:	9b01      	ldr	r3, [sp, #4]
 80057ac:	6ed9      	ldr	r1, [r3, #108]	; 0x6c
 80057ae:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80057b2:	f422 1200 	bic.w	r2, r2, #2097152	; 0x200000
 80057b6:	3358      	adds	r3, #88	; 0x58
 80057b8:	015b      	lsls	r3, r3, #5
 80057ba:	440b      	add	r3, r1
 80057bc:	601a      	str	r2, [r3, #0]
}
 80057be:	b002      	add	sp, #8
 80057c0:	4770      	bx	lr
 80057c2:	bf00      	nop
	...

080057d0 <usb_lld_clear_in>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number
 *
 * @notapi
 */
void usb_lld_clear_in(USBDriver *usbp, usbep_t ep) {
 80057d0:	b082      	sub	sp, #8
 80057d2:	9001      	str	r0, [sp, #4]
 80057d4:	460b      	mov	r3, r1
 80057d6:	f88d 3003 	strb.w	r3, [sp, #3]

  usbp->otg->ie[ep].DIEPCTL &= ~DIEPCTL_STALL;
 80057da:	9b01      	ldr	r3, [sp, #4]
 80057dc:	6eda      	ldr	r2, [r3, #108]	; 0x6c
 80057de:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80057e2:	3348      	adds	r3, #72	; 0x48
 80057e4:	015b      	lsls	r3, r3, #5
 80057e6:	4413      	add	r3, r2
 80057e8:	681a      	ldr	r2, [r3, #0]
 80057ea:	9b01      	ldr	r3, [sp, #4]
 80057ec:	6ed9      	ldr	r1, [r3, #108]	; 0x6c
 80057ee:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80057f2:	f422 1200 	bic.w	r2, r2, #2097152	; 0x200000
 80057f6:	3348      	adds	r3, #72	; 0x48
 80057f8:	015b      	lsls	r3, r3, #5
 80057fa:	440b      	add	r3, r1
 80057fc:	601a      	str	r2, [r3, #0]
}
 80057fe:	b002      	add	sp, #8
 8005800:	4770      	bx	lr
 8005802:	bf00      	nop
	...

08005810 <spi_lld_init>:
/**
 * @brief   Low level SPI driver initialization.
 *
 * @notapi
 */
void spi_lld_init(void) {
 8005810:	b508      	push	{r3, lr}

#if STM32_SPI_USE_SPI1
  spiObjectInit(&SPID1);
 8005812:	4809      	ldr	r0, [pc, #36]	; (8005838 <spi_lld_init+0x28>)
 8005814:	f7fd f94c 	bl	8002ab0 <spiObjectInit>
  SPID1.spi       = SPI1;
 8005818:	4b07      	ldr	r3, [pc, #28]	; (8005838 <spi_lld_init+0x28>)
 800581a:	4a08      	ldr	r2, [pc, #32]	; (800583c <spi_lld_init+0x2c>)
 800581c:	61da      	str	r2, [r3, #28]
  SPID1.dmarx     = NULL;
 800581e:	4b06      	ldr	r3, [pc, #24]	; (8005838 <spi_lld_init+0x28>)
 8005820:	2200      	movs	r2, #0
 8005822:	621a      	str	r2, [r3, #32]
  SPID1.dmatx     = NULL;
 8005824:	4b04      	ldr	r3, [pc, #16]	; (8005838 <spi_lld_init+0x28>)
 8005826:	2200      	movs	r2, #0
 8005828:	625a      	str	r2, [r3, #36]	; 0x24
  SPID1.rxdmamode = STM32_DMA_CR_CHSEL(SPI1_RX_DMA_CHANNEL) |
 800582a:	4b03      	ldr	r3, [pc, #12]	; (8005838 <spi_lld_init+0x28>)
 800582c:	4a04      	ldr	r2, [pc, #16]	; (8005840 <spi_lld_init+0x30>)
 800582e:	629a      	str	r2, [r3, #40]	; 0x28
                    STM32_DMA_CR_PL(STM32_SPI_SPI1_DMA_PRIORITY) |
                    STM32_DMA_CR_DIR_P2M |
                    STM32_DMA_CR_TCIE |
                    STM32_DMA_CR_DMEIE |
                    STM32_DMA_CR_TEIE;
  SPID1.txdmamode = STM32_DMA_CR_CHSEL(SPI1_TX_DMA_CHANNEL) |
 8005830:	4b01      	ldr	r3, [pc, #4]	; (8005838 <spi_lld_init+0x28>)
 8005832:	4a04      	ldr	r2, [pc, #16]	; (8005844 <spi_lld_init+0x34>)
 8005834:	62da      	str	r2, [r3, #44]	; 0x2c
                    STM32_DMA_CR_PL(STM32_SPI_SPI6_DMA_PRIORITY) |
                    STM32_DMA_CR_DIR_M2P |
                    STM32_DMA_CR_DMEIE |
                    STM32_DMA_CR_TEIE;
#endif
}
 8005836:	bd08      	pop	{r3, pc}
 8005838:	20000994 	.word	0x20000994
 800583c:	40013000 	.word	0x40013000
 8005840:	06010016 	.word	0x06010016
 8005844:	06010046 	.word	0x06010046
	...

08005850 <port_lock.lto_priv.296>:
static inline void port_lock(void) {
 8005850:	b082      	sub	sp, #8
 8005852:	2320      	movs	r3, #32
 8005854:	9301      	str	r3, [sp, #4]
 8005856:	9b01      	ldr	r3, [sp, #4]
 8005858:	f383 8811 	msr	BASEPRI, r3
}
 800585c:	b002      	add	sp, #8
 800585e:	4770      	bx	lr

08005860 <port_unlock.lto_priv.255>:
static inline void port_unlock(void) {
 8005860:	b082      	sub	sp, #8
 8005862:	2300      	movs	r3, #0
 8005864:	9301      	str	r3, [sp, #4]
 8005866:	9b01      	ldr	r3, [sp, #4]
 8005868:	f383 8811 	msr	BASEPRI, r3
}
 800586c:	b002      	add	sp, #8
 800586e:	4770      	bx	lr

08005870 <port_lock_from_isr.lto_priv.550>:
static inline void port_lock_from_isr(void) {
 8005870:	b508      	push	{r3, lr}
  port_lock();
 8005872:	f7ff ffed 	bl	8005850 <port_lock.lto_priv.296>
}
 8005876:	bd08      	pop	{r3, pc}
	...

08005880 <port_unlock_from_isr.lto_priv.538>:
static inline void port_unlock_from_isr(void) {
 8005880:	b508      	push	{r3, lr}
  port_unlock();
 8005882:	f7ff ffed 	bl	8005860 <port_unlock.lto_priv.255>
}
 8005886:	bd08      	pop	{r3, pc}
	...

08005890 <chSysLockFromISR.lto_priv.523>:
static inline void chSysLockFromISR(void) {
 8005890:	b508      	push	{r3, lr}
  port_lock_from_isr();
 8005892:	f7ff ffed 	bl	8005870 <port_lock_from_isr.lto_priv.550>
  _dbg_check_lock_from_isr();
 8005896:	f000 fdfb 	bl	8006490 <_dbg_check_lock_from_isr>
}
 800589a:	bd08      	pop	{r3, pc}
 800589c:	0000      	movs	r0, r0
	...

080058a0 <chSysUnlockFromISR.lto_priv.514>:
static inline void chSysUnlockFromISR(void) {
 80058a0:	b508      	push	{r3, lr}
  _dbg_check_unlock_from_isr();
 80058a2:	f000 fe0d 	bl	80064c0 <_dbg_check_unlock_from_isr>
  port_unlock_from_isr();
 80058a6:	f7ff ffeb 	bl	8005880 <port_unlock_from_isr.lto_priv.538>
}
 80058aa:	bd08      	pop	{r3, pc}
 80058ac:	0000      	movs	r0, r0
	...

080058b0 <osalSysLockFromISR.lto_priv.671>:
static inline void osalSysLockFromISR(void) {
 80058b0:	b508      	push	{r3, lr}
  chSysLockFromISR();
 80058b2:	f7ff ffed 	bl	8005890 <chSysLockFromISR.lto_priv.523>
}
 80058b6:	bd08      	pop	{r3, pc}
	...

080058c0 <osalSysUnlockFromISR.lto_priv.665>:
static inline void osalSysUnlockFromISR(void) {
 80058c0:	b508      	push	{r3, lr}
  chSysUnlockFromISR();
 80058c2:	f7ff ffed 	bl	80058a0 <chSysUnlockFromISR.lto_priv.514>
}
 80058c6:	bd08      	pop	{r3, pc}
	...

080058d0 <osalOsTimerHandlerI>:
static inline void osalOsTimerHandlerI(void) {
 80058d0:	b508      	push	{r3, lr}
  chSysTimerHandlerI();
 80058d2:	f000 fd3d 	bl	8006350 <chSysTimerHandlerI>
}
 80058d6:	bd08      	pop	{r3, pc}
	...

080058e0 <VectorB0>:
 * @brief   TIM2 interrupt handler.
 * @details This interrupt is used for system tick in free running mode.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(ST_HANDLER) {
 80058e0:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();
 80058e2:	480f      	ldr	r0, [pc, #60]	; (8005920 <VectorB0+0x40>)
 80058e4:	f000 ff34 	bl	8006750 <_trace_isr_enter>
 80058e8:	f000 fe02 	bl	80064f0 <_dbg_check_enter_isr>

  /* Note, under rare circumstances an interrupt can remain latched even if
     the timer SR register has been cleared, in those cases the interrupt
     is simply ignored.*/
  if ((STM32_ST_TIM->SR & TIM_SR_CC1IF) != 0U) {
 80058ec:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 80058f0:	691b      	ldr	r3, [r3, #16]
 80058f2:	f003 0302 	and.w	r3, r3, #2
 80058f6:	2b00      	cmp	r3, #0
 80058f8:	d009      	beq.n	800590e <VectorB0+0x2e>
    STM32_ST_TIM->SR = 0U;
 80058fa:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 80058fe:	2200      	movs	r2, #0
 8005900:	611a      	str	r2, [r3, #16]

    osalSysLockFromISR();
 8005902:	f7ff ffd5 	bl	80058b0 <osalSysLockFromISR.lto_priv.671>
    osalOsTimerHandlerI();
 8005906:	f7ff ffe3 	bl	80058d0 <osalOsTimerHandlerI>
    osalSysUnlockFromISR();
 800590a:	f7ff ffd9 	bl	80058c0 <osalSysUnlockFromISR.lto_priv.665>
  }

  OSAL_IRQ_EPILOGUE();
 800590e:	f000 fe0f 	bl	8006530 <_dbg_check_leave_isr>
 8005912:	4803      	ldr	r0, [pc, #12]	; (8005920 <VectorB0+0x40>)
 8005914:	f000 ff44 	bl	80067a0 <_trace_isr_leave>
 8005918:	f002 fd82 	bl	8008420 <_port_irq_epilogue>
}
 800591c:	bd08      	pop	{r3, pc}
 800591e:	bf00      	nop
 8005920:	08008b04 	.word	0x08008b04
	...

08005930 <st_lld_init>:
/**
 * @brief   Low level ST driver initialization.
 *
 * @notapi
 */
void st_lld_init(void) {
 8005930:	b508      	push	{r3, lr}

#if OSAL_ST_MODE == OSAL_ST_MODE_FREERUNNING
  /* Free running counter mode.*/

  /* Enabling timer clock.*/
  ST_ENABLE_CLOCK();
 8005932:	4b1d      	ldr	r3, [pc, #116]	; (80059a8 <st_lld_init+0x78>)
 8005934:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8005936:	4a1c      	ldr	r2, [pc, #112]	; (80059a8 <st_lld_init+0x78>)
 8005938:	f043 0301 	orr.w	r3, r3, #1
 800593c:	6413      	str	r3, [r2, #64]	; 0x40
 800593e:	4b1a      	ldr	r3, [pc, #104]	; (80059a8 <st_lld_init+0x78>)
 8005940:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 8005942:	4a19      	ldr	r2, [pc, #100]	; (80059a8 <st_lld_init+0x78>)
 8005944:	f043 0301 	orr.w	r3, r3, #1
 8005948:	6613      	str	r3, [r2, #96]	; 0x60
 800594a:	4b17      	ldr	r3, [pc, #92]	; (80059a8 <st_lld_init+0x78>)
 800594c:	6e1b      	ldr	r3, [r3, #96]	; 0x60

  /* Enabling the stop mode during debug for this timer.*/
  ST_ENABLE_STOP();
 800594e:	4b17      	ldr	r3, [pc, #92]	; (80059ac <st_lld_init+0x7c>)
 8005950:	689b      	ldr	r3, [r3, #8]
 8005952:	4a16      	ldr	r2, [pc, #88]	; (80059ac <st_lld_init+0x7c>)
 8005954:	f043 0301 	orr.w	r3, r3, #1
 8005958:	6093      	str	r3, [r2, #8]

  /* Initializing the counter in free running mode.*/
  STM32_ST_TIM->PSC    = (ST_CLOCK_SRC / OSAL_ST_FREQUENCY) - 1;
 800595a:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 800595e:	f242 02cf 	movw	r2, #8399	; 0x20cf
 8005962:	629a      	str	r2, [r3, #40]	; 0x28
  STM32_ST_TIM->ARR    = ST_ARR_INIT;
 8005964:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8005968:	f04f 32ff 	mov.w	r2, #4294967295
 800596c:	62da      	str	r2, [r3, #44]	; 0x2c
  STM32_ST_TIM->CCMR1  = 0;
 800596e:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8005972:	2200      	movs	r2, #0
 8005974:	619a      	str	r2, [r3, #24]
  STM32_ST_TIM->CCR[0] = 0;
 8005976:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 800597a:	2200      	movs	r2, #0
 800597c:	635a      	str	r2, [r3, #52]	; 0x34
  STM32_ST_TIM->DIER   = 0;
 800597e:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8005982:	2200      	movs	r2, #0
 8005984:	60da      	str	r2, [r3, #12]
  STM32_ST_TIM->CR2    = 0;
 8005986:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 800598a:	2200      	movs	r2, #0
 800598c:	605a      	str	r2, [r3, #4]
  STM32_ST_TIM->EGR    = TIM_EGR_UG;
 800598e:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8005992:	2201      	movs	r2, #1
 8005994:	615a      	str	r2, [r3, #20]
  STM32_ST_TIM->CR1    = TIM_CR1_CEN;
 8005996:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 800599a:	2201      	movs	r2, #1
 800599c:	601a      	str	r2, [r3, #0]

  /* IRQ enabled.*/
  nvicEnableVector(ST_NUMBER, STM32_ST_IRQ_PRIORITY);
 800599e:	2108      	movs	r1, #8
 80059a0:	201c      	movs	r0, #28
 80059a2:	f7fd ff1d 	bl	80037e0 <nvicEnableVector>
                  SysTick_CTRL_TICKINT_Msk;

  /* IRQ enabled.*/
  nvicSetSystemHandlerPriority(HANDLER_SYSTICK, STM32_ST_IRQ_PRIORITY);
#endif /* OSAL_ST_MODE == OSAL_ST_MODE_PERIODIC */
}
 80059a6:	bd08      	pop	{r3, pc}
 80059a8:	40023800 	.word	0x40023800
 80059ac:	e0042000 	.word	0xe0042000

080059b0 <VectorA4>:
 *          pointer is not equal to @p NULL in order to not perform an extra
 *          check in a potentially critical interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_TIM1_UP_HANDLER) {
 80059b0:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();
 80059b2:	4808      	ldr	r0, [pc, #32]	; (80059d4 <VectorA4+0x24>)
 80059b4:	f000 fecc 	bl	8006750 <_trace_isr_enter>
 80059b8:	f000 fd9a 	bl	80064f0 <_dbg_check_enter_isr>

  pwm_lld_serve_interrupt(&PWMD1);
 80059bc:	4806      	ldr	r0, [pc, #24]	; (80059d8 <VectorA4+0x28>)
 80059be:	f000 f837 	bl	8005a30 <pwm_lld_serve_interrupt>

  OSAL_IRQ_EPILOGUE();
 80059c2:	f000 fdb5 	bl	8006530 <_dbg_check_leave_isr>
 80059c6:	4803      	ldr	r0, [pc, #12]	; (80059d4 <VectorA4+0x24>)
 80059c8:	f000 feea 	bl	80067a0 <_trace_isr_leave>
 80059cc:	f002 fd28 	bl	8008420 <_port_irq_epilogue>
}
 80059d0:	bd08      	pop	{r3, pc}
 80059d2:	bf00      	nop
 80059d4:	08008b10 	.word	0x08008b10
 80059d8:	200009c4 	.word	0x200009c4
 80059dc:	00000000 	.word	0x00000000

080059e0 <VectorAC>:
 *          associated callback pointer is not equal to @p NULL in order to not
 *          perform an extra check in a potentially critical interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_TIM1_CC_HANDLER) {
 80059e0:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();
 80059e2:	4808      	ldr	r0, [pc, #32]	; (8005a04 <VectorAC+0x24>)
 80059e4:	f000 feb4 	bl	8006750 <_trace_isr_enter>
 80059e8:	f000 fd82 	bl	80064f0 <_dbg_check_enter_isr>

  pwm_lld_serve_interrupt(&PWMD1);
 80059ec:	4806      	ldr	r0, [pc, #24]	; (8005a08 <VectorAC+0x28>)
 80059ee:	f000 f81f 	bl	8005a30 <pwm_lld_serve_interrupt>

  OSAL_IRQ_EPILOGUE();
 80059f2:	f000 fd9d 	bl	8006530 <_dbg_check_leave_isr>
 80059f6:	4803      	ldr	r0, [pc, #12]	; (8005a04 <VectorAC+0x24>)
 80059f8:	f000 fed2 	bl	80067a0 <_trace_isr_leave>
 80059fc:	f002 fd10 	bl	8008420 <_port_irq_epilogue>
}
 8005a00:	bd08      	pop	{r3, pc}
 8005a02:	bf00      	nop
 8005a04:	08008b1c 	.word	0x08008b1c
 8005a08:	200009c4 	.word	0x200009c4
 8005a0c:	00000000 	.word	0x00000000

08005a10 <pwm_lld_init>:
/**
 * @brief   Low level PWM driver initialization.
 *
 * @notapi
 */
void pwm_lld_init(void) {
 8005a10:	b508      	push	{r3, lr}

#if STM32_PWM_USE_TIM1
  /* Driver initialization.*/
  pwmObjectInit(&PWMD1);
 8005a12:	4805      	ldr	r0, [pc, #20]	; (8005a28 <pwm_lld_init+0x18>)
 8005a14:	f7fc fabc 	bl	8001f90 <pwmObjectInit>
  PWMD1.channels = STM32_TIM1_CHANNELS;
 8005a18:	4b03      	ldr	r3, [pc, #12]	; (8005a28 <pwm_lld_init+0x18>)
 8005a1a:	2204      	movs	r2, #4
 8005a1c:	741a      	strb	r2, [r3, #16]
  PWMD1.tim = STM32_TIM1;
 8005a1e:	4b02      	ldr	r3, [pc, #8]	; (8005a28 <pwm_lld_init+0x18>)
 8005a20:	4a02      	ldr	r2, [pc, #8]	; (8005a2c <pwm_lld_init+0x1c>)
 8005a22:	619a      	str	r2, [r3, #24]
  /* Driver initialization.*/
  pwmObjectInit(&PWMD17);
  PWMD17.channels = STM32_TIM17_CHANNELS;
  PWMD17.tim = STM32_TIM17;
#endif
}
 8005a24:	bd08      	pop	{r3, pc}
 8005a26:	bf00      	nop
 8005a28:	200009c4 	.word	0x200009c4
 8005a2c:	40010000 	.word	0x40010000

08005a30 <pwm_lld_serve_interrupt>:
 *
 * @param[in] pwmp      pointer to a @p PWMDriver object
 *
 * @notapi
 */
void pwm_lld_serve_interrupt(PWMDriver *pwmp) {
 8005a30:	b500      	push	{lr}
 8005a32:	b085      	sub	sp, #20
 8005a34:	9001      	str	r0, [sp, #4]
  uint32_t sr;

  sr  = pwmp->tim->SR;
 8005a36:	9b01      	ldr	r3, [sp, #4]
 8005a38:	699b      	ldr	r3, [r3, #24]
 8005a3a:	691b      	ldr	r3, [r3, #16]
 8005a3c:	9303      	str	r3, [sp, #12]
  sr &= pwmp->tim->DIER & STM32_TIM_DIER_IRQ_MASK;
 8005a3e:	9b01      	ldr	r3, [sp, #4]
 8005a40:	699b      	ldr	r3, [r3, #24]
 8005a42:	68db      	ldr	r3, [r3, #12]
 8005a44:	b2db      	uxtb	r3, r3
 8005a46:	9a03      	ldr	r2, [sp, #12]
 8005a48:	4013      	ands	r3, r2
 8005a4a:	9303      	str	r3, [sp, #12]
  pwmp->tim->SR = ~sr;
 8005a4c:	9b01      	ldr	r3, [sp, #4]
 8005a4e:	699b      	ldr	r3, [r3, #24]
 8005a50:	9a03      	ldr	r2, [sp, #12]
 8005a52:	43d2      	mvns	r2, r2
 8005a54:	611a      	str	r2, [r3, #16]
  if (((sr & STM32_TIM_SR_CC1IF) != 0) &&
 8005a56:	9b03      	ldr	r3, [sp, #12]
 8005a58:	f003 0302 	and.w	r3, r3, #2
 8005a5c:	2b00      	cmp	r3, #0
 8005a5e:	d009      	beq.n	8005a74 <pwm_lld_serve_interrupt+0x44>
      (pwmp->config->channels[0].callback != NULL))
 8005a60:	9b01      	ldr	r3, [sp, #4]
 8005a62:	685b      	ldr	r3, [r3, #4]
 8005a64:	691b      	ldr	r3, [r3, #16]
  if (((sr & STM32_TIM_SR_CC1IF) != 0) &&
 8005a66:	2b00      	cmp	r3, #0
 8005a68:	d004      	beq.n	8005a74 <pwm_lld_serve_interrupt+0x44>
    pwmp->config->channels[0].callback(pwmp);
 8005a6a:	9b01      	ldr	r3, [sp, #4]
 8005a6c:	685b      	ldr	r3, [r3, #4]
 8005a6e:	691b      	ldr	r3, [r3, #16]
 8005a70:	9801      	ldr	r0, [sp, #4]
 8005a72:	4798      	blx	r3
  if (((sr & STM32_TIM_SR_CC2IF) != 0) &&
 8005a74:	9b03      	ldr	r3, [sp, #12]
 8005a76:	f003 0304 	and.w	r3, r3, #4
 8005a7a:	2b00      	cmp	r3, #0
 8005a7c:	d009      	beq.n	8005a92 <pwm_lld_serve_interrupt+0x62>
      (pwmp->config->channels[1].callback != NULL))
 8005a7e:	9b01      	ldr	r3, [sp, #4]
 8005a80:	685b      	ldr	r3, [r3, #4]
 8005a82:	699b      	ldr	r3, [r3, #24]
  if (((sr & STM32_TIM_SR_CC2IF) != 0) &&
 8005a84:	2b00      	cmp	r3, #0
 8005a86:	d004      	beq.n	8005a92 <pwm_lld_serve_interrupt+0x62>
    pwmp->config->channels[1].callback(pwmp);
 8005a88:	9b01      	ldr	r3, [sp, #4]
 8005a8a:	685b      	ldr	r3, [r3, #4]
 8005a8c:	699b      	ldr	r3, [r3, #24]
 8005a8e:	9801      	ldr	r0, [sp, #4]
 8005a90:	4798      	blx	r3
  if (((sr & STM32_TIM_SR_CC3IF) != 0) &&
 8005a92:	9b03      	ldr	r3, [sp, #12]
 8005a94:	f003 0308 	and.w	r3, r3, #8
 8005a98:	2b00      	cmp	r3, #0
 8005a9a:	d009      	beq.n	8005ab0 <pwm_lld_serve_interrupt+0x80>
      (pwmp->config->channels[2].callback != NULL))
 8005a9c:	9b01      	ldr	r3, [sp, #4]
 8005a9e:	685b      	ldr	r3, [r3, #4]
 8005aa0:	6a1b      	ldr	r3, [r3, #32]
  if (((sr & STM32_TIM_SR_CC3IF) != 0) &&
 8005aa2:	2b00      	cmp	r3, #0
 8005aa4:	d004      	beq.n	8005ab0 <pwm_lld_serve_interrupt+0x80>
    pwmp->config->channels[2].callback(pwmp);
 8005aa6:	9b01      	ldr	r3, [sp, #4]
 8005aa8:	685b      	ldr	r3, [r3, #4]
 8005aaa:	6a1b      	ldr	r3, [r3, #32]
 8005aac:	9801      	ldr	r0, [sp, #4]
 8005aae:	4798      	blx	r3
  if (((sr & STM32_TIM_SR_CC4IF) != 0) &&
 8005ab0:	9b03      	ldr	r3, [sp, #12]
 8005ab2:	f003 0310 	and.w	r3, r3, #16
 8005ab6:	2b00      	cmp	r3, #0
 8005ab8:	d009      	beq.n	8005ace <pwm_lld_serve_interrupt+0x9e>
      (pwmp->config->channels[3].callback != NULL))
 8005aba:	9b01      	ldr	r3, [sp, #4]
 8005abc:	685b      	ldr	r3, [r3, #4]
 8005abe:	6a9b      	ldr	r3, [r3, #40]	; 0x28
  if (((sr & STM32_TIM_SR_CC4IF) != 0) &&
 8005ac0:	2b00      	cmp	r3, #0
 8005ac2:	d004      	beq.n	8005ace <pwm_lld_serve_interrupt+0x9e>
    pwmp->config->channels[3].callback(pwmp);
 8005ac4:	9b01      	ldr	r3, [sp, #4]
 8005ac6:	685b      	ldr	r3, [r3, #4]
 8005ac8:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8005aca:	9801      	ldr	r0, [sp, #4]
 8005acc:	4798      	blx	r3
  if (((sr & STM32_TIM_SR_UIF) != 0) && (pwmp->config->callback != NULL))
 8005ace:	9b03      	ldr	r3, [sp, #12]
 8005ad0:	f003 0301 	and.w	r3, r3, #1
 8005ad4:	2b00      	cmp	r3, #0
 8005ad6:	d009      	beq.n	8005aec <pwm_lld_serve_interrupt+0xbc>
 8005ad8:	9b01      	ldr	r3, [sp, #4]
 8005ada:	685b      	ldr	r3, [r3, #4]
 8005adc:	689b      	ldr	r3, [r3, #8]
 8005ade:	2b00      	cmp	r3, #0
 8005ae0:	d004      	beq.n	8005aec <pwm_lld_serve_interrupt+0xbc>
    pwmp->config->callback(pwmp);
 8005ae2:	9b01      	ldr	r3, [sp, #4]
 8005ae4:	685b      	ldr	r3, [r3, #4]
 8005ae6:	689b      	ldr	r3, [r3, #8]
 8005ae8:	9801      	ldr	r0, [sp, #4]
 8005aea:	4798      	blx	r3
}
 8005aec:	b005      	add	sp, #20
 8005aee:	f85d fb04 	ldr.w	pc, [sp], #4
 8005af2:	bf00      	nop
	...

08005b00 <port_lock.lto_priv.297>:
static inline void port_lock(void) {
 8005b00:	b082      	sub	sp, #8
 8005b02:	2320      	movs	r3, #32
 8005b04:	9301      	str	r3, [sp, #4]
 8005b06:	9b01      	ldr	r3, [sp, #4]
 8005b08:	f383 8811 	msr	BASEPRI, r3
}
 8005b0c:	b002      	add	sp, #8
 8005b0e:	4770      	bx	lr

08005b10 <port_unlock.lto_priv.256>:
static inline void port_unlock(void) {
 8005b10:	b082      	sub	sp, #8
 8005b12:	2300      	movs	r3, #0
 8005b14:	9301      	str	r3, [sp, #4]
 8005b16:	9b01      	ldr	r3, [sp, #4]
 8005b18:	f383 8811 	msr	BASEPRI, r3
}
 8005b1c:	b002      	add	sp, #8
 8005b1e:	4770      	bx	lr

08005b20 <port_lock_from_isr.lto_priv.551>:
static inline void port_lock_from_isr(void) {
 8005b20:	b508      	push	{r3, lr}
  port_lock();
 8005b22:	f7ff ffed 	bl	8005b00 <port_lock.lto_priv.297>
}
 8005b26:	bd08      	pop	{r3, pc}
	...

08005b30 <port_unlock_from_isr.lto_priv.539>:
static inline void port_unlock_from_isr(void) {
 8005b30:	b508      	push	{r3, lr}
  port_unlock();
 8005b32:	f7ff ffed 	bl	8005b10 <port_unlock.lto_priv.256>
}
 8005b36:	bd08      	pop	{r3, pc}
	...

08005b40 <chSysLockFromISR.lto_priv.524>:
static inline void chSysLockFromISR(void) {
 8005b40:	b508      	push	{r3, lr}
  port_lock_from_isr();
 8005b42:	f7ff ffed 	bl	8005b20 <port_lock_from_isr.lto_priv.551>
  _dbg_check_lock_from_isr();
 8005b46:	f000 fca3 	bl	8006490 <_dbg_check_lock_from_isr>
}
 8005b4a:	bd08      	pop	{r3, pc}
 8005b4c:	0000      	movs	r0, r0
	...

08005b50 <chSysUnlockFromISR.lto_priv.515>:
static inline void chSysUnlockFromISR(void) {
 8005b50:	b508      	push	{r3, lr}
  _dbg_check_unlock_from_isr();
 8005b52:	f000 fcb5 	bl	80064c0 <_dbg_check_unlock_from_isr>
  port_unlock_from_isr();
 8005b56:	f7ff ffeb 	bl	8005b30 <port_unlock_from_isr.lto_priv.539>
}
 8005b5a:	bd08      	pop	{r3, pc}
 8005b5c:	0000      	movs	r0, r0
	...

08005b60 <osalSysLockFromISR.lto_priv.672>:
static inline void osalSysLockFromISR(void) {
 8005b60:	b508      	push	{r3, lr}
  chSysLockFromISR();
 8005b62:	f7ff ffed 	bl	8005b40 <chSysLockFromISR.lto_priv.524>
}
 8005b66:	bd08      	pop	{r3, pc}
	...

08005b70 <osalSysUnlockFromISR.lto_priv.666>:
static inline void osalSysUnlockFromISR(void) {
 8005b70:	b508      	push	{r3, lr}
  chSysUnlockFromISR();
 8005b72:	f7ff ffed 	bl	8005b50 <chSysUnlockFromISR.lto_priv.515>
}
 8005b76:	bd08      	pop	{r3, pc}
	...

08005b80 <osalEventBroadcastFlagsI.lto_priv.660>:
                                            eventflags_t flags) {
 8005b80:	b500      	push	{lr}
 8005b82:	b083      	sub	sp, #12
 8005b84:	9001      	str	r0, [sp, #4]
 8005b86:	9100      	str	r1, [sp, #0]
  chEvtBroadcastFlagsI(esp, flags);
 8005b88:	9900      	ldr	r1, [sp, #0]
 8005b8a:	9801      	ldr	r0, [sp, #4]
 8005b8c:	f002 f958 	bl	8007e40 <chEvtBroadcastFlagsI>
}
 8005b90:	b003      	add	sp, #12
 8005b92:	f85d fb04 	ldr.w	pc, [sp], #4
 8005b96:	bf00      	nop
	...

08005ba0 <set_error>:
 * @brief   Error handling routine.
 *
 * @param[in] sdp       pointer to a @p SerialDriver object
 * @param[in] sr        USART SR register value
 */
static void set_error(SerialDriver *sdp, uint16_t sr) {
 8005ba0:	b500      	push	{lr}
 8005ba2:	b085      	sub	sp, #20
 8005ba4:	9001      	str	r0, [sp, #4]
 8005ba6:	460b      	mov	r3, r1
 8005ba8:	f8ad 3002 	strh.w	r3, [sp, #2]
  eventflags_t sts = 0;
 8005bac:	2300      	movs	r3, #0
 8005bae:	9303      	str	r3, [sp, #12]

  if (sr & USART_SR_ORE)
 8005bb0:	f8bd 3002 	ldrh.w	r3, [sp, #2]
 8005bb4:	f003 0308 	and.w	r3, r3, #8
 8005bb8:	2b00      	cmp	r3, #0
 8005bba:	d003      	beq.n	8005bc4 <set_error+0x24>
    sts |= SD_OVERRUN_ERROR;
 8005bbc:	9b03      	ldr	r3, [sp, #12]
 8005bbe:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8005bc2:	9303      	str	r3, [sp, #12]
  if (sr & USART_SR_PE)
 8005bc4:	f8bd 3002 	ldrh.w	r3, [sp, #2]
 8005bc8:	f003 0301 	and.w	r3, r3, #1
 8005bcc:	2b00      	cmp	r3, #0
 8005bce:	d003      	beq.n	8005bd8 <set_error+0x38>
    sts |= SD_PARITY_ERROR;
 8005bd0:	9b03      	ldr	r3, [sp, #12]
 8005bd2:	f043 0320 	orr.w	r3, r3, #32
 8005bd6:	9303      	str	r3, [sp, #12]
  if (sr & USART_SR_FE)
 8005bd8:	f8bd 3002 	ldrh.w	r3, [sp, #2]
 8005bdc:	f003 0302 	and.w	r3, r3, #2
 8005be0:	2b00      	cmp	r3, #0
 8005be2:	d003      	beq.n	8005bec <set_error+0x4c>
    sts |= SD_FRAMING_ERROR;
 8005be4:	9b03      	ldr	r3, [sp, #12]
 8005be6:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8005bea:	9303      	str	r3, [sp, #12]
  if (sr & USART_SR_NE)
 8005bec:	f8bd 3002 	ldrh.w	r3, [sp, #2]
 8005bf0:	f003 0304 	and.w	r3, r3, #4
 8005bf4:	2b00      	cmp	r3, #0
 8005bf6:	d003      	beq.n	8005c00 <set_error+0x60>
    sts |= SD_NOISE_ERROR;
 8005bf8:	9b03      	ldr	r3, [sp, #12]
 8005bfa:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 8005bfe:	9303      	str	r3, [sp, #12]
  chnAddFlagsI(sdp, sts);
 8005c00:	9b01      	ldr	r3, [sp, #4]
 8005c02:	3304      	adds	r3, #4
 8005c04:	9903      	ldr	r1, [sp, #12]
 8005c06:	4618      	mov	r0, r3
 8005c08:	f7ff ffba 	bl	8005b80 <osalEventBroadcastFlagsI.lto_priv.660>
}
 8005c0c:	b005      	add	sp, #20
 8005c0e:	f85d fb04 	ldr.w	pc, [sp], #4
 8005c12:	bf00      	nop
	...

08005c20 <serve_interrupt>:
/**
 * @brief   Common IRQ handler.
 *
 * @param[in] sdp       communication channel associated to the USART
 */
static void serve_interrupt(SerialDriver *sdp) {
 8005c20:	b500      	push	{lr}
 8005c22:	b089      	sub	sp, #36	; 0x24
 8005c24:	9001      	str	r0, [sp, #4]
  USART_TypeDef *u = sdp->usart;
 8005c26:	9b01      	ldr	r3, [sp, #4]
 8005c28:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 8005c2a:	9306      	str	r3, [sp, #24]
  uint16_t cr1 = u->CR1;
 8005c2c:	9b06      	ldr	r3, [sp, #24]
 8005c2e:	68db      	ldr	r3, [r3, #12]
 8005c30:	f8ad 3016 	strh.w	r3, [sp, #22]
  uint16_t sr = u->SR;
 8005c34:	9b06      	ldr	r3, [sp, #24]
 8005c36:	681b      	ldr	r3, [r3, #0]
 8005c38:	f8ad 301e 	strh.w	r3, [sp, #30]

  /* Special case, LIN break detection.*/
  if (sr & USART_SR_LBD) {
 8005c3c:	f8bd 301e 	ldrh.w	r3, [sp, #30]
 8005c40:	f403 7380 	and.w	r3, r3, #256	; 0x100
 8005c44:	2b00      	cmp	r3, #0
 8005c46:	d00e      	beq.n	8005c66 <serve_interrupt+0x46>
    osalSysLockFromISR();
 8005c48:	f7ff ff8a 	bl	8005b60 <osalSysLockFromISR.lto_priv.672>
    chnAddFlagsI(sdp, SD_BREAK_DETECTED);
 8005c4c:	9b01      	ldr	r3, [sp, #4]
 8005c4e:	3304      	adds	r3, #4
 8005c50:	f44f 7100 	mov.w	r1, #512	; 0x200
 8005c54:	4618      	mov	r0, r3
 8005c56:	f7ff ff93 	bl	8005b80 <osalEventBroadcastFlagsI.lto_priv.660>
    u->SR = ~USART_SR_LBD;
 8005c5a:	9b06      	ldr	r3, [sp, #24]
 8005c5c:	f46f 7280 	mvn.w	r2, #256	; 0x100
 8005c60:	601a      	str	r2, [r3, #0]
    osalSysUnlockFromISR();
 8005c62:	f7ff ff85 	bl	8005b70 <osalSysUnlockFromISR.lto_priv.666>
  }

  /* Data available.*/
  osalSysLockFromISR();
 8005c66:	f7ff ff7b 	bl	8005b60 <osalSysLockFromISR.lto_priv.672>
 8005c6a:	e024      	b.n	8005cb6 <serve_interrupt+0x96>
  while (sr & (USART_SR_RXNE | USART_SR_ORE | USART_SR_NE | USART_SR_FE |
               USART_SR_PE)) {
    uint8_t b;

    /* Error condition detection.*/
    if (sr & (USART_SR_ORE | USART_SR_NE | USART_SR_FE  | USART_SR_PE))
 8005c6c:	f8bd 301e 	ldrh.w	r3, [sp, #30]
 8005c70:	f003 030f 	and.w	r3, r3, #15
 8005c74:	2b00      	cmp	r3, #0
 8005c76:	d005      	beq.n	8005c84 <serve_interrupt+0x64>
      set_error(sdp, sr);
 8005c78:	f8bd 301e 	ldrh.w	r3, [sp, #30]
 8005c7c:	4619      	mov	r1, r3
 8005c7e:	9801      	ldr	r0, [sp, #4]
 8005c80:	f7ff ff8e 	bl	8005ba0 <set_error>
    b = (uint8_t)u->DR & sdp->rxmask;
 8005c84:	9b06      	ldr	r3, [sp, #24]
 8005c86:	685b      	ldr	r3, [r3, #4]
 8005c88:	b2da      	uxtb	r2, r3
 8005c8a:	9b01      	ldr	r3, [sp, #4]
 8005c8c:	f893 3078 	ldrb.w	r3, [r3, #120]	; 0x78
 8005c90:	4013      	ands	r3, r2
 8005c92:	f88d 300f 	strb.w	r3, [sp, #15]
    if (sr & USART_SR_RXNE)
 8005c96:	f8bd 301e 	ldrh.w	r3, [sp, #30]
 8005c9a:	f003 0320 	and.w	r3, r3, #32
 8005c9e:	2b00      	cmp	r3, #0
 8005ca0:	d005      	beq.n	8005cae <serve_interrupt+0x8e>
      sdIncomingDataI(sdp, b);
 8005ca2:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8005ca6:	4619      	mov	r1, r3
 8005ca8:	9801      	ldr	r0, [sp, #4]
 8005caa:	f7fc fab9 	bl	8002220 <sdIncomingDataI>
    sr = u->SR;
 8005cae:	9b06      	ldr	r3, [sp, #24]
 8005cb0:	681b      	ldr	r3, [r3, #0]
 8005cb2:	f8ad 301e 	strh.w	r3, [sp, #30]
  while (sr & (USART_SR_RXNE | USART_SR_ORE | USART_SR_NE | USART_SR_FE |
 8005cb6:	f8bd 301e 	ldrh.w	r3, [sp, #30]
 8005cba:	f003 032f 	and.w	r3, r3, #47	; 0x2f
 8005cbe:	2b00      	cmp	r3, #0
 8005cc0:	d1d4      	bne.n	8005c6c <serve_interrupt+0x4c>
  }
  osalSysUnlockFromISR();
 8005cc2:	f7ff ff55 	bl	8005b70 <osalSysUnlockFromISR.lto_priv.666>

  /* Transmission buffer empty.*/
  if ((cr1 & USART_CR1_TXEIE) && (sr & USART_SR_TXE)) {
 8005cc6:	f8bd 3016 	ldrh.w	r3, [sp, #22]
 8005cca:	f003 0380 	and.w	r3, r3, #128	; 0x80
 8005cce:	2b00      	cmp	r3, #0
 8005cd0:	d022      	beq.n	8005d18 <serve_interrupt+0xf8>
 8005cd2:	f8bd 301e 	ldrh.w	r3, [sp, #30]
 8005cd6:	f003 0380 	and.w	r3, r3, #128	; 0x80
 8005cda:	2b00      	cmp	r3, #0
 8005cdc:	d01c      	beq.n	8005d18 <serve_interrupt+0xf8>
    msg_t b;
    osalSysLockFromISR();
 8005cde:	f7ff ff3f 	bl	8005b60 <osalSysLockFromISR.lto_priv.672>
    b = oqGetI(&sdp->oqueue);
 8005ce2:	9b01      	ldr	r3, [sp, #4]
 8005ce4:	3330      	adds	r3, #48	; 0x30
 8005ce6:	4618      	mov	r0, r3
 8005ce8:	f7fc f8c2 	bl	8001e70 <oqGetI>
 8005cec:	9004      	str	r0, [sp, #16]
    if (b < MSG_OK) {
 8005cee:	9b04      	ldr	r3, [sp, #16]
 8005cf0:	2b00      	cmp	r3, #0
 8005cf2:	da0c      	bge.n	8005d0e <serve_interrupt+0xee>
      chnAddFlagsI(sdp, CHN_OUTPUT_EMPTY);
 8005cf4:	9b01      	ldr	r3, [sp, #4]
 8005cf6:	3304      	adds	r3, #4
 8005cf8:	2108      	movs	r1, #8
 8005cfa:	4618      	mov	r0, r3
 8005cfc:	f7ff ff40 	bl	8005b80 <osalEventBroadcastFlagsI.lto_priv.660>
      u->CR1 = cr1 & ~USART_CR1_TXEIE;
 8005d00:	f8bd 3016 	ldrh.w	r3, [sp, #22]
 8005d04:	f023 0280 	bic.w	r2, r3, #128	; 0x80
 8005d08:	9b06      	ldr	r3, [sp, #24]
 8005d0a:	60da      	str	r2, [r3, #12]
 8005d0c:	e002      	b.n	8005d14 <serve_interrupt+0xf4>
    }
    else
      u->DR = b;
 8005d0e:	9a04      	ldr	r2, [sp, #16]
 8005d10:	9b06      	ldr	r3, [sp, #24]
 8005d12:	605a      	str	r2, [r3, #4]
    osalSysUnlockFromISR();
 8005d14:	f7ff ff2c 	bl	8005b70 <osalSysUnlockFromISR.lto_priv.666>
  }

  /* Physical transmission end.*/
  if ((cr1 & USART_CR1_TCIE) && (sr & USART_SR_TC)) {
 8005d18:	f8bd 3016 	ldrh.w	r3, [sp, #22]
 8005d1c:	f003 0340 	and.w	r3, r3, #64	; 0x40
 8005d20:	2b00      	cmp	r3, #0
 8005d22:	d027      	beq.n	8005d74 <serve_interrupt+0x154>
 8005d24:	f8bd 301e 	ldrh.w	r3, [sp, #30]
 8005d28:	f003 0340 	and.w	r3, r3, #64	; 0x40
 8005d2c:	2b00      	cmp	r3, #0
 8005d2e:	d021      	beq.n	8005d74 <serve_interrupt+0x154>
    osalSysLockFromISR();
 8005d30:	f7ff ff16 	bl	8005b60 <osalSysLockFromISR.lto_priv.672>
    if (oqIsEmptyI(&sdp->oqueue)) {
 8005d34:	9b01      	ldr	r3, [sp, #4]
 8005d36:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 8005d38:	9b01      	ldr	r3, [sp, #4]
 8005d3a:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8005d3c:	429a      	cmp	r2, r3
 8005d3e:	d105      	bne.n	8005d4c <serve_interrupt+0x12c>
 8005d40:	9b01      	ldr	r3, [sp, #4]
 8005d42:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8005d44:	2b00      	cmp	r3, #0
 8005d46:	d001      	beq.n	8005d4c <serve_interrupt+0x12c>
 8005d48:	2301      	movs	r3, #1
 8005d4a:	e000      	b.n	8005d4e <serve_interrupt+0x12e>
 8005d4c:	2300      	movs	r3, #0
 8005d4e:	f003 0301 	and.w	r3, r3, #1
 8005d52:	b2db      	uxtb	r3, r3
 8005d54:	2b00      	cmp	r3, #0
 8005d56:	d00b      	beq.n	8005d70 <serve_interrupt+0x150>
      chnAddFlagsI(sdp, CHN_TRANSMISSION_END);
 8005d58:	9b01      	ldr	r3, [sp, #4]
 8005d5a:	3304      	adds	r3, #4
 8005d5c:	2110      	movs	r1, #16
 8005d5e:	4618      	mov	r0, r3
 8005d60:	f7ff ff0e 	bl	8005b80 <osalEventBroadcastFlagsI.lto_priv.660>
      u->CR1 = cr1 & ~USART_CR1_TCIE;
 8005d64:	f8bd 3016 	ldrh.w	r3, [sp, #22]
 8005d68:	f023 0240 	bic.w	r2, r3, #64	; 0x40
 8005d6c:	9b06      	ldr	r3, [sp, #24]
 8005d6e:	60da      	str	r2, [r3, #12]
    }
    osalSysUnlockFromISR();
 8005d70:	f7ff fefe 	bl	8005b70 <osalSysUnlockFromISR.lto_priv.666>
  }
}
 8005d74:	b009      	add	sp, #36	; 0x24
 8005d76:	f85d fb04 	ldr.w	pc, [sp], #4
 8005d7a:	bf00      	nop
 8005d7c:	0000      	movs	r0, r0
	...

08005d80 <notify2>:
  USART1->CR1 |= USART_CR1_TXEIE | USART_CR1_TCIE;
}
#endif

#if STM32_SERIAL_USE_USART2 || defined(__DOXYGEN__)
static void notify2(io_queue_t *qp) {
 8005d80:	b082      	sub	sp, #8
 8005d82:	9001      	str	r0, [sp, #4]

  (void)qp;
  USART2->CR1 |= USART_CR1_TXEIE | USART_CR1_TCIE;
 8005d84:	4b03      	ldr	r3, [pc, #12]	; (8005d94 <notify2+0x14>)
 8005d86:	68db      	ldr	r3, [r3, #12]
 8005d88:	4a02      	ldr	r2, [pc, #8]	; (8005d94 <notify2+0x14>)
 8005d8a:	f043 03c0 	orr.w	r3, r3, #192	; 0xc0
 8005d8e:	60d3      	str	r3, [r2, #12]
}
 8005d90:	b002      	add	sp, #8
 8005d92:	4770      	bx	lr
 8005d94:	40004400 	.word	0x40004400
	...

08005da0 <VectorD8>:
/**
 * @brief   USART2 interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_USART2_HANDLER) {
 8005da0:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();
 8005da2:	4808      	ldr	r0, [pc, #32]	; (8005dc4 <VectorD8+0x24>)
 8005da4:	f000 fcd4 	bl	8006750 <_trace_isr_enter>
 8005da8:	f000 fba2 	bl	80064f0 <_dbg_check_enter_isr>

  serve_interrupt(&SD2);
 8005dac:	4806      	ldr	r0, [pc, #24]	; (8005dc8 <VectorD8+0x28>)
 8005dae:	f7ff ff37 	bl	8005c20 <serve_interrupt>

  OSAL_IRQ_EPILOGUE();
 8005db2:	f000 fbbd 	bl	8006530 <_dbg_check_leave_isr>
 8005db6:	4803      	ldr	r0, [pc, #12]	; (8005dc4 <VectorD8+0x24>)
 8005db8:	f000 fcf2 	bl	80067a0 <_trace_isr_leave>
 8005dbc:	f002 fb30 	bl	8008420 <_port_irq_epilogue>
}
 8005dc0:	bd08      	pop	{r3, pc}
 8005dc2:	bf00      	nop
 8005dc4:	08008b28 	.word	0x08008b28
 8005dc8:	200009e0 	.word	0x200009e0
 8005dcc:	00000000 	.word	0x00000000

08005dd0 <sd_lld_init>:
/**
 * @brief   Low level serial driver initialization.
 *
 * @notapi
 */
void sd_lld_init(void) {
 8005dd0:	b508      	push	{r3, lr}
  sdObjectInit(&SD1, NULL, notify1);
  SD1.usart = USART1;
#endif

#if STM32_SERIAL_USE_USART2
  sdObjectInit(&SD2, NULL, notify2);
 8005dd2:	4a04      	ldr	r2, [pc, #16]	; (8005de4 <sd_lld_init+0x14>)
 8005dd4:	2100      	movs	r1, #0
 8005dd6:	4804      	ldr	r0, [pc, #16]	; (8005de8 <sd_lld_init+0x18>)
 8005dd8:	f7fc f9f2 	bl	80021c0 <sdObjectInit>
  SD2.usart = USART2;
 8005ddc:	4b02      	ldr	r3, [pc, #8]	; (8005de8 <sd_lld_init+0x18>)
 8005dde:	4a03      	ldr	r2, [pc, #12]	; (8005dec <sd_lld_init+0x1c>)
 8005de0:	675a      	str	r2, [r3, #116]	; 0x74

#if STM32_SERIAL_USE_UART8
  sdObjectInit(&SD8, NULL, notify8);
  SD8.usart = UART8;
#endif
}
 8005de2:	bd08      	pop	{r3, pc}
 8005de4:	08005d81 	.word	0x08005d81
 8005de8:	200009e0 	.word	0x200009e0
 8005dec:	40004400 	.word	0x40004400

08005df0 <gpio_init>:

/*===========================================================================*/
/* Driver local functions.                                                   */
/*===========================================================================*/

static void gpio_init(stm32_gpio_t *gpiop, const gpio_setup_t *config) {
 8005df0:	b082      	sub	sp, #8
 8005df2:	9001      	str	r0, [sp, #4]
 8005df4:	9100      	str	r1, [sp, #0]

  gpiop->OTYPER  = config->otyper;
 8005df6:	9b00      	ldr	r3, [sp, #0]
 8005df8:	685a      	ldr	r2, [r3, #4]
 8005dfa:	9b01      	ldr	r3, [sp, #4]
 8005dfc:	605a      	str	r2, [r3, #4]
  gpiop->OSPEEDR = config->ospeedr;
 8005dfe:	9b00      	ldr	r3, [sp, #0]
 8005e00:	689a      	ldr	r2, [r3, #8]
 8005e02:	9b01      	ldr	r3, [sp, #4]
 8005e04:	609a      	str	r2, [r3, #8]
  gpiop->PUPDR   = config->pupdr;
 8005e06:	9b00      	ldr	r3, [sp, #0]
 8005e08:	68da      	ldr	r2, [r3, #12]
 8005e0a:	9b01      	ldr	r3, [sp, #4]
 8005e0c:	60da      	str	r2, [r3, #12]
  gpiop->ODR     = config->odr;
 8005e0e:	9b00      	ldr	r3, [sp, #0]
 8005e10:	691a      	ldr	r2, [r3, #16]
 8005e12:	9b01      	ldr	r3, [sp, #4]
 8005e14:	615a      	str	r2, [r3, #20]
  gpiop->AFRL    = config->afrl;
 8005e16:	9b00      	ldr	r3, [sp, #0]
 8005e18:	695a      	ldr	r2, [r3, #20]
 8005e1a:	9b01      	ldr	r3, [sp, #4]
 8005e1c:	621a      	str	r2, [r3, #32]
  gpiop->AFRH    = config->afrh;
 8005e1e:	9b00      	ldr	r3, [sp, #0]
 8005e20:	699a      	ldr	r2, [r3, #24]
 8005e22:	9b01      	ldr	r3, [sp, #4]
 8005e24:	625a      	str	r2, [r3, #36]	; 0x24
  gpiop->MODER   = config->moder;
 8005e26:	9b00      	ldr	r3, [sp, #0]
 8005e28:	681a      	ldr	r2, [r3, #0]
 8005e2a:	9b01      	ldr	r3, [sp, #4]
 8005e2c:	601a      	str	r2, [r3, #0]
}
 8005e2e:	b002      	add	sp, #8
 8005e30:	4770      	bx	lr
 8005e32:	bf00      	nop
	...

08005e40 <stm32_gpio_init>:

static void stm32_gpio_init(void) {
 8005e40:	b508      	push	{r3, lr}

  /* Enabling GPIO-related clocks, the mask comes from the
     registry header file.*/
  rccResetAHB1(STM32_GPIO_EN_MASK);
 8005e42:	4b24      	ldr	r3, [pc, #144]	; (8005ed4 <stm32_gpio_init+0x94>)
 8005e44:	691b      	ldr	r3, [r3, #16]
 8005e46:	4a23      	ldr	r2, [pc, #140]	; (8005ed4 <stm32_gpio_init+0x94>)
 8005e48:	ea6f 2353 	mvn.w	r3, r3, lsr #9
 8005e4c:	ea6f 2343 	mvn.w	r3, r3, lsl #9
 8005e50:	6113      	str	r3, [r2, #16]
 8005e52:	4b20      	ldr	r3, [pc, #128]	; (8005ed4 <stm32_gpio_init+0x94>)
 8005e54:	691b      	ldr	r3, [r3, #16]
 8005e56:	4a1f      	ldr	r2, [pc, #124]	; (8005ed4 <stm32_gpio_init+0x94>)
 8005e58:	f423 73ff 	bic.w	r3, r3, #510	; 0x1fe
 8005e5c:	f023 0301 	bic.w	r3, r3, #1
 8005e60:	6113      	str	r3, [r2, #16]
 8005e62:	4b1c      	ldr	r3, [pc, #112]	; (8005ed4 <stm32_gpio_init+0x94>)
 8005e64:	691b      	ldr	r3, [r3, #16]
  rccEnableAHB1(STM32_GPIO_EN_MASK, true);
 8005e66:	4b1b      	ldr	r3, [pc, #108]	; (8005ed4 <stm32_gpio_init+0x94>)
 8005e68:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8005e6a:	4a1a      	ldr	r2, [pc, #104]	; (8005ed4 <stm32_gpio_init+0x94>)
 8005e6c:	ea6f 2353 	mvn.w	r3, r3, lsr #9
 8005e70:	ea6f 2343 	mvn.w	r3, r3, lsl #9
 8005e74:	6313      	str	r3, [r2, #48]	; 0x30
 8005e76:	4b17      	ldr	r3, [pc, #92]	; (8005ed4 <stm32_gpio_init+0x94>)
 8005e78:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 8005e7a:	4a16      	ldr	r2, [pc, #88]	; (8005ed4 <stm32_gpio_init+0x94>)
 8005e7c:	ea6f 2353 	mvn.w	r3, r3, lsr #9
 8005e80:	ea6f 2343 	mvn.w	r3, r3, lsl #9
 8005e84:	6513      	str	r3, [r2, #80]	; 0x50
 8005e86:	4b13      	ldr	r3, [pc, #76]	; (8005ed4 <stm32_gpio_init+0x94>)
 8005e88:	6d1b      	ldr	r3, [r3, #80]	; 0x50

  /* Initializing all the defined GPIO ports.*/
#if STM32_HAS_GPIOA
  gpio_init(GPIOA, &gpio_default_config.PAData);
 8005e8a:	4913      	ldr	r1, [pc, #76]	; (8005ed8 <stm32_gpio_init+0x98>)
 8005e8c:	4813      	ldr	r0, [pc, #76]	; (8005edc <stm32_gpio_init+0x9c>)
 8005e8e:	f7ff ffaf 	bl	8005df0 <gpio_init>
#endif
#if STM32_HAS_GPIOB
  gpio_init(GPIOB, &gpio_default_config.PBData);
 8005e92:	4913      	ldr	r1, [pc, #76]	; (8005ee0 <stm32_gpio_init+0xa0>)
 8005e94:	4813      	ldr	r0, [pc, #76]	; (8005ee4 <stm32_gpio_init+0xa4>)
 8005e96:	f7ff ffab 	bl	8005df0 <gpio_init>
#endif
#if STM32_HAS_GPIOC
  gpio_init(GPIOC, &gpio_default_config.PCData);
 8005e9a:	4913      	ldr	r1, [pc, #76]	; (8005ee8 <stm32_gpio_init+0xa8>)
 8005e9c:	4813      	ldr	r0, [pc, #76]	; (8005eec <stm32_gpio_init+0xac>)
 8005e9e:	f7ff ffa7 	bl	8005df0 <gpio_init>
#endif
#if STM32_HAS_GPIOD
  gpio_init(GPIOD, &gpio_default_config.PDData);
 8005ea2:	4913      	ldr	r1, [pc, #76]	; (8005ef0 <stm32_gpio_init+0xb0>)
 8005ea4:	4813      	ldr	r0, [pc, #76]	; (8005ef4 <stm32_gpio_init+0xb4>)
 8005ea6:	f7ff ffa3 	bl	8005df0 <gpio_init>
#endif
#if STM32_HAS_GPIOE
  gpio_init(GPIOE, &gpio_default_config.PEData);
 8005eaa:	4913      	ldr	r1, [pc, #76]	; (8005ef8 <stm32_gpio_init+0xb8>)
 8005eac:	4813      	ldr	r0, [pc, #76]	; (8005efc <stm32_gpio_init+0xbc>)
 8005eae:	f7ff ff9f 	bl	8005df0 <gpio_init>
#endif
#if STM32_HAS_GPIOF
  gpio_init(GPIOF, &gpio_default_config.PFData);
 8005eb2:	4913      	ldr	r1, [pc, #76]	; (8005f00 <stm32_gpio_init+0xc0>)
 8005eb4:	4813      	ldr	r0, [pc, #76]	; (8005f04 <stm32_gpio_init+0xc4>)
 8005eb6:	f7ff ff9b 	bl	8005df0 <gpio_init>
#endif
#if STM32_HAS_GPIOG
  gpio_init(GPIOG, &gpio_default_config.PGData);
 8005eba:	4913      	ldr	r1, [pc, #76]	; (8005f08 <stm32_gpio_init+0xc8>)
 8005ebc:	4813      	ldr	r0, [pc, #76]	; (8005f0c <stm32_gpio_init+0xcc>)
 8005ebe:	f7ff ff97 	bl	8005df0 <gpio_init>
#endif
#if STM32_HAS_GPIOH
  gpio_init(GPIOH, &gpio_default_config.PHData);
 8005ec2:	4913      	ldr	r1, [pc, #76]	; (8005f10 <stm32_gpio_init+0xd0>)
 8005ec4:	4813      	ldr	r0, [pc, #76]	; (8005f14 <stm32_gpio_init+0xd4>)
 8005ec6:	f7ff ff93 	bl	8005df0 <gpio_init>
#endif
#if STM32_HAS_GPIOI
  gpio_init(GPIOI, &gpio_default_config.PIData);
 8005eca:	4913      	ldr	r1, [pc, #76]	; (8005f18 <stm32_gpio_init+0xd8>)
 8005ecc:	4813      	ldr	r0, [pc, #76]	; (8005f1c <stm32_gpio_init+0xdc>)
 8005ece:	f7ff ff8f 	bl	8005df0 <gpio_init>
  gpio_init(GPIOJ, &gpio_default_config.PJData);
#endif
#if STM32_HAS_GPIOK
  gpio_init(GPIOK, &gpio_default_config.PKData);
#endif
}
 8005ed2:	bd08      	pop	{r3, pc}
 8005ed4:	40023800 	.word	0x40023800
 8005ed8:	08008b34 	.word	0x08008b34
 8005edc:	40020000 	.word	0x40020000
 8005ee0:	08008b50 	.word	0x08008b50
 8005ee4:	40020400 	.word	0x40020400
 8005ee8:	08008b6c 	.word	0x08008b6c
 8005eec:	40020800 	.word	0x40020800
 8005ef0:	08008b88 	.word	0x08008b88
 8005ef4:	40020c00 	.word	0x40020c00
 8005ef8:	08008ba4 	.word	0x08008ba4
 8005efc:	40021000 	.word	0x40021000
 8005f00:	08008bc0 	.word	0x08008bc0
 8005f04:	40021400 	.word	0x40021400
 8005f08:	08008bdc 	.word	0x08008bdc
 8005f0c:	40021800 	.word	0x40021800
 8005f10:	08008bf8 	.word	0x08008bf8
 8005f14:	40021c00 	.word	0x40021c00
 8005f18:	08008c14 	.word	0x08008c14
 8005f1c:	40022000 	.word	0x40022000

08005f20 <__early_init>:
/**
 * @brief   Early initialization code.
 * @details GPIO ports and system clocks are initialized before everything
 *          else.
 */
void __early_init(void) {
 8005f20:	b508      	push	{r3, lr}

  stm32_gpio_init();
 8005f22:	f7ff ff8d 	bl	8005e40 <stm32_gpio_init>
  stm32_clock_init();
 8005f26:	f7fd fd1b 	bl	8003960 <stm32_clock_init>
}
 8005f2a:	bd08      	pop	{r3, pc}
 8005f2c:	0000      	movs	r0, r0
	...

08005f30 <boardInit>:
 * @brief   Board-specific initialization code.
 * @todo    Add your board-specific code, if any.
 */
void boardInit(void) {

}
 8005f30:	4770      	bx	lr
 8005f32:	bf00      	nop
	...

08005f40 <chTimeAddX.lto_priv.459>:
 * @return              The new system time.
 *
 * @xclass
 */
static inline systime_t chTimeAddX(systime_t systime,
                                   sysinterval_t interval) {
 8005f40:	b082      	sub	sp, #8
 8005f42:	9001      	str	r0, [sp, #4]
 8005f44:	9100      	str	r1, [sp, #0]

#if CH_CFG_ST_RESOLUTION != CH_CFG_INTERVALS_SIZE
  chDbgCheck(interval <= (sysinterval_t)((systime_t)-1));
#endif

  return systime + (systime_t)interval;
 8005f46:	9a01      	ldr	r2, [sp, #4]
 8005f48:	9b00      	ldr	r3, [sp, #0]
 8005f4a:	4413      	add	r3, r2
}
 8005f4c:	4618      	mov	r0, r3
 8005f4e:	b002      	add	sp, #8
 8005f50:	4770      	bx	lr
 8005f52:	bf00      	nop
	...

08005f60 <chTimeDiffX.lto_priv.644>:
 * @param[in] end       second system time
 * @return              The interval representing the time difference.
 *
 * @xclass
 */
static inline sysinterval_t chTimeDiffX(systime_t start, systime_t end) {
 8005f60:	b082      	sub	sp, #8
 8005f62:	9001      	str	r0, [sp, #4]
 8005f64:	9100      	str	r1, [sp, #0]

  /*lint -save -e9033 [10.8] This cast is required by the operation, it is
    known that the destination type can be wider.*/
  return (sysinterval_t)((systime_t)(end - start));
 8005f66:	9a00      	ldr	r2, [sp, #0]
 8005f68:	9b01      	ldr	r3, [sp, #4]
 8005f6a:	1ad3      	subs	r3, r2, r3
  /*lint -restore*/
}
 8005f6c:	4618      	mov	r0, r3
 8005f6e:	b002      	add	sp, #8
 8005f70:	4770      	bx	lr
 8005f72:	bf00      	nop
	...

08005f80 <__NVIC_SetPriorityGrouping>:
           In case of a conflict between priority grouping and available
           priority bits (__NVIC_PRIO_BITS), the smallest possible priority group is set.
  \param [in]      PriorityGroup  Priority grouping field.
 */
__STATIC_INLINE void __NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
 8005f80:	b084      	sub	sp, #16
 8005f82:	9001      	str	r0, [sp, #4]
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */
 8005f84:	9b01      	ldr	r3, [sp, #4]
 8005f86:	f003 0307 	and.w	r3, r3, #7
 8005f8a:	9303      	str	r3, [sp, #12]

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 8005f8c:	4b0a      	ldr	r3, [pc, #40]	; (8005fb8 <__NVIC_SetPriorityGrouping+0x38>)
 8005f8e:	68db      	ldr	r3, [r3, #12]
 8005f90:	9302      	str	r3, [sp, #8]
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
 8005f92:	9a02      	ldr	r2, [sp, #8]
 8005f94:	f64f 03ff 	movw	r3, #63743	; 0xf8ff
 8005f98:	4013      	ands	r3, r2
 8005f9a:	9302      	str	r3, [sp, #8]
  reg_value  =  (reg_value                                   |
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << SCB_AIRCR_PRIGROUP_Pos)  );              /* Insert write key and priority group */
 8005f9c:	9b03      	ldr	r3, [sp, #12]
 8005f9e:	021a      	lsls	r2, r3, #8
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
 8005fa0:	9b02      	ldr	r3, [sp, #8]
 8005fa2:	4313      	orrs	r3, r2
  reg_value  =  (reg_value                                   |
 8005fa4:	f043 63bf 	orr.w	r3, r3, #100139008	; 0x5f80000
 8005fa8:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
 8005fac:	9302      	str	r3, [sp, #8]
  SCB->AIRCR =  reg_value;
 8005fae:	4a02      	ldr	r2, [pc, #8]	; (8005fb8 <__NVIC_SetPriorityGrouping+0x38>)
 8005fb0:	9b02      	ldr	r3, [sp, #8]
 8005fb2:	60d3      	str	r3, [r2, #12]
}
 8005fb4:	b004      	add	sp, #16
 8005fb6:	4770      	bx	lr
 8005fb8:	e000ed00 	.word	0xe000ed00
 8005fbc:	00000000 	.word	0x00000000

08005fc0 <__NVIC_SetPriority>:
  \param [in]      IRQn  Interrupt number.
  \param [in]  priority  Priority to set.
  \note    The priority cannot be set for every processor exception.
 */
__STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
 8005fc0:	b082      	sub	sp, #8
 8005fc2:	4603      	mov	r3, r0
 8005fc4:	9100      	str	r1, [sp, #0]
 8005fc6:	f88d 3007 	strb.w	r3, [sp, #7]
  if ((int32_t)(IRQn) >= 0)
 8005fca:	f99d 3007 	ldrsb.w	r3, [sp, #7]
 8005fce:	2b00      	cmp	r3, #0
 8005fd0:	db0a      	blt.n	8005fe8 <__NVIC_SetPriority+0x28>
  {
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8005fd2:	9b00      	ldr	r3, [sp, #0]
 8005fd4:	b2da      	uxtb	r2, r3
 8005fd6:	490b      	ldr	r1, [pc, #44]	; (8006004 <__NVIC_SetPriority+0x44>)
 8005fd8:	f99d 3007 	ldrsb.w	r3, [sp, #7]
 8005fdc:	0112      	lsls	r2, r2, #4
 8005fde:	b2d2      	uxtb	r2, r2
 8005fe0:	440b      	add	r3, r1
 8005fe2:	f883 2300 	strb.w	r2, [r3, #768]	; 0x300
 8005fe6:	e00b      	b.n	8006000 <__NVIC_SetPriority+0x40>
  }
  else
  {
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8005fe8:	9b00      	ldr	r3, [sp, #0]
 8005fea:	b2da      	uxtb	r2, r3
 8005fec:	4906      	ldr	r1, [pc, #24]	; (8006008 <__NVIC_SetPriority+0x48>)
 8005fee:	f89d 3007 	ldrb.w	r3, [sp, #7]
 8005ff2:	f003 030f 	and.w	r3, r3, #15
 8005ff6:	3b04      	subs	r3, #4
 8005ff8:	0112      	lsls	r2, r2, #4
 8005ffa:	b2d2      	uxtb	r2, r2
 8005ffc:	440b      	add	r3, r1
 8005ffe:	761a      	strb	r2, [r3, #24]
  }
}
 8006000:	b002      	add	sp, #8
 8006002:	4770      	bx	lr
 8006004:	e000e100 	.word	0xe000e100
 8006008:	e000ed00 	.word	0xe000ed00
 800600c:	00000000 	.word	0x00000000

08006010 <port_init>:
static inline void port_init(void) {
 8006010:	b508      	push	{r3, lr}
  NVIC_SetPriorityGrouping(CORTEX_PRIGROUP_INIT);
 8006012:	2003      	movs	r0, #3
 8006014:	f7ff ffb4 	bl	8005f80 <__NVIC_SetPriorityGrouping>
  CoreDebug->DEMCR |= CoreDebug_DEMCR_TRCENA_Msk;
 8006018:	4b0b      	ldr	r3, [pc, #44]	; (8006048 <port_init+0x38>)
 800601a:	68db      	ldr	r3, [r3, #12]
 800601c:	4a0a      	ldr	r2, [pc, #40]	; (8006048 <port_init+0x38>)
 800601e:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
 8006022:	60d3      	str	r3, [r2, #12]
  DWT->CTRL |= DWT_CTRL_CYCCNTENA_Msk;
 8006024:	4b09      	ldr	r3, [pc, #36]	; (800604c <port_init+0x3c>)
 8006026:	681b      	ldr	r3, [r3, #0]
 8006028:	4a08      	ldr	r2, [pc, #32]	; (800604c <port_init+0x3c>)
 800602a:	f043 0301 	orr.w	r3, r3, #1
 800602e:	6013      	str	r3, [r2, #0]
  NVIC_SetPriority(SVCall_IRQn, CORTEX_PRIORITY_SVCALL);
 8006030:	2101      	movs	r1, #1
 8006032:	f06f 0004 	mvn.w	r0, #4
 8006036:	f7ff ffc3 	bl	8005fc0 <__NVIC_SetPriority>
  NVIC_SetPriority(PendSV_IRQn, CORTEX_PRIORITY_PENDSV);
 800603a:	2102      	movs	r1, #2
 800603c:	f06f 0001 	mvn.w	r0, #1
 8006040:	f7ff ffbe 	bl	8005fc0 <__NVIC_SetPriority>
}
 8006044:	bd08      	pop	{r3, pc}
 8006046:	bf00      	nop
 8006048:	e000edf0 	.word	0xe000edf0
 800604c:	e0001000 	.word	0xe0001000

08006050 <port_lock.lto_priv.298>:
static inline void port_lock(void) {
 8006050:	b082      	sub	sp, #8
 8006052:	2320      	movs	r3, #32
 8006054:	9301      	str	r3, [sp, #4]
 8006056:	9b01      	ldr	r3, [sp, #4]
 8006058:	f383 8811 	msr	BASEPRI, r3
}
 800605c:	b002      	add	sp, #8
 800605e:	4770      	bx	lr

08006060 <port_unlock.lto_priv.257>:
static inline void port_unlock(void) {
 8006060:	b082      	sub	sp, #8
 8006062:	2300      	movs	r3, #0
 8006064:	9301      	str	r3, [sp, #4]
 8006066:	9b01      	ldr	r3, [sp, #4]
 8006068:	f383 8811 	msr	BASEPRI, r3
}
 800606c:	b002      	add	sp, #8
 800606e:	4770      	bx	lr

08006070 <port_lock_from_isr.lto_priv.552>:
static inline void port_lock_from_isr(void) {
 8006070:	b508      	push	{r3, lr}
  port_lock();
 8006072:	f7ff ffed 	bl	8006050 <port_lock.lto_priv.298>
}
 8006076:	bd08      	pop	{r3, pc}
	...

08006080 <port_unlock_from_isr.lto_priv.540>:
static inline void port_unlock_from_isr(void) {
 8006080:	b508      	push	{r3, lr}
  port_unlock();
 8006082:	f7ff ffed 	bl	8006060 <port_unlock.lto_priv.257>
}
 8006086:	bd08      	pop	{r3, pc}
	...

08006090 <port_disable.lto_priv.532>:
  __ASM volatile ("cpsid i" : : : "memory");
 8006090:	b672      	cpsid	i
 *          the priority mask to level 0.
 */
static inline void port_disable(void) {

  __disable_irq();
}
 8006092:	4770      	bx	lr
	...

080060a0 <port_enable.lto_priv.530>:

/**
 * @brief   Enables all the interrupt sources.
 * @note    In this port it lowers the base priority to user level.
 */
static inline void port_enable(void) {
 80060a0:	b082      	sub	sp, #8
 80060a2:	2300      	movs	r3, #0
 80060a4:	9301      	str	r3, [sp, #4]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 80060a6:	9b01      	ldr	r3, [sp, #4]
 80060a8:	f383 8811 	msr	BASEPRI, r3
  __ASM volatile ("cpsie i" : : : "memory");
 80060ac:	b662      	cpsie	i

#if (CORTEX_SIMPLIFIED_PRIORITY == FALSE) || defined(__DOXYGEN__)
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#endif
  __enable_irq();
}
 80060ae:	b002      	add	sp, #8
 80060b0:	4770      	bx	lr
 80060b2:	bf00      	nop
	...

080060c0 <port_wait_for_interrupt>:
static inline void port_wait_for_interrupt(void) {

#if CORTEX_ENABLE_WFI_IDLE == TRUE
  __WFI();
#endif
}
 80060c0:	4770      	bx	lr
 80060c2:	bf00      	nop
	...

080060d0 <port_rt_get_counter_value.lto_priv.628>:
 *
 * @return              The realtime counter value.
 */
static inline rtcnt_t port_rt_get_counter_value(void) {

  return DWT->CYCCNT;
 80060d0:	4b01      	ldr	r3, [pc, #4]	; (80060d8 <port_rt_get_counter_value.lto_priv.628+0x8>)
 80060d2:	685b      	ldr	r3, [r3, #4]
}
 80060d4:	4618      	mov	r0, r3
 80060d6:	4770      	bx	lr
 80060d8:	e0001000 	.word	0xe0001000
 80060dc:	00000000 	.word	0x00000000

080060e0 <st_lld_get_counter.lto_priv.445>:
  return (systime_t)STM32_ST_TIM->CNT;
 80060e0:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 80060e4:	6a5b      	ldr	r3, [r3, #36]	; 0x24
}
 80060e6:	4618      	mov	r0, r3
 80060e8:	4770      	bx	lr
 80060ea:	bf00      	nop
 80060ec:	0000      	movs	r0, r0
	...

080060f0 <port_timer_stop_alarm.lto_priv.651>:
/**
 * @brief   Stops the alarm interrupt.
 *
 * @notapi
 */
static inline void port_timer_stop_alarm(void) {
 80060f0:	b508      	push	{r3, lr}

  stStopAlarm();
 80060f2:	f7fa fecd 	bl	8000e90 <stStopAlarm>
}
 80060f6:	bd08      	pop	{r3, pc}
	...

08006100 <port_timer_set_alarm.lto_priv.649>:
 *
 * @param[in] time      the time to be set for the next alarm
 *
 * @notapi
 */
static inline void port_timer_set_alarm(systime_t time) {
 8006100:	b500      	push	{lr}
 8006102:	b083      	sub	sp, #12
 8006104:	9001      	str	r0, [sp, #4]

  stSetAlarm(time);
 8006106:	9801      	ldr	r0, [sp, #4]
 8006108:	f7fa feca 	bl	8000ea0 <stSetAlarm>
}
 800610c:	b003      	add	sp, #12
 800610e:	f85d fb04 	ldr.w	pc, [sp], #4
 8006112:	bf00      	nop
	...

08006120 <port_timer_get_time.lto_priv.434>:
 *
 * @return              The system time.
 *
 * @notapi
 */
static inline systime_t port_timer_get_time(void) {
 8006120:	b508      	push	{r3, lr}

  return stGetCounter();
 8006122:	f7ff ffdd 	bl	80060e0 <st_lld_get_counter.lto_priv.445>
 8006126:	4603      	mov	r3, r0
}
 8006128:	4618      	mov	r0, r3
 800612a:	bd08      	pop	{r3, pc}
 800612c:	0000      	movs	r0, r0
	...

08006130 <chSysEnable.lto_priv.528>:
static inline void chSysEnable(void) {
 8006130:	b508      	push	{r3, lr}
  _dbg_check_enable();
 8006132:	f000 f965 	bl	8006400 <_dbg_check_enable>
  port_enable();
 8006136:	f7ff ffb3 	bl	80060a0 <port_enable.lto_priv.530>
}
 800613a:	bd08      	pop	{r3, pc}
 800613c:	0000      	movs	r0, r0
	...

08006140 <chSysLockFromISR.lto_priv.525>:
static inline void chSysLockFromISR(void) {
 8006140:	b508      	push	{r3, lr}
  port_lock_from_isr();
 8006142:	f7ff ff95 	bl	8006070 <port_lock_from_isr.lto_priv.552>
  _dbg_check_lock_from_isr();
 8006146:	f000 f9a3 	bl	8006490 <_dbg_check_lock_from_isr>
}
 800614a:	bd08      	pop	{r3, pc}
 800614c:	0000      	movs	r0, r0
	...

08006150 <chSysUnlockFromISR.lto_priv.516>:
static inline void chSysUnlockFromISR(void) {
 8006150:	b508      	push	{r3, lr}
  _dbg_check_unlock_from_isr();
 8006152:	f000 f9b5 	bl	80064c0 <_dbg_check_unlock_from_isr>
  port_unlock_from_isr();
 8006156:	f7ff ff93 	bl	8006080 <port_unlock_from_isr.lto_priv.540>
}
 800615a:	bd08      	pop	{r3, pc}
 800615c:	0000      	movs	r0, r0
	...

08006160 <chVTGetSystemTimeX.lto_priv.356>:
 *
 * @return              The system time in ticks.
 *
 * @xclass
 */
static inline systime_t chVTGetSystemTimeX(void) {
 8006160:	b508      	push	{r3, lr}

#if CH_CFG_ST_TIMEDELTA == 0
  return ch.vtlist.systime;
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  return port_timer_get_time();
 8006162:	f7ff ffdd 	bl	8006120 <port_timer_get_time.lto_priv.434>
 8006166:	4603      	mov	r3, r0
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
 8006168:	4618      	mov	r0, r3
 800616a:	bd08      	pop	{r3, pc}
 800616c:	0000      	movs	r0, r0
	...

08006170 <chVTDoTickI>:
 *          to acquire the lock if needed. This is done in order to reduce
 *          interrupts jitter when many timers are in use.
 *
 * @iclass
 */
static inline void chVTDoTickI(void) {
 8006170:	b530      	push	{r4, r5, lr}
 8006172:	b087      	sub	sp, #28

  chDbgCheckClassI();
 8006174:	f000 f9fc 	bl	8006570 <chDbgCheckClassI>
  virtual_timer_t *vtp;
  systime_t now;
  sysinterval_t delta, nowdelta;

  /* Looping through timers.*/
  vtp = ch.vtlist.next;
 8006178:	4b47      	ldr	r3, [pc, #284]	; (8006298 <chVTDoTickI+0x128>)
 800617a:	69db      	ldr	r3, [r3, #28]
 800617c:	9305      	str	r3, [sp, #20]
  while (true) {

    /* Getting the system time as reference.*/
    now = chVTGetSystemTimeX();
 800617e:	f7ff ffef 	bl	8006160 <chVTGetSystemTimeX.lto_priv.356>
 8006182:	9002      	str	r0, [sp, #8]
    nowdelta = chTimeDiffX(ch.vtlist.lasttime, now);
 8006184:	4b44      	ldr	r3, [pc, #272]	; (8006298 <chVTDoTickI+0x128>)
 8006186:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8006188:	9902      	ldr	r1, [sp, #8]
 800618a:	4618      	mov	r0, r3
 800618c:	f7ff fee8 	bl	8005f60 <chTimeDiffX.lto_priv.644>
 8006190:	9003      	str	r0, [sp, #12]

    /* The list scan is limited by the timers header having
       "ch.vtlist.vt_delta == (sysinterval_t)-1" which is
       greater than all deltas.*/
    if (nowdelta < vtp->delta) {
 8006192:	9b05      	ldr	r3, [sp, #20]
 8006194:	689b      	ldr	r3, [r3, #8]
 8006196:	9a03      	ldr	r2, [sp, #12]
 8006198:	429a      	cmp	r2, r3
 800619a:	d332      	bcc.n	8006202 <chVTDoTickI+0x92>
    /* Consuming all timers between "vtp->lasttime" and now.*/
    do {
      vtfunc_t fn;

      /* The "last time" becomes this timer's expiration time.*/
      ch.vtlist.lasttime += vtp->delta;
 800619c:	4b3e      	ldr	r3, [pc, #248]	; (8006298 <chVTDoTickI+0x128>)
 800619e:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 80061a0:	9b05      	ldr	r3, [sp, #20]
 80061a2:	689b      	ldr	r3, [r3, #8]
 80061a4:	4413      	add	r3, r2
 80061a6:	4a3c      	ldr	r2, [pc, #240]	; (8006298 <chVTDoTickI+0x128>)
 80061a8:	6293      	str	r3, [r2, #40]	; 0x28
      nowdelta -= vtp->delta;
 80061aa:	9b05      	ldr	r3, [sp, #20]
 80061ac:	689b      	ldr	r3, [r3, #8]
 80061ae:	9a03      	ldr	r2, [sp, #12]
 80061b0:	1ad3      	subs	r3, r2, r3
 80061b2:	9303      	str	r3, [sp, #12]

      vtp->next->prev = (virtual_timer_t *)&ch.vtlist;
 80061b4:	9b05      	ldr	r3, [sp, #20]
 80061b6:	681b      	ldr	r3, [r3, #0]
 80061b8:	4a38      	ldr	r2, [pc, #224]	; (800629c <chVTDoTickI+0x12c>)
 80061ba:	605a      	str	r2, [r3, #4]
      ch.vtlist.next = vtp->next;
 80061bc:	9b05      	ldr	r3, [sp, #20]
 80061be:	681b      	ldr	r3, [r3, #0]
 80061c0:	4a35      	ldr	r2, [pc, #212]	; (8006298 <chVTDoTickI+0x128>)
 80061c2:	61d3      	str	r3, [r2, #28]
      fn = vtp->func;
 80061c4:	9b05      	ldr	r3, [sp, #20]
 80061c6:	68db      	ldr	r3, [r3, #12]
 80061c8:	9301      	str	r3, [sp, #4]
      vtp->func = NULL;
 80061ca:	9b05      	ldr	r3, [sp, #20]
 80061cc:	2200      	movs	r2, #0
 80061ce:	60da      	str	r2, [r3, #12]

      /* if the list becomes empty then the timer is stopped.*/
      if (ch.vtlist.next == (virtual_timer_t *)&ch.vtlist) {
 80061d0:	4b31      	ldr	r3, [pc, #196]	; (8006298 <chVTDoTickI+0x128>)
 80061d2:	69db      	ldr	r3, [r3, #28]
 80061d4:	4a31      	ldr	r2, [pc, #196]	; (800629c <chVTDoTickI+0x12c>)
 80061d6:	4293      	cmp	r3, r2
 80061d8:	d101      	bne.n	80061de <chVTDoTickI+0x6e>
        port_timer_stop_alarm();
 80061da:	f7ff ff89 	bl	80060f0 <port_timer_stop_alarm.lto_priv.651>
      }

      /* The callback is invoked outside the kernel critical zone.*/
      chSysUnlockFromISR();
 80061de:	f7ff ffb7 	bl	8006150 <chSysUnlockFromISR.lto_priv.516>
      fn(vtp->par);
 80061e2:	9b05      	ldr	r3, [sp, #20]
 80061e4:	691a      	ldr	r2, [r3, #16]
 80061e6:	9b01      	ldr	r3, [sp, #4]
 80061e8:	4610      	mov	r0, r2
 80061ea:	4798      	blx	r3
      chSysLockFromISR();
 80061ec:	f7ff ffa8 	bl	8006140 <chSysLockFromISR.lto_priv.525>

      /* Next element in the list.*/
      vtp = ch.vtlist.next;
 80061f0:	4b29      	ldr	r3, [pc, #164]	; (8006298 <chVTDoTickI+0x128>)
 80061f2:	69db      	ldr	r3, [r3, #28]
 80061f4:	9305      	str	r3, [sp, #20]
    }
    while (vtp->delta <= nowdelta);
 80061f6:	9b05      	ldr	r3, [sp, #20]
 80061f8:	689b      	ldr	r3, [r3, #8]
 80061fa:	9a03      	ldr	r2, [sp, #12]
 80061fc:	429a      	cmp	r2, r3
 80061fe:	d2cd      	bcs.n	800619c <chVTDoTickI+0x2c>
 8006200:	e7bd      	b.n	800617e <chVTDoTickI+0xe>
  }

  /* if the list is empty, nothing else to do.*/
  if (ch.vtlist.next == (virtual_timer_t *)&ch.vtlist) {
 8006202:	4b25      	ldr	r3, [pc, #148]	; (8006298 <chVTDoTickI+0x128>)
 8006204:	69db      	ldr	r3, [r3, #28]
 8006206:	4a25      	ldr	r2, [pc, #148]	; (800629c <chVTDoTickI+0x12c>)
 8006208:	4293      	cmp	r3, r2
 800620a:	d043      	beq.n	8006294 <chVTDoTickI+0x124>
    return;
  }

  /* The "unprocessed nowdelta" time slice is added to "last time"
     and subtracted to next timer's delta.*/
  ch.vtlist.lasttime += nowdelta;
 800620c:	4b22      	ldr	r3, [pc, #136]	; (8006298 <chVTDoTickI+0x128>)
 800620e:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 8006210:	9b03      	ldr	r3, [sp, #12]
 8006212:	4413      	add	r3, r2
 8006214:	4a20      	ldr	r2, [pc, #128]	; (8006298 <chVTDoTickI+0x128>)
 8006216:	6293      	str	r3, [r2, #40]	; 0x28
  ch.vtlist.next->delta -= nowdelta;
 8006218:	4b1f      	ldr	r3, [pc, #124]	; (8006298 <chVTDoTickI+0x128>)
 800621a:	69db      	ldr	r3, [r3, #28]
 800621c:	6899      	ldr	r1, [r3, #8]
 800621e:	4b1e      	ldr	r3, [pc, #120]	; (8006298 <chVTDoTickI+0x128>)
 8006220:	69db      	ldr	r3, [r3, #28]
 8006222:	9a03      	ldr	r2, [sp, #12]
 8006224:	1a8a      	subs	r2, r1, r2
 8006226:	609a      	str	r2, [r3, #8]

  /* Recalculating the next alarm time.*/
  delta = chTimeDiffX(now, chTimeAddX(ch.vtlist.lasttime, vtp->delta));
 8006228:	4b1b      	ldr	r3, [pc, #108]	; (8006298 <chVTDoTickI+0x128>)
 800622a:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 800622c:	9b05      	ldr	r3, [sp, #20]
 800622e:	689b      	ldr	r3, [r3, #8]
 8006230:	4619      	mov	r1, r3
 8006232:	4610      	mov	r0, r2
 8006234:	f7ff fe84 	bl	8005f40 <chTimeAddX.lto_priv.459>
 8006238:	4603      	mov	r3, r0
 800623a:	4619      	mov	r1, r3
 800623c:	9802      	ldr	r0, [sp, #8]
 800623e:	f7ff fe8f 	bl	8005f60 <chTimeDiffX.lto_priv.644>
 8006242:	9004      	str	r0, [sp, #16]
  if (delta < (sysinterval_t)CH_CFG_ST_TIMEDELTA) {
 8006244:	9b04      	ldr	r3, [sp, #16]
 8006246:	2b01      	cmp	r3, #1
 8006248:	d801      	bhi.n	800624e <chVTDoTickI+0xde>
    delta = (sysinterval_t)CH_CFG_ST_TIMEDELTA;
 800624a:	2302      	movs	r3, #2
 800624c:	9304      	str	r3, [sp, #16]
  /* The delta could be too large for the physical timer to handle.*/
  else if (delta > (sysinterval_t)TIME_MAX_SYSTIME) {
    delta = (sysinterval_t)TIME_MAX_SYSTIME;
  }
#endif
  port_timer_set_alarm(chTimeAddX(now, delta));
 800624e:	9904      	ldr	r1, [sp, #16]
 8006250:	9802      	ldr	r0, [sp, #8]
 8006252:	f7ff fe75 	bl	8005f40 <chTimeAddX.lto_priv.459>
 8006256:	4603      	mov	r3, r0
 8006258:	4618      	mov	r0, r3
 800625a:	f7ff ff51 	bl	8006100 <port_timer_set_alarm.lto_priv.649>

  chDbgAssert(chTimeDiffX(ch.vtlist.lasttime, chVTGetSystemTimeX()) <=
 800625e:	4b0e      	ldr	r3, [pc, #56]	; (8006298 <chVTDoTickI+0x128>)
 8006260:	6a9c      	ldr	r4, [r3, #40]	; 0x28
 8006262:	f7ff ff7d 	bl	8006160 <chVTGetSystemTimeX.lto_priv.356>
 8006266:	4603      	mov	r3, r0
 8006268:	4619      	mov	r1, r3
 800626a:	4620      	mov	r0, r4
 800626c:	f7ff fe78 	bl	8005f60 <chTimeDiffX.lto_priv.644>
 8006270:	4604      	mov	r4, r0
 8006272:	4b09      	ldr	r3, [pc, #36]	; (8006298 <chVTDoTickI+0x128>)
 8006274:	6a9d      	ldr	r5, [r3, #40]	; 0x28
 8006276:	9904      	ldr	r1, [sp, #16]
 8006278:	9802      	ldr	r0, [sp, #8]
 800627a:	f7ff fe61 	bl	8005f40 <chTimeAddX.lto_priv.459>
 800627e:	4603      	mov	r3, r0
 8006280:	4619      	mov	r1, r3
 8006282:	4628      	mov	r0, r5
 8006284:	f7ff fe6c 	bl	8005f60 <chTimeDiffX.lto_priv.644>
 8006288:	4603      	mov	r3, r0
 800628a:	429c      	cmp	r4, r3
 800628c:	d902      	bls.n	8006294 <chVTDoTickI+0x124>
 800628e:	4804      	ldr	r0, [pc, #16]	; (80062a0 <chVTDoTickI+0x130>)
 8006290:	f000 f84e 	bl	8006330 <chSysHalt>
              chTimeDiffX(ch.vtlist.lasttime, chTimeAddX(now, delta)),
              "exceeding delta");
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
 8006294:	b007      	add	sp, #28
 8006296:	bd30      	pop	{r4, r5, pc}
 8006298:	20000b38 	.word	0x20000b38
 800629c:	20000b54 	.word	0x20000b54
 80062a0:	08009624 	.word	0x08009624
	...

080062b0 <_idle_thread.lto_priv.180>:
 *          that this thread is executed only if there are no other ready
 *          threads in the system.
 *
 * @param[in] p         the thread parameter, unused in this scenario
 */
static void _idle_thread(void *p) {
 80062b0:	b500      	push	{lr}
 80062b2:	b083      	sub	sp, #12
 80062b4:	9001      	str	r0, [sp, #4]
  (void)p;

  while (true) {
    /*lint -save -e522 [2.2] Apparently no side effects because it contains
      an asm instruction.*/
    port_wait_for_interrupt();
 80062b6:	f7ff ff03 	bl	80060c0 <port_wait_for_interrupt>
 80062ba:	e7fc      	b.n	80062b6 <_idle_thread.lto_priv.180+0x6>
 80062bc:	0000      	movs	r0, r0
	...

080062c0 <chSysInit>:
 * @post    The main thread is created with priority @p NORMALPRIO and
 *          interrupts are enabled.
 *
 * @special
 */
void chSysInit(void) {
 80062c0:	b508      	push	{r3, lr}

  _scheduler_init();
 80062c2:	f000 fd0d 	bl	8006ce0 <_scheduler_init>
  _vt_init();
 80062c6:	f000 fb1b 	bl	8006900 <_vt_init>
  _trace_init();
 80062ca:	f000 f9e9 	bl	80066a0 <_trace_init>

#if CH_DBG_SYSTEM_STATE_CHECK == TRUE
  ch.dbg.isr_cnt  = (cnt_t)0;
 80062ce:	4b13      	ldr	r3, [pc, #76]	; (800631c <chSysInit+0x5c>)
 80062d0:	2200      	movs	r2, #0
 80062d2:	631a      	str	r2, [r3, #48]	; 0x30
  ch.dbg.lock_cnt = (cnt_t)0;
 80062d4:	4b11      	ldr	r3, [pc, #68]	; (800631c <chSysInit+0x5c>)
 80062d6:	2200      	movs	r2, #0
 80062d8:	635a      	str	r2, [r3, #52]	; 0x34
#endif
#if CH_CFG_USE_TM == TRUE
  _tm_init();
 80062da:	f001 fac9 	bl	8007870 <_tm_init>
#endif
#if CH_CFG_USE_MEMCORE == TRUE
  _core_init();
 80062de:	f001 fe57 	bl	8007f90 <_core_init>
#endif
#if CH_CFG_USE_HEAP == TRUE
  _heap_init();
 80062e2:	f001 fec5 	bl	8008070 <_heap_init>
#endif
#if CH_CFG_USE_FACTORY == TRUE
  _factory_init();
 80062e6:	f002 f82b 	bl	8008340 <_factory_init>
#endif

#if CH_CFG_NO_IDLE_THREAD == FALSE
  /* Now this instructions flow becomes the main thread.*/
#if CH_CFG_USE_REGISTRY == TRUE
  currp = _thread_init(&ch.mainthread, (const char *)&ch_debug, NORMALPRIO);
 80062ea:	2280      	movs	r2, #128	; 0x80
 80062ec:	490c      	ldr	r1, [pc, #48]	; (8006320 <chSysInit+0x60>)
 80062ee:	480d      	ldr	r0, [pc, #52]	; (8006324 <chSysInit+0x64>)
 80062f0:	f001 f826 	bl	8007340 <_thread_init>
 80062f4:	4602      	mov	r2, r0
 80062f6:	4b09      	ldr	r3, [pc, #36]	; (800631c <chSysInit+0x5c>)
 80062f8:	619a      	str	r2, [r3, #24]
#if CH_DBG_ENABLE_STACK_CHECK == TRUE
  {
    /* Setting up the base address of the static main thread stack, the
       symbol must be provided externally.*/
    extern stkalign_t __main_thread_stack_base__;
    currp->wabase = &__main_thread_stack_base__;
 80062fa:	4b08      	ldr	r3, [pc, #32]	; (800631c <chSysInit+0x5c>)
 80062fc:	699b      	ldr	r3, [r3, #24]
 80062fe:	4a0a      	ldr	r2, [pc, #40]	; (8006328 <chSysInit+0x68>)
 8006300:	61da      	str	r2, [r3, #28]
#elif CH_CFG_USE_DYNAMIC == TRUE
  currp->wabase = NULL;
#endif

  /* Setting up the caller as current thread.*/
  currp->state = CH_STATE_CURRENT;
 8006302:	4b06      	ldr	r3, [pc, #24]	; (800631c <chSysInit+0x5c>)
 8006304:	699b      	ldr	r3, [r3, #24]
 8006306:	2201      	movs	r2, #1
 8006308:	f883 2020 	strb.w	r2, [r3, #32]

  /* Port layer initialization last because it depend on some of the
     initializations performed before.*/
  port_init();
 800630c:	f7ff fe80 	bl	8006010 <port_init>

  /* Initialization hook.*/
  CH_CFG_SYSTEM_INIT_HOOK();

  /* It is alive now.*/
  chSysEnable();
 8006310:	f7ff ff0e 	bl	8006130 <chSysEnable.lto_priv.528>
    };

    /* This thread has the lowest priority in the system, its role is just to
       serve interrupts in its context while keeping the lowest energy saving
       mode compatible with the system status.*/
    (void) chThdCreate(&idle_descriptor);
 8006314:	4805      	ldr	r0, [pc, #20]	; (800632c <chSysInit+0x6c>)
 8006316:	f001 f8cb 	bl	80074b0 <chThdCreate>
  }
#endif
}
 800631a:	bd08      	pop	{r3, pc}
 800631c:	20000b38 	.word	0x20000b38
 8006320:	080096fc 	.word	0x080096fc
 8006324:	20001378 	.word	0x20001378
 8006328:	20000400 	.word	0x20000400
 800632c:	0800960c 	.word	0x0800960c

08006330 <chSysHalt>:
 *
 * @param[in] reason        pointer to an error string
 *
 * @special
 */
void chSysHalt(const char *reason) {
 8006330:	b500      	push	{lr}
 8006332:	b083      	sub	sp, #12
 8006334:	9001      	str	r0, [sp, #4]

  port_disable();
 8006336:	f7ff feab 	bl	8006090 <port_disable.lto_priv.532>

  /* Logging the event.*/
  _trace_halt(reason);
 800633a:	9801      	ldr	r0, [sp, #4]
 800633c:	f000 fa58 	bl	80067f0 <_trace_halt>

  /* Pointing to the passed message.*/
  ch.dbg.panic_msg = reason;
 8006340:	4a01      	ldr	r2, [pc, #4]	; (8006348 <chSysHalt+0x18>)
 8006342:	9b01      	ldr	r3, [sp, #4]
 8006344:	62d3      	str	r3, [r2, #44]	; 0x2c
 8006346:	e7fe      	b.n	8006346 <chSysHalt+0x16>
 8006348:	20000b38 	.word	0x20000b38
 800634c:	00000000 	.word	0x00000000

08006350 <chSysTimerHandlerI>:
 *          and, together with the @p CH_CFG_TIME_QUANTUM macro, the round robin
 *          interval.
 *
 * @iclass
 */
void chSysTimerHandlerI(void) {
 8006350:	b508      	push	{r3, lr}

  chDbgCheckClassI();
 8006352:	f000 f90d 	bl	8006570 <chDbgCheckClassI>
  }
#endif
#if CH_DBG_THREADS_PROFILING == TRUE
  currp->time++;
#endif
  chVTDoTickI();
 8006356:	f7ff ff0b 	bl	8006170 <chVTDoTickI>
  CH_CFG_SYSTEM_TICK_HOOK();
}
 800635a:	bd08      	pop	{r3, pc}
 800635c:	0000      	movs	r0, r0
	...

08006360 <chSysIsCounterWithinX>:
 * @retval true         current time within the specified time window.
 * @retval false        current time not within the specified time window.
 *
 * @xclass
 */
bool chSysIsCounterWithinX(rtcnt_t cnt, rtcnt_t start, rtcnt_t end) {
 8006360:	b084      	sub	sp, #16
 8006362:	9003      	str	r0, [sp, #12]
 8006364:	9102      	str	r1, [sp, #8]
 8006366:	9201      	str	r2, [sp, #4]

  return (bool)((cnt - start) < (end - start));
 8006368:	9a03      	ldr	r2, [sp, #12]
 800636a:	9b02      	ldr	r3, [sp, #8]
 800636c:	1ad2      	subs	r2, r2, r3
 800636e:	9901      	ldr	r1, [sp, #4]
 8006370:	9b02      	ldr	r3, [sp, #8]
 8006372:	1acb      	subs	r3, r1, r3
 8006374:	429a      	cmp	r2, r3
 8006376:	bf34      	ite	cc
 8006378:	2301      	movcc	r3, #1
 800637a:	2300      	movcs	r3, #0
 800637c:	b2db      	uxtb	r3, r3
}
 800637e:	4618      	mov	r0, r3
 8006380:	b004      	add	sp, #16
 8006382:	4770      	bx	lr
	...

08006390 <chSysPolledDelayX>:
 *
 * @param[in] cycles    number of cycles
 *
 * @xclass
 */
void chSysPolledDelayX(rtcnt_t cycles) {
 8006390:	b500      	push	{lr}
 8006392:	b085      	sub	sp, #20
 8006394:	9001      	str	r0, [sp, #4]
  rtcnt_t start = chSysGetRealtimeCounterX();
 8006396:	f7ff fe9b 	bl	80060d0 <port_rt_get_counter_value.lto_priv.628>
 800639a:	9003      	str	r0, [sp, #12]
  rtcnt_t end  = start + cycles;
 800639c:	9a03      	ldr	r2, [sp, #12]
 800639e:	9b01      	ldr	r3, [sp, #4]
 80063a0:	4413      	add	r3, r2
 80063a2:	9302      	str	r3, [sp, #8]

  while (chSysIsCounterWithinX(chSysGetRealtimeCounterX(), start, end)) {
 80063a4:	f7ff fe94 	bl	80060d0 <port_rt_get_counter_value.lto_priv.628>
 80063a8:	4603      	mov	r3, r0
 80063aa:	9a02      	ldr	r2, [sp, #8]
 80063ac:	9903      	ldr	r1, [sp, #12]
 80063ae:	4618      	mov	r0, r3
 80063b0:	f7ff ffd6 	bl	8006360 <chSysIsCounterWithinX>
 80063b4:	4603      	mov	r3, r0
 80063b6:	2b00      	cmp	r3, #0
 80063b8:	d1f4      	bne.n	80063a4 <chSysPolledDelayX+0x14>
  }
}
 80063ba:	b005      	add	sp, #20
 80063bc:	f85d fb04 	ldr.w	pc, [sp], #4

080063c0 <port_lock.lto_priv.299>:
static inline void port_lock(void) {
 80063c0:	b082      	sub	sp, #8
 80063c2:	2320      	movs	r3, #32
 80063c4:	9301      	str	r3, [sp, #4]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 80063c6:	9b01      	ldr	r3, [sp, #4]
 80063c8:	f383 8811 	msr	BASEPRI, r3
}
 80063cc:	b002      	add	sp, #8
 80063ce:	4770      	bx	lr

080063d0 <port_unlock.lto_priv.258>:
static inline void port_unlock(void) {
 80063d0:	b082      	sub	sp, #8
 80063d2:	2300      	movs	r3, #0
 80063d4:	9301      	str	r3, [sp, #4]
 80063d6:	9b01      	ldr	r3, [sp, #4]
 80063d8:	f383 8811 	msr	BASEPRI, r3
}
 80063dc:	b002      	add	sp, #8
 80063de:	4770      	bx	lr

080063e0 <port_lock_from_isr.lto_priv.553>:
static inline void port_lock_from_isr(void) {
 80063e0:	b508      	push	{r3, lr}
  port_lock();
 80063e2:	f7ff ffed 	bl	80063c0 <port_lock.lto_priv.299>
}
 80063e6:	bd08      	pop	{r3, pc}
	...

080063f0 <port_unlock_from_isr.lto_priv.541>:
static inline void port_unlock_from_isr(void) {
 80063f0:	b508      	push	{r3, lr}
  port_unlock();
 80063f2:	f7ff ffed 	bl	80063d0 <port_unlock.lto_priv.258>
}
 80063f6:	bd08      	pop	{r3, pc}
	...

08006400 <_dbg_check_enable>:
/**
 * @brief   Guard code for @p chSysEnable().
 *
 * @notapi
 */
void _dbg_check_enable(void) {
 8006400:	b508      	push	{r3, lr}

  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 8006402:	4b06      	ldr	r3, [pc, #24]	; (800641c <_dbg_check_enable+0x1c>)
 8006404:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8006406:	2b00      	cmp	r3, #0
 8006408:	d103      	bne.n	8006412 <_dbg_check_enable+0x12>
 800640a:	4b04      	ldr	r3, [pc, #16]	; (800641c <_dbg_check_enable+0x1c>)
 800640c:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 800640e:	2b00      	cmp	r3, #0
 8006410:	d002      	beq.n	8006418 <_dbg_check_enable+0x18>
    chSysHalt("SV#3");
 8006412:	4803      	ldr	r0, [pc, #12]	; (8006420 <_dbg_check_enable+0x20>)
 8006414:	f7ff ff8c 	bl	8006330 <chSysHalt>
  }
}
 8006418:	bd08      	pop	{r3, pc}
 800641a:	bf00      	nop
 800641c:	20000b38 	.word	0x20000b38
 8006420:	08009978 	.word	0x08009978
	...

08006430 <_dbg_check_lock>:
/**
 * @brief   Guard code for @p chSysLock().
 *
 * @notapi
 */
void _dbg_check_lock(void) {
 8006430:	b508      	push	{r3, lr}

  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 8006432:	4b07      	ldr	r3, [pc, #28]	; (8006450 <_dbg_check_lock+0x20>)
 8006434:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8006436:	2b00      	cmp	r3, #0
 8006438:	d103      	bne.n	8006442 <_dbg_check_lock+0x12>
 800643a:	4b05      	ldr	r3, [pc, #20]	; (8006450 <_dbg_check_lock+0x20>)
 800643c:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 800643e:	2b00      	cmp	r3, #0
 8006440:	d002      	beq.n	8006448 <_dbg_check_lock+0x18>
    chSysHalt("SV#4");
 8006442:	4804      	ldr	r0, [pc, #16]	; (8006454 <_dbg_check_lock+0x24>)
 8006444:	f7ff ff74 	bl	8006330 <chSysHalt>
  }
  _dbg_enter_lock();
 8006448:	4b01      	ldr	r3, [pc, #4]	; (8006450 <_dbg_check_lock+0x20>)
 800644a:	2201      	movs	r2, #1
 800644c:	635a      	str	r2, [r3, #52]	; 0x34
}
 800644e:	bd08      	pop	{r3, pc}
 8006450:	20000b38 	.word	0x20000b38
 8006454:	08009980 	.word	0x08009980
	...

08006460 <_dbg_check_unlock>:
/**
 * @brief   Guard code for @p chSysUnlock().
 *
 * @notapi
 */
void _dbg_check_unlock(void) {
 8006460:	b508      	push	{r3, lr}

  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
 8006462:	4b07      	ldr	r3, [pc, #28]	; (8006480 <_dbg_check_unlock+0x20>)
 8006464:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8006466:	2b00      	cmp	r3, #0
 8006468:	d103      	bne.n	8006472 <_dbg_check_unlock+0x12>
 800646a:	4b05      	ldr	r3, [pc, #20]	; (8006480 <_dbg_check_unlock+0x20>)
 800646c:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 800646e:	2b00      	cmp	r3, #0
 8006470:	dc02      	bgt.n	8006478 <_dbg_check_unlock+0x18>
    chSysHalt("SV#5");
 8006472:	4804      	ldr	r0, [pc, #16]	; (8006484 <_dbg_check_unlock+0x24>)
 8006474:	f7ff ff5c 	bl	8006330 <chSysHalt>
  }
  _dbg_leave_lock();
 8006478:	4b01      	ldr	r3, [pc, #4]	; (8006480 <_dbg_check_unlock+0x20>)
 800647a:	2200      	movs	r2, #0
 800647c:	635a      	str	r2, [r3, #52]	; 0x34
}
 800647e:	bd08      	pop	{r3, pc}
 8006480:	20000b38 	.word	0x20000b38
 8006484:	08009988 	.word	0x08009988
	...

08006490 <_dbg_check_lock_from_isr>:
/**
 * @brief   Guard code for @p chSysLockFromIsr().
 *
 * @notapi
 */
void _dbg_check_lock_from_isr(void) {
 8006490:	b508      	push	{r3, lr}

  if ((ch.dbg.isr_cnt <= (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 8006492:	4b07      	ldr	r3, [pc, #28]	; (80064b0 <_dbg_check_lock_from_isr+0x20>)
 8006494:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8006496:	2b00      	cmp	r3, #0
 8006498:	dd03      	ble.n	80064a2 <_dbg_check_lock_from_isr+0x12>
 800649a:	4b05      	ldr	r3, [pc, #20]	; (80064b0 <_dbg_check_lock_from_isr+0x20>)
 800649c:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 800649e:	2b00      	cmp	r3, #0
 80064a0:	d002      	beq.n	80064a8 <_dbg_check_lock_from_isr+0x18>
    chSysHalt("SV#6");
 80064a2:	4804      	ldr	r0, [pc, #16]	; (80064b4 <_dbg_check_lock_from_isr+0x24>)
 80064a4:	f7ff ff44 	bl	8006330 <chSysHalt>
  }
  _dbg_enter_lock();
 80064a8:	4b01      	ldr	r3, [pc, #4]	; (80064b0 <_dbg_check_lock_from_isr+0x20>)
 80064aa:	2201      	movs	r2, #1
 80064ac:	635a      	str	r2, [r3, #52]	; 0x34
}
 80064ae:	bd08      	pop	{r3, pc}
 80064b0:	20000b38 	.word	0x20000b38
 80064b4:	08009990 	.word	0x08009990
	...

080064c0 <_dbg_check_unlock_from_isr>:
/**
 * @brief   Guard code for @p chSysUnlockFromIsr().
 *
 * @notapi
 */
void _dbg_check_unlock_from_isr(void) {
 80064c0:	b508      	push	{r3, lr}

  if ((ch.dbg.isr_cnt <= (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
 80064c2:	4b07      	ldr	r3, [pc, #28]	; (80064e0 <_dbg_check_unlock_from_isr+0x20>)
 80064c4:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80064c6:	2b00      	cmp	r3, #0
 80064c8:	dd03      	ble.n	80064d2 <_dbg_check_unlock_from_isr+0x12>
 80064ca:	4b05      	ldr	r3, [pc, #20]	; (80064e0 <_dbg_check_unlock_from_isr+0x20>)
 80064cc:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 80064ce:	2b00      	cmp	r3, #0
 80064d0:	dc02      	bgt.n	80064d8 <_dbg_check_unlock_from_isr+0x18>
    chSysHalt("SV#7");
 80064d2:	4804      	ldr	r0, [pc, #16]	; (80064e4 <_dbg_check_unlock_from_isr+0x24>)
 80064d4:	f7ff ff2c 	bl	8006330 <chSysHalt>
  }
  _dbg_leave_lock();
 80064d8:	4b01      	ldr	r3, [pc, #4]	; (80064e0 <_dbg_check_unlock_from_isr+0x20>)
 80064da:	2200      	movs	r2, #0
 80064dc:	635a      	str	r2, [r3, #52]	; 0x34
}
 80064de:	bd08      	pop	{r3, pc}
 80064e0:	20000b38 	.word	0x20000b38
 80064e4:	08009998 	.word	0x08009998
	...

080064f0 <_dbg_check_enter_isr>:
/**
 * @brief   Guard code for @p CH_IRQ_PROLOGUE().
 *
 * @notapi
 */
void _dbg_check_enter_isr(void) {
 80064f0:	b508      	push	{r3, lr}

  port_lock_from_isr();
 80064f2:	f7ff ff75 	bl	80063e0 <port_lock_from_isr.lto_priv.553>
  if ((ch.dbg.isr_cnt < (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 80064f6:	4b09      	ldr	r3, [pc, #36]	; (800651c <_dbg_check_enter_isr+0x2c>)
 80064f8:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80064fa:	2b00      	cmp	r3, #0
 80064fc:	db03      	blt.n	8006506 <_dbg_check_enter_isr+0x16>
 80064fe:	4b07      	ldr	r3, [pc, #28]	; (800651c <_dbg_check_enter_isr+0x2c>)
 8006500:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8006502:	2b00      	cmp	r3, #0
 8006504:	d002      	beq.n	800650c <_dbg_check_enter_isr+0x1c>
    chSysHalt("SV#8");
 8006506:	4806      	ldr	r0, [pc, #24]	; (8006520 <_dbg_check_enter_isr+0x30>)
 8006508:	f7ff ff12 	bl	8006330 <chSysHalt>
  }
  ch.dbg.isr_cnt++;
 800650c:	4b03      	ldr	r3, [pc, #12]	; (800651c <_dbg_check_enter_isr+0x2c>)
 800650e:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8006510:	3301      	adds	r3, #1
 8006512:	4a02      	ldr	r2, [pc, #8]	; (800651c <_dbg_check_enter_isr+0x2c>)
 8006514:	6313      	str	r3, [r2, #48]	; 0x30
  port_unlock_from_isr();
 8006516:	f7ff ff6b 	bl	80063f0 <port_unlock_from_isr.lto_priv.541>
}
 800651a:	bd08      	pop	{r3, pc}
 800651c:	20000b38 	.word	0x20000b38
 8006520:	080099a0 	.word	0x080099a0
	...

08006530 <_dbg_check_leave_isr>:
/**
 * @brief   Guard code for @p CH_IRQ_EPILOGUE().
 *
 * @notapi
 */
void _dbg_check_leave_isr(void) {
 8006530:	b508      	push	{r3, lr}

  port_lock_from_isr();
 8006532:	f7ff ff55 	bl	80063e0 <port_lock_from_isr.lto_priv.553>
  if ((ch.dbg.isr_cnt <= (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 8006536:	4b09      	ldr	r3, [pc, #36]	; (800655c <_dbg_check_leave_isr+0x2c>)
 8006538:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800653a:	2b00      	cmp	r3, #0
 800653c:	dd03      	ble.n	8006546 <_dbg_check_leave_isr+0x16>
 800653e:	4b07      	ldr	r3, [pc, #28]	; (800655c <_dbg_check_leave_isr+0x2c>)
 8006540:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8006542:	2b00      	cmp	r3, #0
 8006544:	d002      	beq.n	800654c <_dbg_check_leave_isr+0x1c>
    chSysHalt("SV#9");
 8006546:	4806      	ldr	r0, [pc, #24]	; (8006560 <_dbg_check_leave_isr+0x30>)
 8006548:	f7ff fef2 	bl	8006330 <chSysHalt>
  }
  ch.dbg.isr_cnt--;
 800654c:	4b03      	ldr	r3, [pc, #12]	; (800655c <_dbg_check_leave_isr+0x2c>)
 800654e:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8006550:	3b01      	subs	r3, #1
 8006552:	4a02      	ldr	r2, [pc, #8]	; (800655c <_dbg_check_leave_isr+0x2c>)
 8006554:	6313      	str	r3, [r2, #48]	; 0x30
  port_unlock_from_isr();
 8006556:	f7ff ff4b 	bl	80063f0 <port_unlock_from_isr.lto_priv.541>
}
 800655a:	bd08      	pop	{r3, pc}
 800655c:	20000b38 	.word	0x20000b38
 8006560:	080099a8 	.word	0x080099a8
	...

08006570 <chDbgCheckClassI>:
 *          an I-class API function. A panic is generated if the state is
 *          not compatible.
 *
 * @api
 */
void chDbgCheckClassI(void) {
 8006570:	b508      	push	{r3, lr}

  if ((ch.dbg.isr_cnt < (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
 8006572:	4b06      	ldr	r3, [pc, #24]	; (800658c <chDbgCheckClassI+0x1c>)
 8006574:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8006576:	2b00      	cmp	r3, #0
 8006578:	db03      	blt.n	8006582 <chDbgCheckClassI+0x12>
 800657a:	4b04      	ldr	r3, [pc, #16]	; (800658c <chDbgCheckClassI+0x1c>)
 800657c:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 800657e:	2b00      	cmp	r3, #0
 8006580:	dc02      	bgt.n	8006588 <chDbgCheckClassI+0x18>
    chSysHalt("SV#10");
 8006582:	4803      	ldr	r0, [pc, #12]	; (8006590 <chDbgCheckClassI+0x20>)
 8006584:	f7ff fed4 	bl	8006330 <chSysHalt>
  }
}
 8006588:	bd08      	pop	{r3, pc}
 800658a:	bf00      	nop
 800658c:	20000b38 	.word	0x20000b38
 8006590:	080099b0 	.word	0x080099b0
	...

080065a0 <chDbgCheckClassS>:
 *          an S-class API function. A panic is generated if the state is
 *          not compatible.
 *
 * @api
 */
void chDbgCheckClassS(void) {
 80065a0:	b508      	push	{r3, lr}

  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
 80065a2:	4b06      	ldr	r3, [pc, #24]	; (80065bc <chDbgCheckClassS+0x1c>)
 80065a4:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80065a6:	2b00      	cmp	r3, #0
 80065a8:	d103      	bne.n	80065b2 <chDbgCheckClassS+0x12>
 80065aa:	4b04      	ldr	r3, [pc, #16]	; (80065bc <chDbgCheckClassS+0x1c>)
 80065ac:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 80065ae:	2b00      	cmp	r3, #0
 80065b0:	dc02      	bgt.n	80065b8 <chDbgCheckClassS+0x18>
    chSysHalt("SV#11");
 80065b2:	4803      	ldr	r0, [pc, #12]	; (80065c0 <chDbgCheckClassS+0x20>)
 80065b4:	f7ff febc 	bl	8006330 <chSysHalt>
  }
}
 80065b8:	bd08      	pop	{r3, pc}
 80065ba:	bf00      	nop
 80065bc:	20000b38 	.word	0x20000b38
 80065c0:	080099b8 	.word	0x080099b8
	...

080065d0 <port_lock.lto_priv.300>:
static inline void port_lock(void) {
 80065d0:	b082      	sub	sp, #8
 80065d2:	2320      	movs	r3, #32
 80065d4:	9301      	str	r3, [sp, #4]
 80065d6:	9b01      	ldr	r3, [sp, #4]
 80065d8:	f383 8811 	msr	BASEPRI, r3
}
 80065dc:	b002      	add	sp, #8
 80065de:	4770      	bx	lr

080065e0 <port_unlock.lto_priv.259>:
static inline void port_unlock(void) {
 80065e0:	b082      	sub	sp, #8
 80065e2:	2300      	movs	r3, #0
 80065e4:	9301      	str	r3, [sp, #4]
 80065e6:	9b01      	ldr	r3, [sp, #4]
 80065e8:	f383 8811 	msr	BASEPRI, r3
}
 80065ec:	b002      	add	sp, #8
 80065ee:	4770      	bx	lr

080065f0 <port_lock_from_isr.lto_priv.554>:
static inline void port_lock_from_isr(void) {
 80065f0:	b508      	push	{r3, lr}
  port_lock();
 80065f2:	f7ff ffed 	bl	80065d0 <port_lock.lto_priv.300>
}
 80065f6:	bd08      	pop	{r3, pc}
	...

08006600 <port_unlock_from_isr.lto_priv.542>:
static inline void port_unlock_from_isr(void) {
 8006600:	b508      	push	{r3, lr}
  port_unlock();
 8006602:	f7ff ffed 	bl	80065e0 <port_unlock.lto_priv.259>
}
 8006606:	bd08      	pop	{r3, pc}
	...

08006610 <port_rt_get_counter_value.lto_priv.629>:
  return DWT->CYCCNT;
 8006610:	4b01      	ldr	r3, [pc, #4]	; (8006618 <port_rt_get_counter_value.lto_priv.629+0x8>)
 8006612:	685b      	ldr	r3, [r3, #4]
}
 8006614:	4618      	mov	r0, r3
 8006616:	4770      	bx	lr
 8006618:	e0001000 	.word	0xe0001000
 800661c:	00000000 	.word	0x00000000

08006620 <st_lld_get_counter.lto_priv.446>:
  return (systime_t)STM32_ST_TIM->CNT;
 8006620:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8006624:	6a5b      	ldr	r3, [r3, #36]	; 0x24
}
 8006626:	4618      	mov	r0, r3
 8006628:	4770      	bx	lr
 800662a:	bf00      	nop
 800662c:	0000      	movs	r0, r0
	...

08006630 <port_timer_get_time.lto_priv.435>:
static inline systime_t port_timer_get_time(void) {
 8006630:	b508      	push	{r3, lr}
  return stGetCounter();
 8006632:	f7ff fff5 	bl	8006620 <st_lld_get_counter.lto_priv.446>
 8006636:	4603      	mov	r3, r0
}
 8006638:	4618      	mov	r0, r3
 800663a:	bd08      	pop	{r3, pc}
 800663c:	0000      	movs	r0, r0
	...

08006640 <chVTGetSystemTimeX.lto_priv.357>:
static inline systime_t chVTGetSystemTimeX(void) {
 8006640:	b508      	push	{r3, lr}
  return port_timer_get_time();
 8006642:	f7ff fff5 	bl	8006630 <port_timer_get_time.lto_priv.435>
 8006646:	4603      	mov	r3, r0
}
 8006648:	4618      	mov	r0, r3
 800664a:	bd08      	pop	{r3, pc}
 800664c:	0000      	movs	r0, r0
	...

08006650 <trace_next>:
/**
 * @brief   Writes a time stamp and increases the trace buffer pointer.
 *
 * @notapi
 */
static NOINLINE void trace_next(void) {
 8006650:	b510      	push	{r4, lr}

  ch.dbg.trace_buffer.ptr->time    = chVTGetSystemTimeX();
 8006652:	4b0f      	ldr	r3, [pc, #60]	; (8006690 <trace_next+0x40>)
 8006654:	6bdc      	ldr	r4, [r3, #60]	; 0x3c
 8006656:	f7ff fff3 	bl	8006640 <chVTGetSystemTimeX.lto_priv.357>
 800665a:	4603      	mov	r3, r0
 800665c:	6063      	str	r3, [r4, #4]
#if PORT_SUPPORTS_RT == TRUE
  ch.dbg.trace_buffer.ptr->rtstamp = chSysGetRealtimeCounterX();
 800665e:	f7ff ffd7 	bl	8006610 <port_rt_get_counter_value.lto_priv.629>
 8006662:	4601      	mov	r1, r0
 8006664:	4b0a      	ldr	r3, [pc, #40]	; (8006690 <trace_next+0x40>)
 8006666:	6bda      	ldr	r2, [r3, #60]	; 0x3c
 8006668:	f021 417f 	bic.w	r1, r1, #4278190080	; 0xff000000
 800666c:	6813      	ldr	r3, [r2, #0]
 800666e:	f361 231f 	bfi	r3, r1, #8, #24
 8006672:	6013      	str	r3, [r2, #0]
#endif

  /* Trace hook, useful in order to interface debug tools.*/
  CH_CFG_TRACE_HOOK(ch.dbg.trace_buffer.ptr);

  if (++ch.dbg.trace_buffer.ptr >=
 8006674:	4b06      	ldr	r3, [pc, #24]	; (8006690 <trace_next+0x40>)
 8006676:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8006678:	3310      	adds	r3, #16
 800667a:	4a05      	ldr	r2, [pc, #20]	; (8006690 <trace_next+0x40>)
 800667c:	63d3      	str	r3, [r2, #60]	; 0x3c
 800667e:	4b04      	ldr	r3, [pc, #16]	; (8006690 <trace_next+0x40>)
 8006680:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8006682:	4a04      	ldr	r2, [pc, #16]	; (8006694 <trace_next+0x44>)
 8006684:	4293      	cmp	r3, r2
 8006686:	d302      	bcc.n	800668e <trace_next+0x3e>
      &ch.dbg.trace_buffer.buffer[CH_DBG_TRACE_BUFFER_SIZE]) {
    ch.dbg.trace_buffer.ptr = &ch.dbg.trace_buffer.buffer[0];
 8006688:	4b01      	ldr	r3, [pc, #4]	; (8006690 <trace_next+0x40>)
 800668a:	4a03      	ldr	r2, [pc, #12]	; (8006698 <trace_next+0x48>)
 800668c:	63da      	str	r2, [r3, #60]	; 0x3c
  }
}
 800668e:	bd10      	pop	{r4, pc}
 8006690:	20000b38 	.word	0x20000b38
 8006694:	20001378 	.word	0x20001378
 8006698:	20000b78 	.word	0x20000b78
 800669c:	00000000 	.word	0x00000000

080066a0 <_trace_init>:
#if (CH_DBG_TRACE_MASK != CH_DBG_TRACE_MASK_DISABLED) || defined(__DOXYGEN__)
/**
 * @brief   Trace circular buffer subsystem initialization.
 * @note    Internal use only.
 */
void _trace_init(void) {
 80066a0:	b082      	sub	sp, #8
  unsigned i;

  ch.dbg.trace_buffer.suspended = (uint16_t)~CH_DBG_TRACE_MASK;
 80066a2:	4b10      	ldr	r3, [pc, #64]	; (80066e4 <_trace_init+0x44>)
 80066a4:	f64f 72f0 	movw	r2, #65520	; 0xfff0
 80066a8:	871a      	strh	r2, [r3, #56]	; 0x38
  ch.dbg.trace_buffer.size      = CH_DBG_TRACE_BUFFER_SIZE;
 80066aa:	4b0e      	ldr	r3, [pc, #56]	; (80066e4 <_trace_init+0x44>)
 80066ac:	2280      	movs	r2, #128	; 0x80
 80066ae:	875a      	strh	r2, [r3, #58]	; 0x3a
  ch.dbg.trace_buffer.ptr       = &ch.dbg.trace_buffer.buffer[0];
 80066b0:	4b0c      	ldr	r3, [pc, #48]	; (80066e4 <_trace_init+0x44>)
 80066b2:	4a0d      	ldr	r2, [pc, #52]	; (80066e8 <_trace_init+0x48>)
 80066b4:	63da      	str	r2, [r3, #60]	; 0x3c
  for (i = 0U; i < (unsigned)CH_DBG_TRACE_BUFFER_SIZE; i++) {
 80066b6:	2300      	movs	r3, #0
 80066b8:	9301      	str	r3, [sp, #4]
 80066ba:	e00d      	b.n	80066d8 <_trace_init+0x38>
    ch.dbg.trace_buffer.buffer[i].type = CH_TRACE_TYPE_UNUSED;
 80066bc:	4a09      	ldr	r2, [pc, #36]	; (80066e4 <_trace_init+0x44>)
 80066be:	9b01      	ldr	r3, [sp, #4]
 80066c0:	3301      	adds	r3, #1
 80066c2:	011b      	lsls	r3, r3, #4
 80066c4:	4413      	add	r3, r2
 80066c6:	f103 0228 	add.w	r2, r3, #40	; 0x28
 80066ca:	7a13      	ldrb	r3, [r2, #8]
 80066cc:	f36f 0302 	bfc	r3, #0, #3
 80066d0:	7213      	strb	r3, [r2, #8]
  for (i = 0U; i < (unsigned)CH_DBG_TRACE_BUFFER_SIZE; i++) {
 80066d2:	9b01      	ldr	r3, [sp, #4]
 80066d4:	3301      	adds	r3, #1
 80066d6:	9301      	str	r3, [sp, #4]
 80066d8:	9b01      	ldr	r3, [sp, #4]
 80066da:	2b7f      	cmp	r3, #127	; 0x7f
 80066dc:	d9ee      	bls.n	80066bc <_trace_init+0x1c>
  }
}
 80066de:	b002      	add	sp, #8
 80066e0:	4770      	bx	lr
 80066e2:	bf00      	nop
 80066e4:	20000b38 	.word	0x20000b38
 80066e8:	20000b78 	.word	0x20000b78
 80066ec:	00000000 	.word	0x00000000

080066f0 <_trace_switch>:
 * @param[in] ntp       the thread being switched in
 * @param[in] otp       the thread being switched out
 *
 * @notapi
 */
void _trace_switch(thread_t *ntp, thread_t *otp) {
 80066f0:	b500      	push	{lr}
 80066f2:	b083      	sub	sp, #12
 80066f4:	9001      	str	r0, [sp, #4]
 80066f6:	9100      	str	r1, [sp, #0]

  (void)ntp;

  if ((ch.dbg.trace_buffer.suspended & CH_DBG_TRACE_MASK_SWITCH) == 0U) {
 80066f8:	4b14      	ldr	r3, [pc, #80]	; (800674c <_trace_switch+0x5c>)
 80066fa:	8f1b      	ldrh	r3, [r3, #56]	; 0x38
 80066fc:	f003 0301 	and.w	r3, r3, #1
 8006700:	2b00      	cmp	r3, #0
 8006702:	d11f      	bne.n	8006744 <_trace_switch+0x54>
    ch.dbg.trace_buffer.ptr->type        = CH_TRACE_TYPE_SWITCH;
 8006704:	4b11      	ldr	r3, [pc, #68]	; (800674c <_trace_switch+0x5c>)
 8006706:	6bda      	ldr	r2, [r3, #60]	; 0x3c
 8006708:	7813      	ldrb	r3, [r2, #0]
 800670a:	2101      	movs	r1, #1
 800670c:	f361 0302 	bfi	r3, r1, #0, #3
 8006710:	7013      	strb	r3, [r2, #0]
    ch.dbg.trace_buffer.ptr->state       = (uint8_t)otp->state;
 8006712:	9b00      	ldr	r3, [sp, #0]
 8006714:	f893 1020 	ldrb.w	r1, [r3, #32]
 8006718:	4b0c      	ldr	r3, [pc, #48]	; (800674c <_trace_switch+0x5c>)
 800671a:	6bda      	ldr	r2, [r3, #60]	; 0x3c
 800671c:	460b      	mov	r3, r1
 800671e:	f003 031f 	and.w	r3, r3, #31
 8006722:	b2d9      	uxtb	r1, r3
 8006724:	7813      	ldrb	r3, [r2, #0]
 8006726:	f361 03c7 	bfi	r3, r1, #3, #5
 800672a:	7013      	strb	r3, [r2, #0]
    ch.dbg.trace_buffer.ptr->u.sw.ntp    = currp;
 800672c:	4b07      	ldr	r3, [pc, #28]	; (800674c <_trace_switch+0x5c>)
 800672e:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8006730:	4a06      	ldr	r2, [pc, #24]	; (800674c <_trace_switch+0x5c>)
 8006732:	6992      	ldr	r2, [r2, #24]
 8006734:	609a      	str	r2, [r3, #8]
    ch.dbg.trace_buffer.ptr->u.sw.wtobjp = otp->u.wtobjp;
 8006736:	4b05      	ldr	r3, [pc, #20]	; (800674c <_trace_switch+0x5c>)
 8006738:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 800673a:	9a00      	ldr	r2, [sp, #0]
 800673c:	6a52      	ldr	r2, [r2, #36]	; 0x24
 800673e:	60da      	str	r2, [r3, #12]
    trace_next();
 8006740:	f7ff ff86 	bl	8006650 <trace_next>
  }
}
 8006744:	b003      	add	sp, #12
 8006746:	f85d fb04 	ldr.w	pc, [sp], #4
 800674a:	bf00      	nop
 800674c:	20000b38 	.word	0x20000b38

08006750 <_trace_isr_enter>:
 *
 * @param[in] isr       name of the isr
 *
 * @notapi
 */
void _trace_isr_enter(const char *isr) {
 8006750:	b500      	push	{lr}
 8006752:	b083      	sub	sp, #12
 8006754:	9001      	str	r0, [sp, #4]

  if ((ch.dbg.trace_buffer.suspended & CH_DBG_TRACE_MASK_ISR) == 0U) {
 8006756:	4b10      	ldr	r3, [pc, #64]	; (8006798 <_trace_isr_enter+0x48>)
 8006758:	8f1b      	ldrh	r3, [r3, #56]	; 0x38
 800675a:	f003 0302 	and.w	r3, r3, #2
 800675e:	2b00      	cmp	r3, #0
 8006760:	d116      	bne.n	8006790 <_trace_isr_enter+0x40>
    port_lock_from_isr();
 8006762:	f7ff ff45 	bl	80065f0 <port_lock_from_isr.lto_priv.554>
    ch.dbg.trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_ENTER;
 8006766:	4b0c      	ldr	r3, [pc, #48]	; (8006798 <_trace_isr_enter+0x48>)
 8006768:	6bda      	ldr	r2, [r3, #60]	; 0x3c
 800676a:	7813      	ldrb	r3, [r2, #0]
 800676c:	2102      	movs	r1, #2
 800676e:	f361 0302 	bfi	r3, r1, #0, #3
 8006772:	7013      	strb	r3, [r2, #0]
    ch.dbg.trace_buffer.ptr->state       = 0U;
 8006774:	4b08      	ldr	r3, [pc, #32]	; (8006798 <_trace_isr_enter+0x48>)
 8006776:	6bda      	ldr	r2, [r3, #60]	; 0x3c
 8006778:	7813      	ldrb	r3, [r2, #0]
 800677a:	f36f 03c7 	bfc	r3, #3, #5
 800677e:	7013      	strb	r3, [r2, #0]
    ch.dbg.trace_buffer.ptr->u.isr.name  = isr;
 8006780:	4b05      	ldr	r3, [pc, #20]	; (8006798 <_trace_isr_enter+0x48>)
 8006782:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8006784:	9a01      	ldr	r2, [sp, #4]
 8006786:	609a      	str	r2, [r3, #8]
    trace_next();
 8006788:	f7ff ff62 	bl	8006650 <trace_next>
    port_unlock_from_isr();
 800678c:	f7ff ff38 	bl	8006600 <port_unlock_from_isr.lto_priv.542>
  }
}
 8006790:	b003      	add	sp, #12
 8006792:	f85d fb04 	ldr.w	pc, [sp], #4
 8006796:	bf00      	nop
 8006798:	20000b38 	.word	0x20000b38
 800679c:	00000000 	.word	0x00000000

080067a0 <_trace_isr_leave>:
 *
 * @param[in] isr       name of the isr
 *
 * @notapi
 */
void _trace_isr_leave(const char *isr) {
 80067a0:	b500      	push	{lr}
 80067a2:	b083      	sub	sp, #12
 80067a4:	9001      	str	r0, [sp, #4]

  if ((ch.dbg.trace_buffer.suspended & CH_DBG_TRACE_MASK_ISR) == 0U) {
 80067a6:	4b10      	ldr	r3, [pc, #64]	; (80067e8 <_trace_isr_leave+0x48>)
 80067a8:	8f1b      	ldrh	r3, [r3, #56]	; 0x38
 80067aa:	f003 0302 	and.w	r3, r3, #2
 80067ae:	2b00      	cmp	r3, #0
 80067b0:	d116      	bne.n	80067e0 <_trace_isr_leave+0x40>
    port_lock_from_isr();
 80067b2:	f7ff ff1d 	bl	80065f0 <port_lock_from_isr.lto_priv.554>
    ch.dbg.trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_LEAVE;
 80067b6:	4b0c      	ldr	r3, [pc, #48]	; (80067e8 <_trace_isr_leave+0x48>)
 80067b8:	6bda      	ldr	r2, [r3, #60]	; 0x3c
 80067ba:	7813      	ldrb	r3, [r2, #0]
 80067bc:	2103      	movs	r1, #3
 80067be:	f361 0302 	bfi	r3, r1, #0, #3
 80067c2:	7013      	strb	r3, [r2, #0]
    ch.dbg.trace_buffer.ptr->state       = 0U;
 80067c4:	4b08      	ldr	r3, [pc, #32]	; (80067e8 <_trace_isr_leave+0x48>)
 80067c6:	6bda      	ldr	r2, [r3, #60]	; 0x3c
 80067c8:	7813      	ldrb	r3, [r2, #0]
 80067ca:	f36f 03c7 	bfc	r3, #3, #5
 80067ce:	7013      	strb	r3, [r2, #0]
    ch.dbg.trace_buffer.ptr->u.isr.name  = isr;
 80067d0:	4b05      	ldr	r3, [pc, #20]	; (80067e8 <_trace_isr_leave+0x48>)
 80067d2:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 80067d4:	9a01      	ldr	r2, [sp, #4]
 80067d6:	609a      	str	r2, [r3, #8]
    trace_next();
 80067d8:	f7ff ff3a 	bl	8006650 <trace_next>
    port_unlock_from_isr();
 80067dc:	f7ff ff10 	bl	8006600 <port_unlock_from_isr.lto_priv.542>
  }
}
 80067e0:	b003      	add	sp, #12
 80067e2:	f85d fb04 	ldr.w	pc, [sp], #4
 80067e6:	bf00      	nop
 80067e8:	20000b38 	.word	0x20000b38
 80067ec:	00000000 	.word	0x00000000

080067f0 <_trace_halt>:
 *
 * @param[in] reason    the halt error string
 *
 * @notapi
 */
void _trace_halt(const char *reason) {
 80067f0:	b500      	push	{lr}
 80067f2:	b083      	sub	sp, #12
 80067f4:	9001      	str	r0, [sp, #4]

  if ((ch.dbg.trace_buffer.suspended & CH_DBG_TRACE_MASK_HALT) == 0U) {
 80067f6:	4b0e      	ldr	r3, [pc, #56]	; (8006830 <_trace_halt+0x40>)
 80067f8:	8f1b      	ldrh	r3, [r3, #56]	; 0x38
 80067fa:	f003 0304 	and.w	r3, r3, #4
 80067fe:	2b00      	cmp	r3, #0
 8006800:	d112      	bne.n	8006828 <_trace_halt+0x38>
    ch.dbg.trace_buffer.ptr->type          = CH_TRACE_TYPE_HALT;
 8006802:	4b0b      	ldr	r3, [pc, #44]	; (8006830 <_trace_halt+0x40>)
 8006804:	6bda      	ldr	r2, [r3, #60]	; 0x3c
 8006806:	7813      	ldrb	r3, [r2, #0]
 8006808:	2104      	movs	r1, #4
 800680a:	f361 0302 	bfi	r3, r1, #0, #3
 800680e:	7013      	strb	r3, [r2, #0]
    ch.dbg.trace_buffer.ptr->state         = 0;
 8006810:	4b07      	ldr	r3, [pc, #28]	; (8006830 <_trace_halt+0x40>)
 8006812:	6bda      	ldr	r2, [r3, #60]	; 0x3c
 8006814:	7813      	ldrb	r3, [r2, #0]
 8006816:	f36f 03c7 	bfc	r3, #3, #5
 800681a:	7013      	strb	r3, [r2, #0]
    ch.dbg.trace_buffer.ptr->u.halt.reason = reason;
 800681c:	4b04      	ldr	r3, [pc, #16]	; (8006830 <_trace_halt+0x40>)
 800681e:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8006820:	9a01      	ldr	r2, [sp, #4]
 8006822:	609a      	str	r2, [r3, #8]
    trace_next();
 8006824:	f7ff ff14 	bl	8006650 <trace_next>
  }
}
 8006828:	b003      	add	sp, #12
 800682a:	f85d fb04 	ldr.w	pc, [sp], #4
 800682e:	bf00      	nop
 8006830:	20000b38 	.word	0x20000b38
	...

08006840 <chTimeAddX.lto_priv.460>:
                                   sysinterval_t interval) {
 8006840:	b082      	sub	sp, #8
 8006842:	9001      	str	r0, [sp, #4]
 8006844:	9100      	str	r1, [sp, #0]
  return systime + (systime_t)interval;
 8006846:	9a01      	ldr	r2, [sp, #4]
 8006848:	9b00      	ldr	r3, [sp, #0]
 800684a:	4413      	add	r3, r2
}
 800684c:	4618      	mov	r0, r3
 800684e:	b002      	add	sp, #8
 8006850:	4770      	bx	lr
 8006852:	bf00      	nop
	...

08006860 <chTimeDiffX.lto_priv.645>:
static inline sysinterval_t chTimeDiffX(systime_t start, systime_t end) {
 8006860:	b082      	sub	sp, #8
 8006862:	9001      	str	r0, [sp, #4]
 8006864:	9100      	str	r1, [sp, #0]
  return (sysinterval_t)((systime_t)(end - start));
 8006866:	9a00      	ldr	r2, [sp, #0]
 8006868:	9b01      	ldr	r3, [sp, #4]
 800686a:	1ad3      	subs	r3, r2, r3
}
 800686c:	4618      	mov	r0, r3
 800686e:	b002      	add	sp, #8
 8006870:	4770      	bx	lr
 8006872:	bf00      	nop
	...

08006880 <st_lld_get_counter.lto_priv.447>:
  return (systime_t)STM32_ST_TIM->CNT;
 8006880:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8006884:	6a5b      	ldr	r3, [r3, #36]	; 0x24
}
 8006886:	4618      	mov	r0, r3
 8006888:	4770      	bx	lr
 800688a:	bf00      	nop
 800688c:	0000      	movs	r0, r0
	...

08006890 <port_timer_start_alarm>:
static inline void port_timer_start_alarm(systime_t time) {
 8006890:	b500      	push	{lr}
 8006892:	b083      	sub	sp, #12
 8006894:	9001      	str	r0, [sp, #4]
  stStartAlarm(time);
 8006896:	9801      	ldr	r0, [sp, #4]
 8006898:	f7fa fae2 	bl	8000e60 <stStartAlarm>
}
 800689c:	b003      	add	sp, #12
 800689e:	f85d fb04 	ldr.w	pc, [sp], #4
 80068a2:	bf00      	nop
	...

080068b0 <port_timer_stop_alarm.lto_priv.652>:
static inline void port_timer_stop_alarm(void) {
 80068b0:	b508      	push	{r3, lr}
  stStopAlarm();
 80068b2:	f7fa faed 	bl	8000e90 <stStopAlarm>
}
 80068b6:	bd08      	pop	{r3, pc}
	...

080068c0 <port_timer_set_alarm.lto_priv.650>:
static inline void port_timer_set_alarm(systime_t time) {
 80068c0:	b500      	push	{lr}
 80068c2:	b083      	sub	sp, #12
 80068c4:	9001      	str	r0, [sp, #4]
  stSetAlarm(time);
 80068c6:	9801      	ldr	r0, [sp, #4]
 80068c8:	f7fa faea 	bl	8000ea0 <stSetAlarm>
}
 80068cc:	b003      	add	sp, #12
 80068ce:	f85d fb04 	ldr.w	pc, [sp], #4
 80068d2:	bf00      	nop
	...

080068e0 <port_timer_get_time.lto_priv.436>:
static inline systime_t port_timer_get_time(void) {
 80068e0:	b508      	push	{r3, lr}
  return stGetCounter();
 80068e2:	f7ff ffcd 	bl	8006880 <st_lld_get_counter.lto_priv.447>
 80068e6:	4603      	mov	r3, r0
}
 80068e8:	4618      	mov	r0, r3
 80068ea:	bd08      	pop	{r3, pc}
 80068ec:	0000      	movs	r0, r0
	...

080068f0 <chVTGetSystemTimeX.lto_priv.358>:
static inline systime_t chVTGetSystemTimeX(void) {
 80068f0:	b508      	push	{r3, lr}
  return port_timer_get_time();
 80068f2:	f7ff fff5 	bl	80068e0 <port_timer_get_time.lto_priv.436>
 80068f6:	4603      	mov	r3, r0
}
 80068f8:	4618      	mov	r0, r3
 80068fa:	bd08      	pop	{r3, pc}
 80068fc:	0000      	movs	r0, r0
	...

08006900 <_vt_init>:
 *
 * @notapi
 */
void _vt_init(void) {

  ch.vtlist.next = (virtual_timer_t *)&ch.vtlist;
 8006900:	4b06      	ldr	r3, [pc, #24]	; (800691c <_vt_init+0x1c>)
 8006902:	4a07      	ldr	r2, [pc, #28]	; (8006920 <_vt_init+0x20>)
 8006904:	61da      	str	r2, [r3, #28]
  ch.vtlist.prev = (virtual_timer_t *)&ch.vtlist;
 8006906:	4b05      	ldr	r3, [pc, #20]	; (800691c <_vt_init+0x1c>)
 8006908:	4a05      	ldr	r2, [pc, #20]	; (8006920 <_vt_init+0x20>)
 800690a:	621a      	str	r2, [r3, #32]
  ch.vtlist.delta = (sysinterval_t)-1;
 800690c:	4b03      	ldr	r3, [pc, #12]	; (800691c <_vt_init+0x1c>)
 800690e:	f04f 32ff 	mov.w	r2, #4294967295
 8006912:	625a      	str	r2, [r3, #36]	; 0x24
#if CH_CFG_ST_TIMEDELTA == 0
  ch.vtlist.systime = (systime_t)0;
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  ch.vtlist.lasttime = (systime_t)0;
 8006914:	4b01      	ldr	r3, [pc, #4]	; (800691c <_vt_init+0x1c>)
 8006916:	2200      	movs	r2, #0
 8006918:	629a      	str	r2, [r3, #40]	; 0x28
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
 800691a:	4770      	bx	lr
 800691c:	20000b38 	.word	0x20000b38
 8006920:	20000b54 	.word	0x20000b54
	...

08006930 <chVTDoSetI>:
 *                      function
 *
 * @iclass
 */
void chVTDoSetI(virtual_timer_t *vtp, sysinterval_t delay,
                vtfunc_t vtfunc, void *par) {
 8006930:	b500      	push	{lr}
 8006932:	b089      	sub	sp, #36	; 0x24
 8006934:	9003      	str	r0, [sp, #12]
 8006936:	9102      	str	r1, [sp, #8]
 8006938:	9201      	str	r2, [sp, #4]
 800693a:	9300      	str	r3, [sp, #0]
  virtual_timer_t *p;
  sysinterval_t delta;

  chDbgCheckClassI();
 800693c:	f7ff fe18 	bl	8006570 <chDbgCheckClassI>
  chDbgCheck((vtp != NULL) && (vtfunc != NULL) && (delay != TIME_IMMEDIATE));
 8006940:	9b03      	ldr	r3, [sp, #12]
 8006942:	2b00      	cmp	r3, #0
 8006944:	d005      	beq.n	8006952 <chVTDoSetI+0x22>
 8006946:	9b01      	ldr	r3, [sp, #4]
 8006948:	2b00      	cmp	r3, #0
 800694a:	d002      	beq.n	8006952 <chVTDoSetI+0x22>
 800694c:	9b02      	ldr	r3, [sp, #8]
 800694e:	2b00      	cmp	r3, #0
 8006950:	d102      	bne.n	8006958 <chVTDoSetI+0x28>
 8006952:	484c      	ldr	r0, [pc, #304]	; (8006a84 <chVTDoSetI+0x154>)
 8006954:	f7ff fcec 	bl	8006330 <chSysHalt>

  vtp->par = par;
 8006958:	9b03      	ldr	r3, [sp, #12]
 800695a:	9a00      	ldr	r2, [sp, #0]
 800695c:	611a      	str	r2, [r3, #16]
  vtp->func = vtfunc;
 800695e:	9b03      	ldr	r3, [sp, #12]
 8006960:	9a01      	ldr	r2, [sp, #4]
 8006962:	60da      	str	r2, [r3, #12]

#if CH_CFG_ST_TIMEDELTA > 0
  {
    systime_t now = chVTGetSystemTimeX();
 8006964:	f7ff ffc4 	bl	80068f0 <chVTGetSystemTimeX.lto_priv.358>
 8006968:	9005      	str	r0, [sp, #20]

    /* If the requested delay is lower than the minimum safe delta then it
       is raised to the minimum safe value.*/
    if (delay < (sysinterval_t)CH_CFG_ST_TIMEDELTA) {
 800696a:	9b02      	ldr	r3, [sp, #8]
 800696c:	2b01      	cmp	r3, #1
 800696e:	d801      	bhi.n	8006974 <chVTDoSetI+0x44>
      delay = (sysinterval_t)CH_CFG_ST_TIMEDELTA;
 8006970:	2302      	movs	r3, #2
 8006972:	9302      	str	r3, [sp, #8]
    }

    /* Special case where the timers list is empty.*/
    if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.next) {
 8006974:	4b44      	ldr	r3, [pc, #272]	; (8006a88 <chVTDoSetI+0x158>)
 8006976:	69db      	ldr	r3, [r3, #28]
 8006978:	4a44      	ldr	r2, [pc, #272]	; (8006a8c <chVTDoSetI+0x15c>)
 800697a:	4293      	cmp	r3, r2
 800697c:	d11c      	bne.n	80069b8 <chVTDoSetI+0x88>

      /* The delta list is empty, the current time becomes the new
         delta list base time, the timer is inserted.*/
      ch.vtlist.lasttime = now;
 800697e:	4a42      	ldr	r2, [pc, #264]	; (8006a88 <chVTDoSetI+0x158>)
 8006980:	9b05      	ldr	r3, [sp, #20]
 8006982:	6293      	str	r3, [r2, #40]	; 0x28
      ch.vtlist.next = vtp;
 8006984:	4a40      	ldr	r2, [pc, #256]	; (8006a88 <chVTDoSetI+0x158>)
 8006986:	9b03      	ldr	r3, [sp, #12]
 8006988:	61d3      	str	r3, [r2, #28]
      ch.vtlist.prev = vtp;
 800698a:	4a3f      	ldr	r2, [pc, #252]	; (8006a88 <chVTDoSetI+0x158>)
 800698c:	9b03      	ldr	r3, [sp, #12]
 800698e:	6213      	str	r3, [r2, #32]
      vtp->next = (virtual_timer_t *)&ch.vtlist;
 8006990:	9b03      	ldr	r3, [sp, #12]
 8006992:	4a3e      	ldr	r2, [pc, #248]	; (8006a8c <chVTDoSetI+0x15c>)
 8006994:	601a      	str	r2, [r3, #0]
      vtp->prev = (virtual_timer_t *)&ch.vtlist;
 8006996:	9b03      	ldr	r3, [sp, #12]
 8006998:	4a3c      	ldr	r2, [pc, #240]	; (8006a8c <chVTDoSetI+0x15c>)
 800699a:	605a      	str	r2, [r3, #4]
      vtp->delta = delay;
 800699c:	9b03      	ldr	r3, [sp, #12]
 800699e:	9a02      	ldr	r2, [sp, #8]
 80069a0:	609a      	str	r2, [r3, #8]
        delay = (sysinterval_t)TIME_MAX_SYSTIME;
      }
#endif

      /* Being the first element in the list the alarm timer is started.*/
      port_timer_start_alarm(chTimeAddX(ch.vtlist.lasttime, delay));
 80069a2:	4b39      	ldr	r3, [pc, #228]	; (8006a88 <chVTDoSetI+0x158>)
 80069a4:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 80069a6:	9902      	ldr	r1, [sp, #8]
 80069a8:	4618      	mov	r0, r3
 80069aa:	f7ff ff49 	bl	8006840 <chTimeAddX.lto_priv.460>
 80069ae:	4603      	mov	r3, r0
 80069b0:	4618      	mov	r0, r3
 80069b2:	f7ff ff6d 	bl	8006890 <port_timer_start_alarm>
 80069b6:	e061      	b.n	8006a7c <chVTDoSetI+0x14c>

      return;
    }

    /* Pointer to the first element in the delta list, which is non-empty.*/
    p = ch.vtlist.next;
 80069b8:	4b33      	ldr	r3, [pc, #204]	; (8006a88 <chVTDoSetI+0x158>)
 80069ba:	69db      	ldr	r3, [r3, #28]
 80069bc:	9307      	str	r3, [sp, #28]

    /* Delay as delta from 'lasttime'. Note, it can overflow and the value
       becomes lower than 'now'.*/
    delta = chTimeDiffX(ch.vtlist.lasttime, now) + delay;
 80069be:	4b32      	ldr	r3, [pc, #200]	; (8006a88 <chVTDoSetI+0x158>)
 80069c0:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 80069c2:	9905      	ldr	r1, [sp, #20]
 80069c4:	4618      	mov	r0, r3
 80069c6:	f7ff ff4b 	bl	8006860 <chTimeDiffX.lto_priv.645>
 80069ca:	4602      	mov	r2, r0
 80069cc:	9b02      	ldr	r3, [sp, #8]
 80069ce:	4413      	add	r3, r2
 80069d0:	9306      	str	r3, [sp, #24]

    if (delta < chTimeDiffX(ch.vtlist.lasttime, now)) {
 80069d2:	4b2d      	ldr	r3, [pc, #180]	; (8006a88 <chVTDoSetI+0x158>)
 80069d4:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 80069d6:	9905      	ldr	r1, [sp, #20]
 80069d8:	4618      	mov	r0, r3
 80069da:	f7ff ff41 	bl	8006860 <chTimeDiffX.lto_priv.645>
 80069de:	4602      	mov	r2, r0
 80069e0:	9b06      	ldr	r3, [sp, #24]
 80069e2:	4293      	cmp	r3, r2
 80069e4:	d208      	bcs.n	80069f8 <chVTDoSetI+0xc8>
      /* Scenario where a very large delay excedeed the numeric range, it
         requires a special handling. We need to skip the first element and
         adjust the delta to wrap back in the previous numeric range.*/
      delta -= p->delta;
 80069e6:	9b07      	ldr	r3, [sp, #28]
 80069e8:	689b      	ldr	r3, [r3, #8]
 80069ea:	9a06      	ldr	r2, [sp, #24]
 80069ec:	1ad3      	subs	r3, r2, r3
 80069ee:	9306      	str	r3, [sp, #24]
      p = p->next;
 80069f0:	9b07      	ldr	r3, [sp, #28]
 80069f2:	681b      	ldr	r3, [r3, #0]
 80069f4:	9307      	str	r3, [sp, #28]
 80069f6:	e020      	b.n	8006a3a <chVTDoSetI+0x10a>
    }
    else if (delta < p->delta) {
 80069f8:	9b07      	ldr	r3, [sp, #28]
 80069fa:	689b      	ldr	r3, [r3, #8]
 80069fc:	9a06      	ldr	r2, [sp, #24]
 80069fe:	429a      	cmp	r2, r3
 8006a00:	d21b      	bcs.n	8006a3a <chVTDoSetI+0x10a>
      sysinterval_t deadline_delta;

      /* A small delay that will become the first element in the delta list
         and next deadline.*/
      deadline_delta = delta;
 8006a02:	9b06      	ldr	r3, [sp, #24]
 8006a04:	9304      	str	r3, [sp, #16]
      /* The delta could be too large for the physical timer to handle.*/
      if (deadline_delta > (sysinterval_t)TIME_MAX_SYSTIME) {
        deadline_delta = (sysinterval_t)TIME_MAX_SYSTIME;
      }
#endif
      port_timer_set_alarm(chTimeAddX(ch.vtlist.lasttime, deadline_delta));
 8006a06:	4b20      	ldr	r3, [pc, #128]	; (8006a88 <chVTDoSetI+0x158>)
 8006a08:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8006a0a:	9904      	ldr	r1, [sp, #16]
 8006a0c:	4618      	mov	r0, r3
 8006a0e:	f7ff ff17 	bl	8006840 <chTimeAddX.lto_priv.460>
 8006a12:	4603      	mov	r3, r0
 8006a14:	4618      	mov	r0, r3
 8006a16:	f7ff ff53 	bl	80068c0 <port_timer_set_alarm.lto_priv.650>
 8006a1a:	e00e      	b.n	8006a3a <chVTDoSetI+0x10a>

  /* The delta list is scanned in order to find the correct position for
     this timer. */
  while (p->delta < delta) {
    /* Debug assert if the timer is already in the list.*/
    chDbgAssert(p != vtp, "timer already armed");
 8006a1c:	9a07      	ldr	r2, [sp, #28]
 8006a1e:	9b03      	ldr	r3, [sp, #12]
 8006a20:	429a      	cmp	r2, r3
 8006a22:	d102      	bne.n	8006a2a <chVTDoSetI+0xfa>
 8006a24:	4817      	ldr	r0, [pc, #92]	; (8006a84 <chVTDoSetI+0x154>)
 8006a26:	f7ff fc83 	bl	8006330 <chSysHalt>

    delta -= p->delta;
 8006a2a:	9b07      	ldr	r3, [sp, #28]
 8006a2c:	689b      	ldr	r3, [r3, #8]
 8006a2e:	9a06      	ldr	r2, [sp, #24]
 8006a30:	1ad3      	subs	r3, r2, r3
 8006a32:	9306      	str	r3, [sp, #24]
    p = p->next;
 8006a34:	9b07      	ldr	r3, [sp, #28]
 8006a36:	681b      	ldr	r3, [r3, #0]
 8006a38:	9307      	str	r3, [sp, #28]
  while (p->delta < delta) {
 8006a3a:	9b07      	ldr	r3, [sp, #28]
 8006a3c:	689b      	ldr	r3, [r3, #8]
 8006a3e:	9a06      	ldr	r2, [sp, #24]
 8006a40:	429a      	cmp	r2, r3
 8006a42:	d8eb      	bhi.n	8006a1c <chVTDoSetI+0xec>
  }

  /* The timer is inserted in the delta list.*/
  vtp->next = p;
 8006a44:	9b03      	ldr	r3, [sp, #12]
 8006a46:	9a07      	ldr	r2, [sp, #28]
 8006a48:	601a      	str	r2, [r3, #0]
  vtp->prev = vtp->next->prev;
 8006a4a:	9b03      	ldr	r3, [sp, #12]
 8006a4c:	681b      	ldr	r3, [r3, #0]
 8006a4e:	685a      	ldr	r2, [r3, #4]
 8006a50:	9b03      	ldr	r3, [sp, #12]
 8006a52:	605a      	str	r2, [r3, #4]
  vtp->prev->next = vtp;
 8006a54:	9b03      	ldr	r3, [sp, #12]
 8006a56:	685b      	ldr	r3, [r3, #4]
 8006a58:	9a03      	ldr	r2, [sp, #12]
 8006a5a:	601a      	str	r2, [r3, #0]
  p->prev = vtp;
 8006a5c:	9b07      	ldr	r3, [sp, #28]
 8006a5e:	9a03      	ldr	r2, [sp, #12]
 8006a60:	605a      	str	r2, [r3, #4]
  vtp->delta = delta;
 8006a62:	9b03      	ldr	r3, [sp, #12]
 8006a64:	9a06      	ldr	r2, [sp, #24]
 8006a66:	609a      	str	r2, [r3, #8]

  /* Calculate new delta for the following entry.*/
  p->delta -= delta;
 8006a68:	9b07      	ldr	r3, [sp, #28]
 8006a6a:	689a      	ldr	r2, [r3, #8]
 8006a6c:	9b06      	ldr	r3, [sp, #24]
 8006a6e:	1ad2      	subs	r2, r2, r3
 8006a70:	9b07      	ldr	r3, [sp, #28]
 8006a72:	609a      	str	r2, [r3, #8]

  /* Special case when the timer is in last position in the list, the
     value in the header must be restored.*/
  ch.vtlist.delta = (sysinterval_t)-1;
 8006a74:	4b04      	ldr	r3, [pc, #16]	; (8006a88 <chVTDoSetI+0x158>)
 8006a76:	f04f 32ff 	mov.w	r2, #4294967295
 8006a7a:	625a      	str	r2, [r3, #36]	; 0x24
}
 8006a7c:	b009      	add	sp, #36	; 0x24
 8006a7e:	f85d fb04 	ldr.w	pc, [sp], #4
 8006a82:	bf00      	nop
 8006a84:	08009630 	.word	0x08009630
 8006a88:	20000b38 	.word	0x20000b38
 8006a8c:	20000b54 	.word	0x20000b54

08006a90 <chVTDoResetI>:
 *
 * @param[in] vtp       the @p virtual_timer_t structure pointer
 *
 * @iclass
 */
void chVTDoResetI(virtual_timer_t *vtp) {
 8006a90:	b510      	push	{r4, lr}
 8006a92:	b084      	sub	sp, #16
 8006a94:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();
 8006a96:	f7ff fd6b 	bl	8006570 <chDbgCheckClassI>
  chDbgCheck(vtp != NULL);
 8006a9a:	9b01      	ldr	r3, [sp, #4]
 8006a9c:	2b00      	cmp	r3, #0
 8006a9e:	d102      	bne.n	8006aa6 <chVTDoResetI+0x16>
 8006aa0:	483a      	ldr	r0, [pc, #232]	; (8006b8c <chVTDoResetI+0xfc>)
 8006aa2:	f7ff fc45 	bl	8006330 <chSysHalt>
  chDbgAssert(vtp->func != NULL, "timer not set or already triggered");
 8006aa6:	9b01      	ldr	r3, [sp, #4]
 8006aa8:	68db      	ldr	r3, [r3, #12]
 8006aaa:	2b00      	cmp	r3, #0
 8006aac:	d102      	bne.n	8006ab4 <chVTDoResetI+0x24>
 8006aae:	4837      	ldr	r0, [pc, #220]	; (8006b8c <chVTDoResetI+0xfc>)
 8006ab0:	f7ff fc3e 	bl	8006330 <chSysHalt>
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  sysinterval_t nowdelta, delta;

  /* If the timer is not the first of the list then it is simply unlinked
     else the operation is more complex.*/
  if (ch.vtlist.next != vtp) {
 8006ab4:	4b36      	ldr	r3, [pc, #216]	; (8006b90 <chVTDoResetI+0x100>)
 8006ab6:	69db      	ldr	r3, [r3, #28]
 8006ab8:	9a01      	ldr	r2, [sp, #4]
 8006aba:	429a      	cmp	r2, r3
 8006abc:	d01b      	beq.n	8006af6 <chVTDoResetI+0x66>
    /* Removing the element from the delta list.*/
    vtp->prev->next = vtp->next;
 8006abe:	9b01      	ldr	r3, [sp, #4]
 8006ac0:	685b      	ldr	r3, [r3, #4]
 8006ac2:	9a01      	ldr	r2, [sp, #4]
 8006ac4:	6812      	ldr	r2, [r2, #0]
 8006ac6:	601a      	str	r2, [r3, #0]
    vtp->next->prev = vtp->prev;
 8006ac8:	9b01      	ldr	r3, [sp, #4]
 8006aca:	681b      	ldr	r3, [r3, #0]
 8006acc:	9a01      	ldr	r2, [sp, #4]
 8006ace:	6852      	ldr	r2, [r2, #4]
 8006ad0:	605a      	str	r2, [r3, #4]
    vtp->func = NULL;
 8006ad2:	9b01      	ldr	r3, [sp, #4]
 8006ad4:	2200      	movs	r2, #0
 8006ad6:	60da      	str	r2, [r3, #12]

    /* Adding delta to the next element, if it is not the last one.*/
    if (&ch.vtlist != (virtual_timers_list_t *)vtp->next)
 8006ad8:	9b01      	ldr	r3, [sp, #4]
 8006ada:	681b      	ldr	r3, [r3, #0]
 8006adc:	4a2d      	ldr	r2, [pc, #180]	; (8006b94 <chVTDoResetI+0x104>)
 8006ade:	4293      	cmp	r3, r2
 8006ae0:	d051      	beq.n	8006b86 <chVTDoResetI+0xf6>
      vtp->next->delta += vtp->delta;
 8006ae2:	9b01      	ldr	r3, [sp, #4]
 8006ae4:	681b      	ldr	r3, [r3, #0]
 8006ae6:	6899      	ldr	r1, [r3, #8]
 8006ae8:	9b01      	ldr	r3, [sp, #4]
 8006aea:	689a      	ldr	r2, [r3, #8]
 8006aec:	9b01      	ldr	r3, [sp, #4]
 8006aee:	681b      	ldr	r3, [r3, #0]
 8006af0:	440a      	add	r2, r1
 8006af2:	609a      	str	r2, [r3, #8]
 8006af4:	e048      	b.n	8006b88 <chVTDoResetI+0xf8>

    return;
  }

  /* Removing the first timer from the list.*/
  ch.vtlist.next = vtp->next;
 8006af6:	9b01      	ldr	r3, [sp, #4]
 8006af8:	681b      	ldr	r3, [r3, #0]
 8006afa:	4a25      	ldr	r2, [pc, #148]	; (8006b90 <chVTDoResetI+0x100>)
 8006afc:	61d3      	str	r3, [r2, #28]
  ch.vtlist.next->prev = (virtual_timer_t *)&ch.vtlist;
 8006afe:	4b24      	ldr	r3, [pc, #144]	; (8006b90 <chVTDoResetI+0x100>)
 8006b00:	69db      	ldr	r3, [r3, #28]
 8006b02:	4a24      	ldr	r2, [pc, #144]	; (8006b94 <chVTDoResetI+0x104>)
 8006b04:	605a      	str	r2, [r3, #4]
  vtp->func = NULL;
 8006b06:	9b01      	ldr	r3, [sp, #4]
 8006b08:	2200      	movs	r2, #0
 8006b0a:	60da      	str	r2, [r3, #12]

  /* If the list become empty then the alarm timer is stopped and done.*/
  if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.next) {
 8006b0c:	4b20      	ldr	r3, [pc, #128]	; (8006b90 <chVTDoResetI+0x100>)
 8006b0e:	69db      	ldr	r3, [r3, #28]
 8006b10:	4a20      	ldr	r2, [pc, #128]	; (8006b94 <chVTDoResetI+0x104>)
 8006b12:	4293      	cmp	r3, r2
 8006b14:	d102      	bne.n	8006b1c <chVTDoResetI+0x8c>
    port_timer_stop_alarm();
 8006b16:	f7ff fecb 	bl	80068b0 <port_timer_stop_alarm.lto_priv.652>
 8006b1a:	e035      	b.n	8006b88 <chVTDoResetI+0xf8>

    return;
  }

  /* The delta of the removed timer is added to the new first timer.*/
  ch.vtlist.next->delta += vtp->delta;
 8006b1c:	4b1c      	ldr	r3, [pc, #112]	; (8006b90 <chVTDoResetI+0x100>)
 8006b1e:	69db      	ldr	r3, [r3, #28]
 8006b20:	6899      	ldr	r1, [r3, #8]
 8006b22:	9b01      	ldr	r3, [sp, #4]
 8006b24:	689a      	ldr	r2, [r3, #8]
 8006b26:	4b1a      	ldr	r3, [pc, #104]	; (8006b90 <chVTDoResetI+0x100>)
 8006b28:	69db      	ldr	r3, [r3, #28]
 8006b2a:	440a      	add	r2, r1
 8006b2c:	609a      	str	r2, [r3, #8]
/*  if (ch.vtlist.next->delta == 0) {
    return;
  }*/

  /* Distance in ticks between the last alarm event and current time.*/
  nowdelta = chTimeDiffX(ch.vtlist.lasttime, chVTGetSystemTimeX());
 8006b2e:	4b18      	ldr	r3, [pc, #96]	; (8006b90 <chVTDoResetI+0x100>)
 8006b30:	6a9c      	ldr	r4, [r3, #40]	; 0x28
 8006b32:	f7ff fedd 	bl	80068f0 <chVTGetSystemTimeX.lto_priv.358>
 8006b36:	4603      	mov	r3, r0
 8006b38:	4619      	mov	r1, r3
 8006b3a:	4620      	mov	r0, r4
 8006b3c:	f7ff fe90 	bl	8006860 <chTimeDiffX.lto_priv.645>
 8006b40:	9002      	str	r0, [sp, #8]

  /* If the current time surpassed the time of the next element in list
     then the event interrupt is already pending, just return.*/
  if (nowdelta >= ch.vtlist.next->delta) {
 8006b42:	4b13      	ldr	r3, [pc, #76]	; (8006b90 <chVTDoResetI+0x100>)
 8006b44:	69db      	ldr	r3, [r3, #28]
 8006b46:	689b      	ldr	r3, [r3, #8]
 8006b48:	9a02      	ldr	r2, [sp, #8]
 8006b4a:	429a      	cmp	r2, r3
 8006b4c:	d21c      	bcs.n	8006b88 <chVTDoResetI+0xf8>
    return;
  }

  /* Distance from the next scheduled event and now.*/
  delta = ch.vtlist.next->delta - nowdelta;
 8006b4e:	4b10      	ldr	r3, [pc, #64]	; (8006b90 <chVTDoResetI+0x100>)
 8006b50:	69db      	ldr	r3, [r3, #28]
 8006b52:	689a      	ldr	r2, [r3, #8]
 8006b54:	9b02      	ldr	r3, [sp, #8]
 8006b56:	1ad3      	subs	r3, r2, r3
 8006b58:	9303      	str	r3, [sp, #12]

  /* Making sure to not schedule an event closer than CH_CFG_ST_TIMEDELTA
     ticks from now.*/
  if (delta < (sysinterval_t)CH_CFG_ST_TIMEDELTA) {
 8006b5a:	9b03      	ldr	r3, [sp, #12]
 8006b5c:	2b01      	cmp	r3, #1
 8006b5e:	d803      	bhi.n	8006b68 <chVTDoResetI+0xd8>
    delta = nowdelta + (sysinterval_t)CH_CFG_ST_TIMEDELTA;
 8006b60:	9b02      	ldr	r3, [sp, #8]
 8006b62:	3302      	adds	r3, #2
 8006b64:	9303      	str	r3, [sp, #12]
 8006b66:	e003      	b.n	8006b70 <chVTDoResetI+0xe0>
  }
  else {
    delta = nowdelta + delta;
 8006b68:	9a03      	ldr	r2, [sp, #12]
 8006b6a:	9b02      	ldr	r3, [sp, #8]
 8006b6c:	4413      	add	r3, r2
 8006b6e:	9303      	str	r3, [sp, #12]
    if (delta > (sysinterval_t)TIME_MAX_SYSTIME) {
      delta = (sysinterval_t)TIME_MAX_SYSTIME;
    }
#endif
  }
  port_timer_set_alarm(chTimeAddX(ch.vtlist.lasttime, delta));
 8006b70:	4b07      	ldr	r3, [pc, #28]	; (8006b90 <chVTDoResetI+0x100>)
 8006b72:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8006b74:	9903      	ldr	r1, [sp, #12]
 8006b76:	4618      	mov	r0, r3
 8006b78:	f7ff fe62 	bl	8006840 <chTimeAddX.lto_priv.460>
 8006b7c:	4603      	mov	r3, r0
 8006b7e:	4618      	mov	r0, r3
 8006b80:	f7ff fe9e 	bl	80068c0 <port_timer_set_alarm.lto_priv.650>
 8006b84:	e000      	b.n	8006b88 <chVTDoResetI+0xf8>
      vtp->next->delta += vtp->delta;
 8006b86:	bf00      	nop
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
 8006b88:	b004      	add	sp, #16
 8006b8a:	bd10      	pop	{r4, pc}
 8006b8c:	0800963c 	.word	0x0800963c
 8006b90:	20000b38 	.word	0x20000b38
 8006b94:	20000b54 	.word	0x20000b54
	...

08006ba0 <port_lock.lto_priv.301>:
static inline void port_lock(void) {
 8006ba0:	b082      	sub	sp, #8
 8006ba2:	2320      	movs	r3, #32
 8006ba4:	9301      	str	r3, [sp, #4]
 8006ba6:	9b01      	ldr	r3, [sp, #4]
 8006ba8:	f383 8811 	msr	BASEPRI, r3
}
 8006bac:	b002      	add	sp, #8
 8006bae:	4770      	bx	lr

08006bb0 <port_unlock.lto_priv.260>:
static inline void port_unlock(void) {
 8006bb0:	b082      	sub	sp, #8
 8006bb2:	2300      	movs	r3, #0
 8006bb4:	9301      	str	r3, [sp, #4]
 8006bb6:	9b01      	ldr	r3, [sp, #4]
 8006bb8:	f383 8811 	msr	BASEPRI, r3
}
 8006bbc:	b002      	add	sp, #8
 8006bbe:	4770      	bx	lr

08006bc0 <port_lock_from_isr.lto_priv.555>:
static inline void port_lock_from_isr(void) {
 8006bc0:	b508      	push	{r3, lr}
  port_lock();
 8006bc2:	f7ff ffed 	bl	8006ba0 <port_lock.lto_priv.301>
}
 8006bc6:	bd08      	pop	{r3, pc}
	...

08006bd0 <port_unlock_from_isr.lto_priv.543>:
static inline void port_unlock_from_isr(void) {
 8006bd0:	b508      	push	{r3, lr}
  port_unlock();
 8006bd2:	f7ff ffed 	bl	8006bb0 <port_unlock.lto_priv.260>
}
 8006bd6:	bd08      	pop	{r3, pc}
	...

08006be0 <queue_init.lto_priv.592>:
static inline void queue_init(threads_queue_t *tqp) {
 8006be0:	b082      	sub	sp, #8
 8006be2:	9001      	str	r0, [sp, #4]
  tqp->next = (thread_t *)tqp;
 8006be4:	9b01      	ldr	r3, [sp, #4]
 8006be6:	9a01      	ldr	r2, [sp, #4]
 8006be8:	601a      	str	r2, [r3, #0]
  tqp->prev = (thread_t *)tqp;
 8006bea:	9b01      	ldr	r3, [sp, #4]
 8006bec:	9a01      	ldr	r2, [sp, #4]
 8006bee:	605a      	str	r2, [r3, #4]
}
 8006bf0:	b002      	add	sp, #8
 8006bf2:	4770      	bx	lr
	...

08006c00 <queue_fifo_remove.lto_priv.598>:
  tp->queue.prev             = tqp->prev;
  tp->queue.prev->queue.next = tp;
  tqp->prev                  = tp;
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
 8006c00:	b084      	sub	sp, #16
 8006c02:	9001      	str	r0, [sp, #4]
  thread_t *tp = tqp->next;
 8006c04:	9b01      	ldr	r3, [sp, #4]
 8006c06:	681b      	ldr	r3, [r3, #0]
 8006c08:	9303      	str	r3, [sp, #12]

  tqp->next             = tp->queue.next;
 8006c0a:	9b03      	ldr	r3, [sp, #12]
 8006c0c:	681a      	ldr	r2, [r3, #0]
 8006c0e:	9b01      	ldr	r3, [sp, #4]
 8006c10:	601a      	str	r2, [r3, #0]
  tqp->next->queue.prev = (thread_t *)tqp;
 8006c12:	9b01      	ldr	r3, [sp, #4]
 8006c14:	681b      	ldr	r3, [r3, #0]
 8006c16:	9a01      	ldr	r2, [sp, #4]
 8006c18:	605a      	str	r2, [r3, #4]

  return tp;
 8006c1a:	9b03      	ldr	r3, [sp, #12]
}
 8006c1c:	4618      	mov	r0, r3
 8006c1e:	b004      	add	sp, #16
 8006c20:	4770      	bx	lr
 8006c22:	bf00      	nop
	...

08006c30 <queue_dequeue.lto_priv.619>:
  tqp->prev->queue.next = (thread_t *)tqp;

  return tp;
}

static inline thread_t *queue_dequeue(thread_t *tp) {
 8006c30:	b082      	sub	sp, #8
 8006c32:	9001      	str	r0, [sp, #4]

  tp->queue.prev->queue.next = tp->queue.next;
 8006c34:	9b01      	ldr	r3, [sp, #4]
 8006c36:	685b      	ldr	r3, [r3, #4]
 8006c38:	9a01      	ldr	r2, [sp, #4]
 8006c3a:	6812      	ldr	r2, [r2, #0]
 8006c3c:	601a      	str	r2, [r3, #0]
  tp->queue.next->queue.prev = tp->queue.prev;
 8006c3e:	9b01      	ldr	r3, [sp, #4]
 8006c40:	681b      	ldr	r3, [r3, #0]
 8006c42:	9a01      	ldr	r2, [sp, #4]
 8006c44:	6852      	ldr	r2, [r2, #4]
 8006c46:	605a      	str	r2, [r3, #4]

  return tp;
 8006c48:	9b01      	ldr	r3, [sp, #4]
}
 8006c4a:	4618      	mov	r0, r3
 8006c4c:	b002      	add	sp, #8
 8006c4e:	4770      	bx	lr

08006c50 <chSchIsRescRequiredI>:
 * @retval false        if rescheduling is not necessary.
 * @retval true         if there is a ready thread at higher priority.
 *
 * @iclass
 */
static inline bool chSchIsRescRequiredI(void) {
 8006c50:	b508      	push	{r3, lr}

  chDbgCheckClassI();
 8006c52:	f7ff fc8d 	bl	8006570 <chDbgCheckClassI>

  return firstprio(&ch.rlist.queue) > currp->prio;
 8006c56:	4b06      	ldr	r3, [pc, #24]	; (8006c70 <chSchIsRescRequiredI+0x20>)
 8006c58:	681b      	ldr	r3, [r3, #0]
 8006c5a:	689a      	ldr	r2, [r3, #8]
 8006c5c:	4b04      	ldr	r3, [pc, #16]	; (8006c70 <chSchIsRescRequiredI+0x20>)
 8006c5e:	699b      	ldr	r3, [r3, #24]
 8006c60:	689b      	ldr	r3, [r3, #8]
 8006c62:	429a      	cmp	r2, r3
 8006c64:	bf8c      	ite	hi
 8006c66:	2301      	movhi	r3, #1
 8006c68:	2300      	movls	r3, #0
 8006c6a:	b2db      	uxtb	r3, r3
}
 8006c6c:	4618      	mov	r0, r3
 8006c6e:	bd08      	pop	{r3, pc}
 8006c70:	20000b38 	.word	0x20000b38
	...

08006c80 <chSysLockFromISR.lto_priv.526>:
static inline void chSysLockFromISR(void) {
 8006c80:	b508      	push	{r3, lr}
  port_lock_from_isr();
 8006c82:	f7ff ff9d 	bl	8006bc0 <port_lock_from_isr.lto_priv.555>
  _dbg_check_lock_from_isr();
 8006c86:	f7ff fc03 	bl	8006490 <_dbg_check_lock_from_isr>
}
 8006c8a:	bd08      	pop	{r3, pc}
 8006c8c:	0000      	movs	r0, r0
	...

08006c90 <chSysUnlockFromISR.lto_priv.517>:
static inline void chSysUnlockFromISR(void) {
 8006c90:	b508      	push	{r3, lr}
  _dbg_check_unlock_from_isr();
 8006c92:	f7ff fc15 	bl	80064c0 <_dbg_check_unlock_from_isr>
  port_unlock_from_isr();
 8006c96:	f7ff ff9b 	bl	8006bd0 <port_unlock_from_isr.lto_priv.543>
}
 8006c9a:	bd08      	pop	{r3, pc}
 8006c9c:	0000      	movs	r0, r0
	...

08006ca0 <chVTIsArmedI.lto_priv.508>:
static inline bool chVTIsArmedI(const virtual_timer_t *vtp) {
 8006ca0:	b500      	push	{lr}
 8006ca2:	b083      	sub	sp, #12
 8006ca4:	9001      	str	r0, [sp, #4]
  chDbgCheckClassI();
 8006ca6:	f7ff fc63 	bl	8006570 <chDbgCheckClassI>
  return (bool)(vtp->func != NULL);
 8006caa:	9b01      	ldr	r3, [sp, #4]
 8006cac:	68db      	ldr	r3, [r3, #12]
 8006cae:	2b00      	cmp	r3, #0
 8006cb0:	bf14      	ite	ne
 8006cb2:	2301      	movne	r3, #1
 8006cb4:	2300      	moveq	r3, #0
 8006cb6:	b2db      	uxtb	r3, r3
}
 8006cb8:	4618      	mov	r0, r3
 8006cba:	b003      	add	sp, #12
 8006cbc:	f85d fb04 	ldr.w	pc, [sp], #4

08006cc0 <chSemFastSignalI>:
 *
 * @param[in] sp        pointer to a @p semaphore_t structure
 *
 * @iclass
 */
static inline void chSemFastSignalI(semaphore_t *sp) {
 8006cc0:	b500      	push	{lr}
 8006cc2:	b083      	sub	sp, #12
 8006cc4:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();
 8006cc6:	f7ff fc53 	bl	8006570 <chDbgCheckClassI>

  sp->cnt++;
 8006cca:	9b01      	ldr	r3, [sp, #4]
 8006ccc:	689b      	ldr	r3, [r3, #8]
 8006cce:	1c5a      	adds	r2, r3, #1
 8006cd0:	9b01      	ldr	r3, [sp, #4]
 8006cd2:	609a      	str	r2, [r3, #8]
}
 8006cd4:	b003      	add	sp, #12
 8006cd6:	f85d fb04 	ldr.w	pc, [sp], #4
 8006cda:	bf00      	nop
 8006cdc:	0000      	movs	r0, r0
	...

08006ce0 <_scheduler_init>:
/**
 * @brief   Scheduler initialization.
 *
 * @notapi
 */
void _scheduler_init(void) {
 8006ce0:	b508      	push	{r3, lr}

  queue_init(&ch.rlist.queue);
 8006ce2:	4806      	ldr	r0, [pc, #24]	; (8006cfc <_scheduler_init+0x1c>)
 8006ce4:	f7ff ff7c 	bl	8006be0 <queue_init.lto_priv.592>
  ch.rlist.prio = NOPRIO;
 8006ce8:	4b04      	ldr	r3, [pc, #16]	; (8006cfc <_scheduler_init+0x1c>)
 8006cea:	2200      	movs	r2, #0
 8006cec:	609a      	str	r2, [r3, #8]
#if CH_CFG_USE_REGISTRY == TRUE
  ch.rlist.newer = (thread_t *)&ch.rlist;
 8006cee:	4b03      	ldr	r3, [pc, #12]	; (8006cfc <_scheduler_init+0x1c>)
 8006cf0:	4a02      	ldr	r2, [pc, #8]	; (8006cfc <_scheduler_init+0x1c>)
 8006cf2:	611a      	str	r2, [r3, #16]
  ch.rlist.older = (thread_t *)&ch.rlist;
 8006cf4:	4b01      	ldr	r3, [pc, #4]	; (8006cfc <_scheduler_init+0x1c>)
 8006cf6:	4a01      	ldr	r2, [pc, #4]	; (8006cfc <_scheduler_init+0x1c>)
 8006cf8:	615a      	str	r2, [r3, #20]
#endif
}
 8006cfa:	bd08      	pop	{r3, pc}
 8006cfc:	20000b38 	.word	0x20000b38

08006d00 <chSchReadyI>:
 * @param[in] tp        the thread to be made ready
 * @return              The thread pointer.
 *
 * @iclass
 */
thread_t *chSchReadyI(thread_t *tp) {
 8006d00:	b500      	push	{lr}
 8006d02:	b085      	sub	sp, #20
 8006d04:	9001      	str	r0, [sp, #4]
  thread_t *cp;

  chDbgCheckClassI();
 8006d06:	f7ff fc33 	bl	8006570 <chDbgCheckClassI>
  chDbgCheck(tp != NULL);
 8006d0a:	9b01      	ldr	r3, [sp, #4]
 8006d0c:	2b00      	cmp	r3, #0
 8006d0e:	d102      	bne.n	8006d16 <chSchReadyI+0x16>
 8006d10:	4818      	ldr	r0, [pc, #96]	; (8006d74 <chSchReadyI+0x74>)
 8006d12:	f7ff fb0d 	bl	8006330 <chSysHalt>
  chDbgAssert((tp->state != CH_STATE_READY) &&
 8006d16:	9b01      	ldr	r3, [sp, #4]
 8006d18:	f893 3020 	ldrb.w	r3, [r3, #32]
 8006d1c:	2b00      	cmp	r3, #0
 8006d1e:	d004      	beq.n	8006d2a <chSchReadyI+0x2a>
 8006d20:	9b01      	ldr	r3, [sp, #4]
 8006d22:	f893 3020 	ldrb.w	r3, [r3, #32]
 8006d26:	2b0f      	cmp	r3, #15
 8006d28:	d102      	bne.n	8006d30 <chSchReadyI+0x30>
 8006d2a:	4812      	ldr	r0, [pc, #72]	; (8006d74 <chSchReadyI+0x74>)
 8006d2c:	f7ff fb00 	bl	8006330 <chSysHalt>
              (tp->state != CH_STATE_FINAL),
              "invalid state");

  tp->state = CH_STATE_READY;
 8006d30:	9b01      	ldr	r3, [sp, #4]
 8006d32:	2200      	movs	r2, #0
 8006d34:	f883 2020 	strb.w	r2, [r3, #32]
  cp = (thread_t *)&ch.rlist.queue;
 8006d38:	4b0f      	ldr	r3, [pc, #60]	; (8006d78 <chSchReadyI+0x78>)
 8006d3a:	9303      	str	r3, [sp, #12]
  do {
    cp = cp->queue.next;
 8006d3c:	9b03      	ldr	r3, [sp, #12]
 8006d3e:	681b      	ldr	r3, [r3, #0]
 8006d40:	9303      	str	r3, [sp, #12]
  } while (cp->prio >= tp->prio);
 8006d42:	9b03      	ldr	r3, [sp, #12]
 8006d44:	689a      	ldr	r2, [r3, #8]
 8006d46:	9b01      	ldr	r3, [sp, #4]
 8006d48:	689b      	ldr	r3, [r3, #8]
 8006d4a:	429a      	cmp	r2, r3
 8006d4c:	d2f6      	bcs.n	8006d3c <chSchReadyI+0x3c>
  /* Insertion on prev.*/
  tp->queue.next             = cp;
 8006d4e:	9b01      	ldr	r3, [sp, #4]
 8006d50:	9a03      	ldr	r2, [sp, #12]
 8006d52:	601a      	str	r2, [r3, #0]
  tp->queue.prev             = cp->queue.prev;
 8006d54:	9b03      	ldr	r3, [sp, #12]
 8006d56:	685a      	ldr	r2, [r3, #4]
 8006d58:	9b01      	ldr	r3, [sp, #4]
 8006d5a:	605a      	str	r2, [r3, #4]
  tp->queue.prev->queue.next = tp;
 8006d5c:	9b01      	ldr	r3, [sp, #4]
 8006d5e:	685b      	ldr	r3, [r3, #4]
 8006d60:	9a01      	ldr	r2, [sp, #4]
 8006d62:	601a      	str	r2, [r3, #0]
  cp->queue.prev             = tp;
 8006d64:	9b03      	ldr	r3, [sp, #12]
 8006d66:	9a01      	ldr	r2, [sp, #4]
 8006d68:	605a      	str	r2, [r3, #4]

  return tp;
 8006d6a:	9b01      	ldr	r3, [sp, #4]
}
 8006d6c:	4618      	mov	r0, r3
 8006d6e:	b005      	add	sp, #20
 8006d70:	f85d fb04 	ldr.w	pc, [sp], #4
 8006d74:	0800964c 	.word	0x0800964c
 8006d78:	20000b38 	.word	0x20000b38
 8006d7c:	00000000 	.word	0x00000000

08006d80 <chSchReadyAheadI>:
 * @param[in] tp        the thread to be made ready
 * @return              The thread pointer.
 *
 * @iclass
 */
thread_t *chSchReadyAheadI(thread_t *tp) {
 8006d80:	b500      	push	{lr}
 8006d82:	b085      	sub	sp, #20
 8006d84:	9001      	str	r0, [sp, #4]
  thread_t *cp;

  chDbgCheckClassI();
 8006d86:	f7ff fbf3 	bl	8006570 <chDbgCheckClassI>
  chDbgCheck(tp != NULL);
 8006d8a:	9b01      	ldr	r3, [sp, #4]
 8006d8c:	2b00      	cmp	r3, #0
 8006d8e:	d102      	bne.n	8006d96 <chSchReadyAheadI+0x16>
 8006d90:	4818      	ldr	r0, [pc, #96]	; (8006df4 <chSchReadyAheadI+0x74>)
 8006d92:	f7ff facd 	bl	8006330 <chSysHalt>
  chDbgAssert((tp->state != CH_STATE_READY) &&
 8006d96:	9b01      	ldr	r3, [sp, #4]
 8006d98:	f893 3020 	ldrb.w	r3, [r3, #32]
 8006d9c:	2b00      	cmp	r3, #0
 8006d9e:	d004      	beq.n	8006daa <chSchReadyAheadI+0x2a>
 8006da0:	9b01      	ldr	r3, [sp, #4]
 8006da2:	f893 3020 	ldrb.w	r3, [r3, #32]
 8006da6:	2b0f      	cmp	r3, #15
 8006da8:	d102      	bne.n	8006db0 <chSchReadyAheadI+0x30>
 8006daa:	4812      	ldr	r0, [pc, #72]	; (8006df4 <chSchReadyAheadI+0x74>)
 8006dac:	f7ff fac0 	bl	8006330 <chSysHalt>
              (tp->state != CH_STATE_FINAL),
              "invalid state");

  tp->state = CH_STATE_READY;
 8006db0:	9b01      	ldr	r3, [sp, #4]
 8006db2:	2200      	movs	r2, #0
 8006db4:	f883 2020 	strb.w	r2, [r3, #32]
  cp = (thread_t *)&ch.rlist.queue;
 8006db8:	4b0f      	ldr	r3, [pc, #60]	; (8006df8 <chSchReadyAheadI+0x78>)
 8006dba:	9303      	str	r3, [sp, #12]
  do {
    cp = cp->queue.next;
 8006dbc:	9b03      	ldr	r3, [sp, #12]
 8006dbe:	681b      	ldr	r3, [r3, #0]
 8006dc0:	9303      	str	r3, [sp, #12]
  } while (cp->prio > tp->prio);
 8006dc2:	9b03      	ldr	r3, [sp, #12]
 8006dc4:	689a      	ldr	r2, [r3, #8]
 8006dc6:	9b01      	ldr	r3, [sp, #4]
 8006dc8:	689b      	ldr	r3, [r3, #8]
 8006dca:	429a      	cmp	r2, r3
 8006dcc:	d8f6      	bhi.n	8006dbc <chSchReadyAheadI+0x3c>
  /* Insertion on prev.*/
  tp->queue.next             = cp;
 8006dce:	9b01      	ldr	r3, [sp, #4]
 8006dd0:	9a03      	ldr	r2, [sp, #12]
 8006dd2:	601a      	str	r2, [r3, #0]
  tp->queue.prev             = cp->queue.prev;
 8006dd4:	9b03      	ldr	r3, [sp, #12]
 8006dd6:	685a      	ldr	r2, [r3, #4]
 8006dd8:	9b01      	ldr	r3, [sp, #4]
 8006dda:	605a      	str	r2, [r3, #4]
  tp->queue.prev->queue.next = tp;
 8006ddc:	9b01      	ldr	r3, [sp, #4]
 8006dde:	685b      	ldr	r3, [r3, #4]
 8006de0:	9a01      	ldr	r2, [sp, #4]
 8006de2:	601a      	str	r2, [r3, #0]
  cp->queue.prev             = tp;
 8006de4:	9b03      	ldr	r3, [sp, #12]
 8006de6:	9a01      	ldr	r2, [sp, #4]
 8006de8:	605a      	str	r2, [r3, #4]

  return tp;
 8006dea:	9b01      	ldr	r3, [sp, #4]
}
 8006dec:	4618      	mov	r0, r3
 8006dee:	b005      	add	sp, #20
 8006df0:	f85d fb04 	ldr.w	pc, [sp], #4
 8006df4:	08009658 	.word	0x08009658
 8006df8:	20000b38 	.word	0x20000b38
 8006dfc:	00000000 	.word	0x00000000

08006e00 <chSchGoSleepS>:
 *
 * @param[in] newstate  the new thread state
 *
 * @sclass
 */
void chSchGoSleepS(tstate_t newstate) {
 8006e00:	b500      	push	{lr}
 8006e02:	b087      	sub	sp, #28
 8006e04:	4603      	mov	r3, r0
 8006e06:	f88d 3007 	strb.w	r3, [sp, #7]
  thread_t *otp = currp;
 8006e0a:	4b19      	ldr	r3, [pc, #100]	; (8006e70 <chSchGoSleepS+0x70>)
 8006e0c:	699b      	ldr	r3, [r3, #24]
 8006e0e:	9305      	str	r3, [sp, #20]

  chDbgCheckClassS();
 8006e10:	f7ff fbc6 	bl	80065a0 <chDbgCheckClassS>

  /* New state.*/
  otp->state = newstate;
 8006e14:	9b05      	ldr	r3, [sp, #20]
 8006e16:	f89d 2007 	ldrb.w	r2, [sp, #7]
 8006e1a:	f883 2020 	strb.w	r2, [r3, #32]
     time quantum when it will wakeup.*/
  otp->ticks = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif

  /* Next thread in ready list becomes current.*/
  currp = queue_fifo_remove(&ch.rlist.queue);
 8006e1e:	4814      	ldr	r0, [pc, #80]	; (8006e70 <chSchGoSleepS+0x70>)
 8006e20:	f7ff feee 	bl	8006c00 <queue_fifo_remove.lto_priv.598>
 8006e24:	4602      	mov	r2, r0
 8006e26:	4b12      	ldr	r3, [pc, #72]	; (8006e70 <chSchGoSleepS+0x70>)
 8006e28:	619a      	str	r2, [r3, #24]
  currp->state = CH_STATE_CURRENT;
 8006e2a:	4b11      	ldr	r3, [pc, #68]	; (8006e70 <chSchGoSleepS+0x70>)
 8006e2c:	699b      	ldr	r3, [r3, #24]
 8006e2e:	2201      	movs	r2, #1
 8006e30:	f883 2020 	strb.w	r2, [r3, #32]
  if (currp->prio == IDLEPRIO) {
    CH_CFG_IDLE_ENTER_HOOK();
  }

  /* Swap operation as tail call.*/
  chSysSwitch(currp, otp);
 8006e34:	4b0e      	ldr	r3, [pc, #56]	; (8006e70 <chSchGoSleepS+0x70>)
 8006e36:	699b      	ldr	r3, [r3, #24]
 8006e38:	9905      	ldr	r1, [sp, #20]
 8006e3a:	4618      	mov	r0, r3
 8006e3c:	f7ff fc58 	bl	80066f0 <_trace_switch>
  __ASM volatile ("MRS %0, psp"  : "=r" (result) );
 8006e40:	f3ef 8309 	mrs	r3, PSP
 8006e44:	9303      	str	r3, [sp, #12]
  return(result);
 8006e46:	9b03      	ldr	r3, [sp, #12]
 8006e48:	9304      	str	r3, [sp, #16]
 8006e4a:	9b04      	ldr	r3, [sp, #16]
 8006e4c:	f1a3 0224 	sub.w	r2, r3, #36	; 0x24
 8006e50:	9b05      	ldr	r3, [sp, #20]
 8006e52:	69db      	ldr	r3, [r3, #28]
 8006e54:	429a      	cmp	r2, r3
 8006e56:	d202      	bcs.n	8006e5e <chSchGoSleepS+0x5e>
 8006e58:	4806      	ldr	r0, [pc, #24]	; (8006e74 <chSchGoSleepS+0x74>)
 8006e5a:	f7ff fa69 	bl	8006330 <chSysHalt>
 8006e5e:	4b04      	ldr	r3, [pc, #16]	; (8006e70 <chSchGoSleepS+0x70>)
 8006e60:	699b      	ldr	r3, [r3, #24]
 8006e62:	9905      	ldr	r1, [sp, #20]
 8006e64:	4618      	mov	r0, r3
 8006e66:	f7f9 fa33 	bl	80002d0 <_port_switch>
}
 8006e6a:	b007      	add	sp, #28
 8006e6c:	f85d fb04 	ldr.w	pc, [sp], #4
 8006e70:	20000b38 	.word	0x20000b38
 8006e74:	080099c0 	.word	0x080099c0
	...

08006e80 <wakeup>:

/*
 * Timeout wakeup callback.
 */
static void wakeup(void *p) {
 8006e80:	b500      	push	{lr}
 8006e82:	b085      	sub	sp, #20
 8006e84:	9001      	str	r0, [sp, #4]
  thread_t *tp = (thread_t *)p;
 8006e86:	9b01      	ldr	r3, [sp, #4]
 8006e88:	9303      	str	r3, [sp, #12]

  chSysLockFromISR();
 8006e8a:	f7ff fef9 	bl	8006c80 <chSysLockFromISR.lto_priv.526>
  switch (tp->state) {
 8006e8e:	9b03      	ldr	r3, [sp, #12]
 8006e90:	f893 3020 	ldrb.w	r3, [r3, #32]
 8006e94:	2b07      	cmp	r3, #7
 8006e96:	d823      	bhi.n	8006ee0 <wakeup+0x60>
 8006e98:	a201      	add	r2, pc, #4	; (adr r2, 8006ea0 <wakeup+0x20>)
 8006e9a:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8006e9e:	bf00      	nop
 8006ea0:	08006ec1 	.word	0x08006ec1
 8006ea4:	08006ee1 	.word	0x08006ee1
 8006ea8:	08006ee1 	.word	0x08006ee1
 8006eac:	08006ec7 	.word	0x08006ec7
 8006eb0:	08006edb 	.word	0x08006edb
 8006eb4:	08006ed1 	.word	0x08006ed1
 8006eb8:	08006ee1 	.word	0x08006ee1
 8006ebc:	08006edb 	.word	0x08006edb
  case CH_STATE_READY:
    /* Handling the special case where the thread has been made ready by
       another thread with higher priority.*/
    chSysUnlockFromISR();
 8006ec0:	f7ff fee6 	bl	8006c90 <chSysUnlockFromISR.lto_priv.517>
 8006ec4:	e015      	b.n	8006ef2 <wakeup+0x72>
    return;
  case CH_STATE_SUSPENDED:
    *tp->u.wttrp = NULL;
 8006ec6:	9b03      	ldr	r3, [sp, #12]
 8006ec8:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8006eca:	2200      	movs	r2, #0
 8006ecc:	601a      	str	r2, [r3, #0]
 8006ece:	e007      	b.n	8006ee0 <wakeup+0x60>
    break;
#if CH_CFG_USE_SEMAPHORES == TRUE
  case CH_STATE_WTSEM:
    chSemFastSignalI(tp->u.wtsemp);
 8006ed0:	9b03      	ldr	r3, [sp, #12]
 8006ed2:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8006ed4:	4618      	mov	r0, r3
 8006ed6:	f7ff fef3 	bl	8006cc0 <chSemFastSignalI>
    /* Falls through.*/
#if (CH_CFG_USE_CONDVARS == TRUE) && (CH_CFG_USE_CONDVARS_TIMEOUT == TRUE)
  case CH_STATE_WTCOND:
#endif
    /* States requiring dequeuing.*/
    (void) queue_dequeue(tp);
 8006eda:	9803      	ldr	r0, [sp, #12]
 8006edc:	f7ff fea8 	bl	8006c30 <queue_dequeue.lto_priv.619>
    break;
  default:
    /* Any other state, nothing to do.*/
    break;
  }
  tp->u.rdymsg = MSG_TIMEOUT;
 8006ee0:	9b03      	ldr	r3, [sp, #12]
 8006ee2:	f04f 32ff 	mov.w	r2, #4294967295
 8006ee6:	625a      	str	r2, [r3, #36]	; 0x24
  (void) chSchReadyI(tp);
 8006ee8:	9803      	ldr	r0, [sp, #12]
 8006eea:	f7ff ff09 	bl	8006d00 <chSchReadyI>
  chSysUnlockFromISR();
 8006eee:	f7ff fecf 	bl	8006c90 <chSysUnlockFromISR.lto_priv.517>
}
 8006ef2:	b005      	add	sp, #20
 8006ef4:	f85d fb04 	ldr.w	pc, [sp], #4
	...

08006f00 <chSchGoSleepTimeoutS>:
 * @return              The wakeup message.
 * @retval MSG_TIMEOUT  if a timeout occurs.
 *
 * @sclass
 */
msg_t chSchGoSleepTimeoutS(tstate_t newstate, sysinterval_t timeout) {
 8006f00:	b500      	push	{lr}
 8006f02:	b089      	sub	sp, #36	; 0x24
 8006f04:	4603      	mov	r3, r0
 8006f06:	9100      	str	r1, [sp, #0]
 8006f08:	f88d 3007 	strb.w	r3, [sp, #7]

  chDbgCheckClassS();
 8006f0c:	f7ff fb48 	bl	80065a0 <chDbgCheckClassS>

  if (TIME_INFINITE != timeout) {
 8006f10:	9b00      	ldr	r3, [sp, #0]
 8006f12:	f1b3 3fff 	cmp.w	r3, #4294967295
 8006f16:	d017      	beq.n	8006f48 <chSchGoSleepTimeoutS+0x48>
    virtual_timer_t vt;

    chVTDoSetI(&vt, timeout, wakeup, currp);
 8006f18:	4b11      	ldr	r3, [pc, #68]	; (8006f60 <chSchGoSleepTimeoutS+0x60>)
 8006f1a:	699b      	ldr	r3, [r3, #24]
 8006f1c:	a803      	add	r0, sp, #12
 8006f1e:	4a11      	ldr	r2, [pc, #68]	; (8006f64 <chSchGoSleepTimeoutS+0x64>)
 8006f20:	9900      	ldr	r1, [sp, #0]
 8006f22:	f7ff fd05 	bl	8006930 <chVTDoSetI>
    chSchGoSleepS(newstate);
 8006f26:	f89d 3007 	ldrb.w	r3, [sp, #7]
 8006f2a:	4618      	mov	r0, r3
 8006f2c:	f7ff ff68 	bl	8006e00 <chSchGoSleepS>
    if (chVTIsArmedI(&vt)) {
 8006f30:	ab03      	add	r3, sp, #12
 8006f32:	4618      	mov	r0, r3
 8006f34:	f7ff feb4 	bl	8006ca0 <chVTIsArmedI.lto_priv.508>
 8006f38:	4603      	mov	r3, r0
 8006f3a:	2b00      	cmp	r3, #0
 8006f3c:	d009      	beq.n	8006f52 <chSchGoSleepTimeoutS+0x52>
      chVTDoResetI(&vt);
 8006f3e:	ab03      	add	r3, sp, #12
 8006f40:	4618      	mov	r0, r3
 8006f42:	f7ff fda5 	bl	8006a90 <chVTDoResetI>
 8006f46:	e004      	b.n	8006f52 <chSchGoSleepTimeoutS+0x52>
    }
  }
  else {
    chSchGoSleepS(newstate);
 8006f48:	f89d 3007 	ldrb.w	r3, [sp, #7]
 8006f4c:	4618      	mov	r0, r3
 8006f4e:	f7ff ff57 	bl	8006e00 <chSchGoSleepS>
  }

  return currp->u.rdymsg;
 8006f52:	4b03      	ldr	r3, [pc, #12]	; (8006f60 <chSchGoSleepTimeoutS+0x60>)
 8006f54:	699b      	ldr	r3, [r3, #24]
 8006f56:	6a5b      	ldr	r3, [r3, #36]	; 0x24
}
 8006f58:	4618      	mov	r0, r3
 8006f5a:	b009      	add	sp, #36	; 0x24
 8006f5c:	f85d fb04 	ldr.w	pc, [sp], #4
 8006f60:	20000b38 	.word	0x20000b38
 8006f64:	08006e81 	.word	0x08006e81
	...

08006f70 <chSchWakeupS>:
 * @param[in] ntp       the thread to be made ready
 * @param[in] msg       the wakeup message
 *
 * @sclass
 */
void chSchWakeupS(thread_t *ntp, msg_t msg) {
 8006f70:	b500      	push	{lr}
 8006f72:	b087      	sub	sp, #28
 8006f74:	9001      	str	r0, [sp, #4]
 8006f76:	9100      	str	r1, [sp, #0]
  thread_t *otp = currp;
 8006f78:	4b23      	ldr	r3, [pc, #140]	; (8007008 <chSchWakeupS+0x98>)
 8006f7a:	699b      	ldr	r3, [r3, #24]
 8006f7c:	9305      	str	r3, [sp, #20]

  chDbgCheckClassS();
 8006f7e:	f7ff fb0f 	bl	80065a0 <chDbgCheckClassS>

  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8006f82:	4b21      	ldr	r3, [pc, #132]	; (8007008 <chSchWakeupS+0x98>)
 8006f84:	681b      	ldr	r3, [r3, #0]
 8006f86:	4a20      	ldr	r2, [pc, #128]	; (8007008 <chSchWakeupS+0x98>)
 8006f88:	4293      	cmp	r3, r2
 8006f8a:	d00a      	beq.n	8006fa2 <chSchWakeupS+0x32>
 8006f8c:	4b1e      	ldr	r3, [pc, #120]	; (8007008 <chSchWakeupS+0x98>)
 8006f8e:	699b      	ldr	r3, [r3, #24]
 8006f90:	689a      	ldr	r2, [r3, #8]
 8006f92:	4b1d      	ldr	r3, [pc, #116]	; (8007008 <chSchWakeupS+0x98>)
 8006f94:	681b      	ldr	r3, [r3, #0]
 8006f96:	689b      	ldr	r3, [r3, #8]
 8006f98:	429a      	cmp	r2, r3
 8006f9a:	d202      	bcs.n	8006fa2 <chSchWakeupS+0x32>
 8006f9c:	481b      	ldr	r0, [pc, #108]	; (800700c <chSchWakeupS+0x9c>)
 8006f9e:	f7ff f9c7 	bl	8006330 <chSysHalt>
              (ch.rlist.current->prio >= ch.rlist.queue.next->prio),
              "priority order violation");

  /* Storing the message to be retrieved by the target thread when it will
     restart execution.*/
  ntp->u.rdymsg = msg;
 8006fa2:	9b01      	ldr	r3, [sp, #4]
 8006fa4:	9a00      	ldr	r2, [sp, #0]
 8006fa6:	625a      	str	r2, [r3, #36]	; 0x24

  /* If the waken thread has a not-greater priority than the current
     one then it is just inserted in the ready list else it made
     running immediately and the invoking thread goes in the ready
     list instead.*/
  if (ntp->prio <= otp->prio) {
 8006fa8:	9b01      	ldr	r3, [sp, #4]
 8006faa:	689a      	ldr	r2, [r3, #8]
 8006fac:	9b05      	ldr	r3, [sp, #20]
 8006fae:	689b      	ldr	r3, [r3, #8]
 8006fb0:	429a      	cmp	r2, r3
 8006fb2:	d803      	bhi.n	8006fbc <chSchWakeupS+0x4c>
    (void) chSchReadyI(ntp);
 8006fb4:	9801      	ldr	r0, [sp, #4]
 8006fb6:	f7ff fea3 	bl	8006d00 <chSchReadyI>
 8006fba:	e021      	b.n	8007000 <chSchWakeupS+0x90>
  }
  else {
    otp = chSchReadyI(otp);
 8006fbc:	9805      	ldr	r0, [sp, #20]
 8006fbe:	f7ff fe9f 	bl	8006d00 <chSchReadyI>
 8006fc2:	9005      	str	r0, [sp, #20]
    if (otp->prio == IDLEPRIO) {
      CH_CFG_IDLE_LEAVE_HOOK();
    }

    /* The extracted thread is marked as current.*/
    currp = ntp;
 8006fc4:	4a10      	ldr	r2, [pc, #64]	; (8007008 <chSchWakeupS+0x98>)
 8006fc6:	9b01      	ldr	r3, [sp, #4]
 8006fc8:	6193      	str	r3, [r2, #24]
    ntp->state = CH_STATE_CURRENT;
 8006fca:	9b01      	ldr	r3, [sp, #4]
 8006fcc:	2201      	movs	r2, #1
 8006fce:	f883 2020 	strb.w	r2, [r3, #32]

    /* Swap operation as tail call.*/
    chSysSwitch(ntp, otp);
 8006fd2:	9905      	ldr	r1, [sp, #20]
 8006fd4:	9801      	ldr	r0, [sp, #4]
 8006fd6:	f7ff fb8b 	bl	80066f0 <_trace_switch>
  __ASM volatile ("MRS %0, psp"  : "=r" (result) );
 8006fda:	f3ef 8309 	mrs	r3, PSP
 8006fde:	9303      	str	r3, [sp, #12]
  return(result);
 8006fe0:	9b03      	ldr	r3, [sp, #12]
 8006fe2:	9304      	str	r3, [sp, #16]
 8006fe4:	9b04      	ldr	r3, [sp, #16]
 8006fe6:	f1a3 0224 	sub.w	r2, r3, #36	; 0x24
 8006fea:	9b05      	ldr	r3, [sp, #20]
 8006fec:	69db      	ldr	r3, [r3, #28]
 8006fee:	429a      	cmp	r2, r3
 8006ff0:	d202      	bcs.n	8006ff8 <chSchWakeupS+0x88>
 8006ff2:	4807      	ldr	r0, [pc, #28]	; (8007010 <chSchWakeupS+0xa0>)
 8006ff4:	f7ff f99c 	bl	8006330 <chSysHalt>
 8006ff8:	9905      	ldr	r1, [sp, #20]
 8006ffa:	9801      	ldr	r0, [sp, #4]
 8006ffc:	f7f9 f968 	bl	80002d0 <_port_switch>
  }
}
 8007000:	b007      	add	sp, #28
 8007002:	f85d fb04 	ldr.w	pc, [sp], #4
 8007006:	bf00      	nop
 8007008:	20000b38 	.word	0x20000b38
 800700c:	0800966c 	.word	0x0800966c
 8007010:	080099c0 	.word	0x080099c0
	...

08007020 <chSchRescheduleS>:
 * @details If a thread with a higher priority than the current thread is in
 *          the ready list then make the higher priority thread running.
 *
 * @sclass
 */
void chSchRescheduleS(void) {
 8007020:	b508      	push	{r3, lr}

  chDbgCheckClassS();
 8007022:	f7ff fabd 	bl	80065a0 <chDbgCheckClassS>

  if (chSchIsRescRequiredI()) {
 8007026:	f7ff fe13 	bl	8006c50 <chSchIsRescRequiredI>
 800702a:	4603      	mov	r3, r0
 800702c:	2b00      	cmp	r3, #0
 800702e:	d001      	beq.n	8007034 <chSchRescheduleS+0x14>
    chSchDoRescheduleAhead();
 8007030:	f000 f81e 	bl	8007070 <chSchDoRescheduleAhead>
  }
}
 8007034:	bd08      	pop	{r3, pc}
 8007036:	bf00      	nop
	...

08007040 <chSchIsPreemptionRequired>:
 *                      immediately.
 * @retval false        if preemption is not required.
 *
 * @special
 */
bool chSchIsPreemptionRequired(void) {
 8007040:	b082      	sub	sp, #8
  tprio_t p1 = firstprio(&ch.rlist.queue);
 8007042:	4b09      	ldr	r3, [pc, #36]	; (8007068 <chSchIsPreemptionRequired+0x28>)
 8007044:	681b      	ldr	r3, [r3, #0]
 8007046:	689b      	ldr	r3, [r3, #8]
 8007048:	9301      	str	r3, [sp, #4]
  tprio_t p2 = currp->prio;
 800704a:	4b07      	ldr	r3, [pc, #28]	; (8007068 <chSchIsPreemptionRequired+0x28>)
 800704c:	699b      	ldr	r3, [r3, #24]
 800704e:	689b      	ldr	r3, [r3, #8]
 8007050:	9300      	str	r3, [sp, #0]
     if the first thread on the ready queue has equal or higher priority.*/
  return (currp->ticks > (tslices_t)0) ? (p1 > p2) : (p1 >= p2);
#else
  /* If the round robin preemption feature is not enabled then performs a
     simpler comparison.*/
  return p1 > p2;
 8007052:	9a01      	ldr	r2, [sp, #4]
 8007054:	9b00      	ldr	r3, [sp, #0]
 8007056:	429a      	cmp	r2, r3
 8007058:	bf8c      	ite	hi
 800705a:	2301      	movhi	r3, #1
 800705c:	2300      	movls	r3, #0
 800705e:	b2db      	uxtb	r3, r3
#endif
}
 8007060:	4618      	mov	r0, r3
 8007062:	b002      	add	sp, #8
 8007064:	4770      	bx	lr
 8007066:	bf00      	nop
 8007068:	20000b38 	.word	0x20000b38
 800706c:	00000000 	.word	0x00000000

08007070 <chSchDoRescheduleAhead>:
 * @note    Not a user function, it is meant to be invoked by the scheduler
 *          itself.
 *
 * @special
 */
void chSchDoRescheduleAhead(void) {
 8007070:	b500      	push	{lr}
 8007072:	b085      	sub	sp, #20
  thread_t *otp = currp;
 8007074:	4b17      	ldr	r3, [pc, #92]	; (80070d4 <chSchDoRescheduleAhead+0x64>)
 8007076:	699b      	ldr	r3, [r3, #24]
 8007078:	9303      	str	r3, [sp, #12]

  /* Picks the first thread from the ready queue and makes it current.*/
  currp = queue_fifo_remove(&ch.rlist.queue);
 800707a:	4816      	ldr	r0, [pc, #88]	; (80070d4 <chSchDoRescheduleAhead+0x64>)
 800707c:	f7ff fdc0 	bl	8006c00 <queue_fifo_remove.lto_priv.598>
 8007080:	4602      	mov	r2, r0
 8007082:	4b14      	ldr	r3, [pc, #80]	; (80070d4 <chSchDoRescheduleAhead+0x64>)
 8007084:	619a      	str	r2, [r3, #24]
  currp->state = CH_STATE_CURRENT;
 8007086:	4b13      	ldr	r3, [pc, #76]	; (80070d4 <chSchDoRescheduleAhead+0x64>)
 8007088:	699b      	ldr	r3, [r3, #24]
 800708a:	2201      	movs	r2, #1
 800708c:	f883 2020 	strb.w	r2, [r3, #32]
  if (otp->prio == IDLEPRIO) {
    CH_CFG_IDLE_LEAVE_HOOK();
  }

  /* Placing in ready list ahead of peers.*/
  otp = chSchReadyAheadI(otp);
 8007090:	9803      	ldr	r0, [sp, #12]
 8007092:	f7ff fe75 	bl	8006d80 <chSchReadyAheadI>
 8007096:	9003      	str	r0, [sp, #12]

  /* Swap operation as tail call.*/
  chSysSwitch(currp, otp);
 8007098:	4b0e      	ldr	r3, [pc, #56]	; (80070d4 <chSchDoRescheduleAhead+0x64>)
 800709a:	699b      	ldr	r3, [r3, #24]
 800709c:	9903      	ldr	r1, [sp, #12]
 800709e:	4618      	mov	r0, r3
 80070a0:	f7ff fb26 	bl	80066f0 <_trace_switch>
  __ASM volatile ("MRS %0, psp"  : "=r" (result) );
 80070a4:	f3ef 8309 	mrs	r3, PSP
 80070a8:	9301      	str	r3, [sp, #4]
  return(result);
 80070aa:	9b01      	ldr	r3, [sp, #4]
 80070ac:	9302      	str	r3, [sp, #8]
 80070ae:	9b02      	ldr	r3, [sp, #8]
 80070b0:	f1a3 0224 	sub.w	r2, r3, #36	; 0x24
 80070b4:	9b03      	ldr	r3, [sp, #12]
 80070b6:	69db      	ldr	r3, [r3, #28]
 80070b8:	429a      	cmp	r2, r3
 80070ba:	d202      	bcs.n	80070c2 <chSchDoRescheduleAhead+0x52>
 80070bc:	4806      	ldr	r0, [pc, #24]	; (80070d8 <chSchDoRescheduleAhead+0x68>)
 80070be:	f7ff f937 	bl	8006330 <chSysHalt>
 80070c2:	4b04      	ldr	r3, [pc, #16]	; (80070d4 <chSchDoRescheduleAhead+0x64>)
 80070c4:	699b      	ldr	r3, [r3, #24]
 80070c6:	9903      	ldr	r1, [sp, #12]
 80070c8:	4618      	mov	r0, r3
 80070ca:	f7f9 f901 	bl	80002d0 <_port_switch>
}
 80070ce:	b005      	add	sp, #20
 80070d0:	f85d fb04 	ldr.w	pc, [sp], #4
 80070d4:	20000b38 	.word	0x20000b38
 80070d8:	080099c0 	.word	0x080099c0
 80070dc:	00000000 	.word	0x00000000

080070e0 <chSchDoReschedule>:
 * @note    Not a user function, it is meant to be invoked by the scheduler
 *          itself or from within the port layer.
 *
 * @special
 */
void chSchDoReschedule(void) {
 80070e0:	b500      	push	{lr}
 80070e2:	b085      	sub	sp, #20
  thread_t *otp = currp;
 80070e4:	4b17      	ldr	r3, [pc, #92]	; (8007144 <chSchDoReschedule+0x64>)
 80070e6:	699b      	ldr	r3, [r3, #24]
 80070e8:	9303      	str	r3, [sp, #12]

  /* Picks the first thread from the ready queue and makes it current.*/
  currp = queue_fifo_remove(&ch.rlist.queue);
 80070ea:	4816      	ldr	r0, [pc, #88]	; (8007144 <chSchDoReschedule+0x64>)
 80070ec:	f7ff fd88 	bl	8006c00 <queue_fifo_remove.lto_priv.598>
 80070f0:	4602      	mov	r2, r0
 80070f2:	4b14      	ldr	r3, [pc, #80]	; (8007144 <chSchDoReschedule+0x64>)
 80070f4:	619a      	str	r2, [r3, #24]
  currp->state = CH_STATE_CURRENT;
 80070f6:	4b13      	ldr	r3, [pc, #76]	; (8007144 <chSchDoReschedule+0x64>)
 80070f8:	699b      	ldr	r3, [r3, #24]
 80070fa:	2201      	movs	r2, #1
 80070fc:	f883 2020 	strb.w	r2, [r3, #32]
    otp = chSchReadyAheadI(otp);
  }
#else /* !(CH_CFG_TIME_QUANTUM > 0) */
  /* If the round-robin mechanism is disabled then the thread goes always
     ahead of its peers.*/
  otp = chSchReadyAheadI(otp);
 8007100:	9803      	ldr	r0, [sp, #12]
 8007102:	f7ff fe3d 	bl	8006d80 <chSchReadyAheadI>
 8007106:	9003      	str	r0, [sp, #12]
#endif /* !(CH_CFG_TIME_QUANTUM > 0) */

  /* Swap operation as tail call.*/
  chSysSwitch(currp, otp);
 8007108:	4b0e      	ldr	r3, [pc, #56]	; (8007144 <chSchDoReschedule+0x64>)
 800710a:	699b      	ldr	r3, [r3, #24]
 800710c:	9903      	ldr	r1, [sp, #12]
 800710e:	4618      	mov	r0, r3
 8007110:	f7ff faee 	bl	80066f0 <_trace_switch>
  __ASM volatile ("MRS %0, psp"  : "=r" (result) );
 8007114:	f3ef 8309 	mrs	r3, PSP
 8007118:	9301      	str	r3, [sp, #4]
  return(result);
 800711a:	9b01      	ldr	r3, [sp, #4]
 800711c:	9302      	str	r3, [sp, #8]
 800711e:	9b02      	ldr	r3, [sp, #8]
 8007120:	f1a3 0224 	sub.w	r2, r3, #36	; 0x24
 8007124:	9b03      	ldr	r3, [sp, #12]
 8007126:	69db      	ldr	r3, [r3, #28]
 8007128:	429a      	cmp	r2, r3
 800712a:	d202      	bcs.n	8007132 <chSchDoReschedule+0x52>
 800712c:	4806      	ldr	r0, [pc, #24]	; (8007148 <chSchDoReschedule+0x68>)
 800712e:	f7ff f8ff 	bl	8006330 <chSysHalt>
 8007132:	4b04      	ldr	r3, [pc, #16]	; (8007144 <chSchDoReschedule+0x64>)
 8007134:	699b      	ldr	r3, [r3, #24]
 8007136:	9903      	ldr	r1, [sp, #12]
 8007138:	4618      	mov	r0, r3
 800713a:	f7f9 f8c9 	bl	80002d0 <_port_switch>
}
 800713e:	b005      	add	sp, #20
 8007140:	f85d fb04 	ldr.w	pc, [sp], #4
 8007144:	20000b38 	.word	0x20000b38
 8007148:	080099c0 	.word	0x080099c0
 800714c:	00000000 	.word	0x00000000

08007150 <port_lock.lto_priv.302>:
static inline void port_lock(void) {
 8007150:	b082      	sub	sp, #8
 8007152:	2320      	movs	r3, #32
 8007154:	9301      	str	r3, [sp, #4]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8007156:	9b01      	ldr	r3, [sp, #4]
 8007158:	f383 8811 	msr	BASEPRI, r3
}
 800715c:	b002      	add	sp, #8
 800715e:	4770      	bx	lr

08007160 <port_unlock.lto_priv.261>:
static inline void port_unlock(void) {
 8007160:	b082      	sub	sp, #8
 8007162:	2300      	movs	r3, #0
 8007164:	9301      	str	r3, [sp, #4]
 8007166:	9b01      	ldr	r3, [sp, #4]
 8007168:	f383 8811 	msr	BASEPRI, r3
}
 800716c:	b002      	add	sp, #8
 800716e:	4770      	bx	lr

08007170 <list_init>:
static inline void list_init(threads_list_t *tlp) {
 8007170:	b082      	sub	sp, #8
 8007172:	9001      	str	r0, [sp, #4]
  tlp->next = (thread_t *)tlp;
 8007174:	9b01      	ldr	r3, [sp, #4]
 8007176:	9a01      	ldr	r2, [sp, #4]
 8007178:	601a      	str	r2, [r3, #0]
}
 800717a:	b002      	add	sp, #8
 800717c:	4770      	bx	lr
 800717e:	bf00      	nop

08007180 <list_notempty>:
static inline bool list_notempty(threads_list_t *tlp) {
 8007180:	b082      	sub	sp, #8
 8007182:	9001      	str	r0, [sp, #4]
  return (bool)(tlp->next != (thread_t *)tlp);
 8007184:	9b01      	ldr	r3, [sp, #4]
 8007186:	681b      	ldr	r3, [r3, #0]
 8007188:	9a01      	ldr	r2, [sp, #4]
 800718a:	429a      	cmp	r2, r3
 800718c:	bf14      	ite	ne
 800718e:	2301      	movne	r3, #1
 8007190:	2300      	moveq	r3, #0
 8007192:	b2db      	uxtb	r3, r3
}
 8007194:	4618      	mov	r0, r3
 8007196:	b002      	add	sp, #8
 8007198:	4770      	bx	lr
 800719a:	bf00      	nop
 800719c:	0000      	movs	r0, r0
	...

080071a0 <queue_init.lto_priv.593>:
static inline void queue_init(threads_queue_t *tqp) {
 80071a0:	b082      	sub	sp, #8
 80071a2:	9001      	str	r0, [sp, #4]
  tqp->next = (thread_t *)tqp;
 80071a4:	9b01      	ldr	r3, [sp, #4]
 80071a6:	9a01      	ldr	r2, [sp, #4]
 80071a8:	601a      	str	r2, [r3, #0]
  tqp->prev = (thread_t *)tqp;
 80071aa:	9b01      	ldr	r3, [sp, #4]
 80071ac:	9a01      	ldr	r2, [sp, #4]
 80071ae:	605a      	str	r2, [r3, #4]
}
 80071b0:	b002      	add	sp, #8
 80071b2:	4770      	bx	lr
	...

080071c0 <queue_notempty.lto_priv.613>:
static inline bool queue_notempty(const threads_queue_t *tqp) {
 80071c0:	b082      	sub	sp, #8
 80071c2:	9001      	str	r0, [sp, #4]
  return (bool)(tqp->next != (const thread_t *)tqp);
 80071c4:	9b01      	ldr	r3, [sp, #4]
 80071c6:	681b      	ldr	r3, [r3, #0]
 80071c8:	9a01      	ldr	r2, [sp, #4]
 80071ca:	429a      	cmp	r2, r3
 80071cc:	bf14      	ite	ne
 80071ce:	2301      	movne	r3, #1
 80071d0:	2300      	moveq	r3, #0
 80071d2:	b2db      	uxtb	r3, r3
}
 80071d4:	4618      	mov	r0, r3
 80071d6:	b002      	add	sp, #8
 80071d8:	4770      	bx	lr
 80071da:	bf00      	nop
 80071dc:	0000      	movs	r0, r0
	...

080071e0 <list_remove>:
static inline thread_t *list_remove(threads_list_t *tlp) {
 80071e0:	b084      	sub	sp, #16
 80071e2:	9001      	str	r0, [sp, #4]
  thread_t *tp = tlp->next;
 80071e4:	9b01      	ldr	r3, [sp, #4]
 80071e6:	681b      	ldr	r3, [r3, #0]
 80071e8:	9303      	str	r3, [sp, #12]
  tlp->next = tp->queue.next;
 80071ea:	9b03      	ldr	r3, [sp, #12]
 80071ec:	681a      	ldr	r2, [r3, #0]
 80071ee:	9b01      	ldr	r3, [sp, #4]
 80071f0:	601a      	str	r2, [r3, #0]
  return tp;
 80071f2:	9b03      	ldr	r3, [sp, #12]
}
 80071f4:	4618      	mov	r0, r3
 80071f6:	b004      	add	sp, #16
 80071f8:	4770      	bx	lr
 80071fa:	bf00      	nop
 80071fc:	0000      	movs	r0, r0
	...

08007200 <queue_insert.lto_priv.604>:
static inline void queue_insert(thread_t *tp, threads_queue_t *tqp) {
 8007200:	b082      	sub	sp, #8
 8007202:	9001      	str	r0, [sp, #4]
 8007204:	9100      	str	r1, [sp, #0]
  tp->queue.next             = (thread_t *)tqp;
 8007206:	9b01      	ldr	r3, [sp, #4]
 8007208:	9a00      	ldr	r2, [sp, #0]
 800720a:	601a      	str	r2, [r3, #0]
  tp->queue.prev             = tqp->prev;
 800720c:	9b00      	ldr	r3, [sp, #0]
 800720e:	685a      	ldr	r2, [r3, #4]
 8007210:	9b01      	ldr	r3, [sp, #4]
 8007212:	605a      	str	r2, [r3, #4]
  tp->queue.prev->queue.next = tp;
 8007214:	9b01      	ldr	r3, [sp, #4]
 8007216:	685b      	ldr	r3, [r3, #4]
 8007218:	9a01      	ldr	r2, [sp, #4]
 800721a:	601a      	str	r2, [r3, #0]
  tqp->prev                  = tp;
 800721c:	9b00      	ldr	r3, [sp, #0]
 800721e:	9a01      	ldr	r2, [sp, #4]
 8007220:	605a      	str	r2, [r3, #4]
}
 8007222:	b002      	add	sp, #8
 8007224:	4770      	bx	lr
 8007226:	bf00      	nop
	...

08007230 <queue_fifo_remove.lto_priv.599>:
static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
 8007230:	b084      	sub	sp, #16
 8007232:	9001      	str	r0, [sp, #4]
  thread_t *tp = tqp->next;
 8007234:	9b01      	ldr	r3, [sp, #4]
 8007236:	681b      	ldr	r3, [r3, #0]
 8007238:	9303      	str	r3, [sp, #12]
  tqp->next             = tp->queue.next;
 800723a:	9b03      	ldr	r3, [sp, #12]
 800723c:	681a      	ldr	r2, [r3, #0]
 800723e:	9b01      	ldr	r3, [sp, #4]
 8007240:	601a      	str	r2, [r3, #0]
  tqp->next->queue.prev = (thread_t *)tqp;
 8007242:	9b01      	ldr	r3, [sp, #4]
 8007244:	681b      	ldr	r3, [r3, #0]
 8007246:	9a01      	ldr	r2, [sp, #4]
 8007248:	605a      	str	r2, [r3, #4]
  return tp;
 800724a:	9b03      	ldr	r3, [sp, #12]
}
 800724c:	4618      	mov	r0, r3
 800724e:	b004      	add	sp, #16
 8007250:	4770      	bx	lr
 8007252:	bf00      	nop
	...

08007260 <chSysLock.lto_priv.410>:
static inline void chSysLock(void) {
 8007260:	b508      	push	{r3, lr}
  port_lock();
 8007262:	f7ff ff75 	bl	8007150 <port_lock.lto_priv.302>
  _dbg_check_lock();
 8007266:	f7ff f8e3 	bl	8006430 <_dbg_check_lock>
}
 800726a:	bd08      	pop	{r3, pc}
 800726c:	0000      	movs	r0, r0
	...

08007270 <chSysUnlock.lto_priv.377>:
static inline void chSysUnlock(void) {
 8007270:	b508      	push	{r3, lr}
  _dbg_check_unlock();
 8007272:	f7ff f8f5 	bl	8006460 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8007276:	4b09      	ldr	r3, [pc, #36]	; (800729c <chSysUnlock.lto_priv.377+0x2c>)
 8007278:	681b      	ldr	r3, [r3, #0]
 800727a:	4a08      	ldr	r2, [pc, #32]	; (800729c <chSysUnlock.lto_priv.377+0x2c>)
 800727c:	4293      	cmp	r3, r2
 800727e:	d00a      	beq.n	8007296 <chSysUnlock.lto_priv.377+0x26>
 8007280:	4b06      	ldr	r3, [pc, #24]	; (800729c <chSysUnlock.lto_priv.377+0x2c>)
 8007282:	699b      	ldr	r3, [r3, #24]
 8007284:	689a      	ldr	r2, [r3, #8]
 8007286:	4b05      	ldr	r3, [pc, #20]	; (800729c <chSysUnlock.lto_priv.377+0x2c>)
 8007288:	681b      	ldr	r3, [r3, #0]
 800728a:	689b      	ldr	r3, [r3, #8]
 800728c:	429a      	cmp	r2, r3
 800728e:	d202      	bcs.n	8007296 <chSysUnlock.lto_priv.377+0x26>
 8007290:	4803      	ldr	r0, [pc, #12]	; (80072a0 <chSysUnlock.lto_priv.377+0x30>)
 8007292:	f7ff f84d 	bl	8006330 <chSysHalt>
  port_unlock();
 8007296:	f7ff ff63 	bl	8007160 <port_unlock.lto_priv.261>
}
 800729a:	bd08      	pop	{r3, pc}
 800729c:	20000b38 	.word	0x20000b38
 80072a0:	08009694 	.word	0x08009694
	...

080072b0 <chThdGetWorkingAreaX.lto_priv.626>:
static inline stkalign_t *chThdGetWorkingAreaX(thread_t *tp) {
 80072b0:	b082      	sub	sp, #8
 80072b2:	9001      	str	r0, [sp, #4]
  return tp->wabase;
 80072b4:	9b01      	ldr	r3, [sp, #4]
 80072b6:	69db      	ldr	r3, [r3, #28]
}
 80072b8:	4618      	mov	r0, r3
 80072ba:	b002      	add	sp, #8
 80072bc:	4770      	bx	lr
 80072be:	bf00      	nop

080072c0 <chThdSleepS>:
static inline void chThdSleepS(sysinterval_t ticks) {
 80072c0:	b500      	push	{lr}
 80072c2:	b083      	sub	sp, #12
 80072c4:	9001      	str	r0, [sp, #4]
  chDbgCheck(ticks != TIME_IMMEDIATE);
 80072c6:	9b01      	ldr	r3, [sp, #4]
 80072c8:	2b00      	cmp	r3, #0
 80072ca:	d102      	bne.n	80072d2 <chThdSleepS+0x12>
 80072cc:	4804      	ldr	r0, [pc, #16]	; (80072e0 <chThdSleepS+0x20>)
 80072ce:	f7ff f82f 	bl	8006330 <chSysHalt>
  (void) chSchGoSleepTimeoutS(CH_STATE_SLEEPING, ticks);
 80072d2:	9901      	ldr	r1, [sp, #4]
 80072d4:	2008      	movs	r0, #8
 80072d6:	f7ff fe13 	bl	8006f00 <chSchGoSleepTimeoutS>
}
 80072da:	b003      	add	sp, #12
 80072dc:	f85d fb04 	ldr.w	pc, [sp], #4
 80072e0:	080096dc 	.word	0x080096dc
	...

080072f0 <chThdDoDequeueNextI>:
 * @param[in] tqp       pointer to the threads queue object
 * @param[in] msg       the message code
 *
 * @iclass
 */
static inline void chThdDoDequeueNextI(threads_queue_t *tqp, msg_t msg) {
 80072f0:	b500      	push	{lr}
 80072f2:	b085      	sub	sp, #20
 80072f4:	9001      	str	r0, [sp, #4]
 80072f6:	9100      	str	r1, [sp, #0]
  thread_t *tp;

  chDbgAssert(queue_notempty(tqp), "empty queue");
 80072f8:	9801      	ldr	r0, [sp, #4]
 80072fa:	f7ff ff61 	bl	80071c0 <queue_notempty.lto_priv.613>
 80072fe:	4603      	mov	r3, r0
 8007300:	f083 0301 	eor.w	r3, r3, #1
 8007304:	b2db      	uxtb	r3, r3
 8007306:	2b00      	cmp	r3, #0
 8007308:	d002      	beq.n	8007310 <chThdDoDequeueNextI+0x20>
 800730a:	480c      	ldr	r0, [pc, #48]	; (800733c <chThdDoDequeueNextI+0x4c>)
 800730c:	f7ff f810 	bl	8006330 <chSysHalt>

  tp = queue_fifo_remove(tqp);
 8007310:	9801      	ldr	r0, [sp, #4]
 8007312:	f7ff ff8d 	bl	8007230 <queue_fifo_remove.lto_priv.599>
 8007316:	9003      	str	r0, [sp, #12]

  chDbgAssert(tp->state == CH_STATE_QUEUED, "invalid state");
 8007318:	9b03      	ldr	r3, [sp, #12]
 800731a:	f893 3020 	ldrb.w	r3, [r3, #32]
 800731e:	2b04      	cmp	r3, #4
 8007320:	d002      	beq.n	8007328 <chThdDoDequeueNextI+0x38>
 8007322:	4806      	ldr	r0, [pc, #24]	; (800733c <chThdDoDequeueNextI+0x4c>)
 8007324:	f7ff f804 	bl	8006330 <chSysHalt>

  tp->u.rdymsg = msg;
 8007328:	9b03      	ldr	r3, [sp, #12]
 800732a:	9a00      	ldr	r2, [sp, #0]
 800732c:	625a      	str	r2, [r3, #36]	; 0x24
  (void) chSchReadyI(tp);
 800732e:	9803      	ldr	r0, [sp, #12]
 8007330:	f7ff fce6 	bl	8006d00 <chSchReadyI>
}
 8007334:	b005      	add	sp, #20
 8007336:	f85d fb04 	ldr.w	pc, [sp], #4
 800733a:	bf00      	nop
 800733c:	080096e8 	.word	0x080096e8

08007340 <_thread_init>:
 * @param[in] prio      the priority level for the new thread
 * @return              The same thread pointer passed as parameter.
 *
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, const char *name, tprio_t prio) {
 8007340:	b500      	push	{lr}
 8007342:	b085      	sub	sp, #20
 8007344:	9003      	str	r0, [sp, #12]
 8007346:	9102      	str	r1, [sp, #8]
 8007348:	9201      	str	r2, [sp, #4]

  tp->prio      = prio;
 800734a:	9b03      	ldr	r3, [sp, #12]
 800734c:	9a01      	ldr	r2, [sp, #4]
 800734e:	609a      	str	r2, [r3, #8]
  tp->state     = CH_STATE_WTSTART;
 8007350:	9b03      	ldr	r3, [sp, #12]
 8007352:	2202      	movs	r2, #2
 8007354:	f883 2020 	strb.w	r2, [r3, #32]
  tp->flags     = CH_FLAG_MODE_STATIC;
 8007358:	9b03      	ldr	r3, [sp, #12]
 800735a:	2200      	movs	r2, #0
 800735c:	f883 2021 	strb.w	r2, [r3, #33]	; 0x21
#if CH_CFG_TIME_QUANTUM > 0
  tp->ticks     = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
#if CH_CFG_USE_MUTEXES == TRUE
  tp->realprio  = prio;
 8007360:	9b03      	ldr	r3, [sp, #12]
 8007362:	9a01      	ldr	r2, [sp, #4]
 8007364:	63da      	str	r2, [r3, #60]	; 0x3c
  tp->mtxlist   = NULL;
 8007366:	9b03      	ldr	r3, [sp, #12]
 8007368:	2200      	movs	r2, #0
 800736a:	639a      	str	r2, [r3, #56]	; 0x38
#endif
#if CH_CFG_USE_EVENTS == TRUE
  tp->epending  = (eventmask_t)0;
 800736c:	9b03      	ldr	r3, [sp, #12]
 800736e:	2200      	movs	r2, #0
 8007370:	635a      	str	r2, [r3, #52]	; 0x34
#endif
#if CH_DBG_THREADS_PROFILING == TRUE
  tp->time      = (systime_t)0;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->refs      = (trefs_t)1;
 8007372:	9b03      	ldr	r3, [sp, #12]
 8007374:	2201      	movs	r2, #1
 8007376:	f883 2022 	strb.w	r2, [r3, #34]	; 0x22
  tp->name      = name;
 800737a:	9b03      	ldr	r3, [sp, #12]
 800737c:	9a02      	ldr	r2, [sp, #8]
 800737e:	619a      	str	r2, [r3, #24]
  REG_INSERT(tp);
 8007380:	9b03      	ldr	r3, [sp, #12]
 8007382:	4a0e      	ldr	r2, [pc, #56]	; (80073bc <_thread_init+0x7c>)
 8007384:	611a      	str	r2, [r3, #16]
 8007386:	4b0d      	ldr	r3, [pc, #52]	; (80073bc <_thread_init+0x7c>)
 8007388:	695a      	ldr	r2, [r3, #20]
 800738a:	9b03      	ldr	r3, [sp, #12]
 800738c:	615a      	str	r2, [r3, #20]
 800738e:	9b03      	ldr	r3, [sp, #12]
 8007390:	695b      	ldr	r3, [r3, #20]
 8007392:	9a03      	ldr	r2, [sp, #12]
 8007394:	611a      	str	r2, [r3, #16]
 8007396:	4a09      	ldr	r2, [pc, #36]	; (80073bc <_thread_init+0x7c>)
 8007398:	9b03      	ldr	r3, [sp, #12]
 800739a:	6153      	str	r3, [r2, #20]
#else
  (void)name;
#endif
#if CH_CFG_USE_WAITEXIT == TRUE
  list_init(&tp->waiting);
 800739c:	9b03      	ldr	r3, [sp, #12]
 800739e:	3328      	adds	r3, #40	; 0x28
 80073a0:	4618      	mov	r0, r3
 80073a2:	f7ff fee5 	bl	8007170 <list_init>
#endif
#if CH_CFG_USE_MESSAGES == TRUE
  queue_init(&tp->msgqueue);
 80073a6:	9b03      	ldr	r3, [sp, #12]
 80073a8:	332c      	adds	r3, #44	; 0x2c
 80073aa:	4618      	mov	r0, r3
 80073ac:	f7ff fef8 	bl	80071a0 <queue_init.lto_priv.593>
#endif
#if CH_DBG_STATISTICS == TRUE
  chTMObjectInit(&tp->stats);
#endif
  CH_CFG_THREAD_INIT_HOOK(tp);
  return tp;
 80073b0:	9b03      	ldr	r3, [sp, #12]
}
 80073b2:	4618      	mov	r0, r3
 80073b4:	b005      	add	sp, #20
 80073b6:	f85d fb04 	ldr.w	pc, [sp], #4
 80073ba:	bf00      	nop
 80073bc:	20000b38 	.word	0x20000b38

080073c0 <_thread_memfill>:
 * @param[in] endp      last address to fill +1
 * @param[in] v         filler value
 *
 * @notapi
 */
void _thread_memfill(uint8_t *startp, uint8_t *endp, uint8_t v) {
 80073c0:	b084      	sub	sp, #16
 80073c2:	9003      	str	r0, [sp, #12]
 80073c4:	9102      	str	r1, [sp, #8]
 80073c6:	4613      	mov	r3, r2
 80073c8:	f88d 3007 	strb.w	r3, [sp, #7]
 80073cc:	e005      	b.n	80073da <_thread_memfill+0x1a>

  while (startp < endp) {
    *startp++ = v;
 80073ce:	9b03      	ldr	r3, [sp, #12]
 80073d0:	1c5a      	adds	r2, r3, #1
 80073d2:	9203      	str	r2, [sp, #12]
 80073d4:	f89d 2007 	ldrb.w	r2, [sp, #7]
 80073d8:	701a      	strb	r2, [r3, #0]
  while (startp < endp) {
 80073da:	9a03      	ldr	r2, [sp, #12]
 80073dc:	9b02      	ldr	r3, [sp, #8]
 80073de:	429a      	cmp	r2, r3
 80073e0:	d3f5      	bcc.n	80073ce <_thread_memfill+0xe>
  }
}
 80073e2:	b004      	add	sp, #16
 80073e4:	4770      	bx	lr
 80073e6:	bf00      	nop
	...

080073f0 <chThdCreateSuspendedI>:
 * @return              The pointer to the @p thread_t structure allocated for
 *                      the thread into the working space area.
 *
 * @iclass
 */
thread_t *chThdCreateSuspendedI(const thread_descriptor_t *tdp) {
 80073f0:	b500      	push	{lr}
 80073f2:	b085      	sub	sp, #20
 80073f4:	9001      	str	r0, [sp, #4]
  thread_t *tp;

  chDbgCheckClassI();
 80073f6:	f7ff f8bb 	bl	8006570 <chDbgCheckClassI>
  chDbgCheck(tdp != NULL);
 80073fa:	9b01      	ldr	r3, [sp, #4]
 80073fc:	2b00      	cmp	r3, #0
 80073fe:	d102      	bne.n	8007406 <chThdCreateSuspendedI+0x16>
 8007400:	4829      	ldr	r0, [pc, #164]	; (80074a8 <chThdCreateSuspendedI+0xb8>)
 8007402:	f7fe ff95 	bl	8006330 <chSysHalt>
  chDbgCheck(MEM_IS_ALIGNED(tdp->wbase, PORT_WORKING_AREA_ALIGN) &&
 8007406:	9b01      	ldr	r3, [sp, #4]
 8007408:	685b      	ldr	r3, [r3, #4]
 800740a:	f003 0307 	and.w	r3, r3, #7
 800740e:	2b00      	cmp	r3, #0
 8007410:	d113      	bne.n	800743a <chThdCreateSuspendedI+0x4a>
 8007412:	9b01      	ldr	r3, [sp, #4]
 8007414:	689b      	ldr	r3, [r3, #8]
 8007416:	f003 0307 	and.w	r3, r3, #7
 800741a:	2b00      	cmp	r3, #0
 800741c:	d10d      	bne.n	800743a <chThdCreateSuspendedI+0x4a>
 800741e:	9b01      	ldr	r3, [sp, #4]
 8007420:	689a      	ldr	r2, [r3, #8]
 8007422:	9b01      	ldr	r3, [sp, #4]
 8007424:	685b      	ldr	r3, [r3, #4]
 8007426:	429a      	cmp	r2, r3
 8007428:	d907      	bls.n	800743a <chThdCreateSuspendedI+0x4a>
 800742a:	9b01      	ldr	r3, [sp, #4]
 800742c:	689b      	ldr	r3, [r3, #8]
 800742e:	461a      	mov	r2, r3
 8007430:	9b01      	ldr	r3, [sp, #4]
 8007432:	685b      	ldr	r3, [r3, #4]
 8007434:	1ad3      	subs	r3, r2, r3
 8007436:	2bc7      	cmp	r3, #199	; 0xc7
 8007438:	d802      	bhi.n	8007440 <chThdCreateSuspendedI+0x50>
 800743a:	481b      	ldr	r0, [pc, #108]	; (80074a8 <chThdCreateSuspendedI+0xb8>)
 800743c:	f7fe ff78 	bl	8006330 <chSysHalt>
             MEM_IS_ALIGNED(tdp->wend, PORT_STACK_ALIGN) &&
             (tdp->wend > tdp->wbase) &&
             (((size_t)tdp->wend - (size_t)tdp->wbase) >= THD_WORKING_AREA_SIZE(0)));
  chDbgCheck((tdp->prio <= HIGHPRIO) && (tdp->funcp != NULL));
 8007440:	9b01      	ldr	r3, [sp, #4]
 8007442:	68db      	ldr	r3, [r3, #12]
 8007444:	2bff      	cmp	r3, #255	; 0xff
 8007446:	d803      	bhi.n	8007450 <chThdCreateSuspendedI+0x60>
 8007448:	9b01      	ldr	r3, [sp, #4]
 800744a:	691b      	ldr	r3, [r3, #16]
 800744c:	2b00      	cmp	r3, #0
 800744e:	d102      	bne.n	8007456 <chThdCreateSuspendedI+0x66>
 8007450:	4815      	ldr	r0, [pc, #84]	; (80074a8 <chThdCreateSuspendedI+0xb8>)
 8007452:	f7fe ff6d 	bl	8006330 <chSysHalt>

  /* The thread structure is laid out in the upper part of the thread
     workspace. The thread position structure is aligned to the required
     stack alignment because it represents the stack top.*/
  tp = (thread_t *)((uint8_t *)tdp->wend -
 8007456:	9b01      	ldr	r3, [sp, #4]
 8007458:	689b      	ldr	r3, [r3, #8]
 800745a:	3b48      	subs	r3, #72	; 0x48
 800745c:	9303      	str	r3, [sp, #12]
                    MEM_ALIGN_NEXT(sizeof (thread_t), PORT_STACK_ALIGN));

#if (CH_DBG_ENABLE_STACK_CHECK == TRUE) || (CH_CFG_USE_DYNAMIC == TRUE)
  /* Stack boundary.*/
  tp->wabase = tdp->wbase;
 800745e:	9b01      	ldr	r3, [sp, #4]
 8007460:	685a      	ldr	r2, [r3, #4]
 8007462:	9b03      	ldr	r3, [sp, #12]
 8007464:	61da      	str	r2, [r3, #28]
#endif

  /* Setting up the port-dependent part of the working area.*/
  PORT_SETUP_CONTEXT(tp, tdp->wbase, tp, tdp->funcp, tdp->arg);
 8007466:	9b03      	ldr	r3, [sp, #12]
 8007468:	f1a3 0224 	sub.w	r2, r3, #36	; 0x24
 800746c:	9b03      	ldr	r3, [sp, #12]
 800746e:	60da      	str	r2, [r3, #12]
 8007470:	9b03      	ldr	r3, [sp, #12]
 8007472:	68db      	ldr	r3, [r3, #12]
 8007474:	9a01      	ldr	r2, [sp, #4]
 8007476:	6912      	ldr	r2, [r2, #16]
 8007478:	601a      	str	r2, [r3, #0]
 800747a:	9b03      	ldr	r3, [sp, #12]
 800747c:	68db      	ldr	r3, [r3, #12]
 800747e:	9a01      	ldr	r2, [sp, #4]
 8007480:	6952      	ldr	r2, [r2, #20]
 8007482:	605a      	str	r2, [r3, #4]
 8007484:	9b03      	ldr	r3, [sp, #12]
 8007486:	68db      	ldr	r3, [r3, #12]
 8007488:	4a08      	ldr	r2, [pc, #32]	; (80074ac <chThdCreateSuspendedI+0xbc>)
 800748a:	621a      	str	r2, [r3, #32]

  /* The driver object is initialized but not started.*/
  return _thread_init(tp, tdp->name, tdp->prio);
 800748c:	9b01      	ldr	r3, [sp, #4]
 800748e:	6819      	ldr	r1, [r3, #0]
 8007490:	9b01      	ldr	r3, [sp, #4]
 8007492:	68db      	ldr	r3, [r3, #12]
 8007494:	461a      	mov	r2, r3
 8007496:	9803      	ldr	r0, [sp, #12]
 8007498:	f7ff ff52 	bl	8007340 <_thread_init>
 800749c:	4603      	mov	r3, r0
}
 800749e:	4618      	mov	r0, r3
 80074a0:	b005      	add	sp, #20
 80074a2:	f85d fb04 	ldr.w	pc, [sp], #4
 80074a6:	bf00      	nop
 80074a8:	0800967c 	.word	0x0800967c
 80074ac:	080002e1 	.word	0x080002e1

080074b0 <chThdCreate>:
 * @return              The pointer to the @p thread_t structure allocated for
 *                      the thread into the working space area.
 *
 * @iclass
 */
thread_t *chThdCreate(const thread_descriptor_t *tdp) {
 80074b0:	b500      	push	{lr}
 80074b2:	b085      	sub	sp, #20
 80074b4:	9001      	str	r0, [sp, #4]
  thread_t *tp;

#if (CH_CFG_USE_REGISTRY == TRUE) &&                                        \
    ((CH_DBG_ENABLE_STACK_CHECK == TRUE) || (CH_CFG_USE_DYNAMIC == TRUE))
  chDbgAssert(chRegFindThreadByWorkingArea(tdp->wbase) == NULL,
 80074b6:	9b01      	ldr	r3, [sp, #4]
 80074b8:	685b      	ldr	r3, [r3, #4]
 80074ba:	4618      	mov	r0, r3
 80074bc:	f000 fac8 	bl	8007a50 <chRegFindThreadByWorkingArea>
 80074c0:	4603      	mov	r3, r0
 80074c2:	2b00      	cmp	r3, #0
 80074c4:	d002      	beq.n	80074cc <chThdCreate+0x1c>
 80074c6:	480e      	ldr	r0, [pc, #56]	; (8007500 <chThdCreate+0x50>)
 80074c8:	f7fe ff32 	bl	8006330 <chSysHalt>
              "working area in use");
#endif

#if CH_DBG_FILL_THREADS == TRUE
  _thread_memfill((uint8_t *)tdp->wbase,
 80074cc:	9b01      	ldr	r3, [sp, #4]
 80074ce:	6858      	ldr	r0, [r3, #4]
                  (uint8_t *)tdp->wend,
 80074d0:	9b01      	ldr	r3, [sp, #4]
 80074d2:	689b      	ldr	r3, [r3, #8]
  _thread_memfill((uint8_t *)tdp->wbase,
 80074d4:	2255      	movs	r2, #85	; 0x55
 80074d6:	4619      	mov	r1, r3
 80074d8:	f7ff ff72 	bl	80073c0 <_thread_memfill>
                  CH_DBG_STACK_FILL_VALUE);
#endif

  chSysLock();
 80074dc:	f7ff fec0 	bl	8007260 <chSysLock.lto_priv.410>
  tp = chThdCreateSuspendedI(tdp);
 80074e0:	9801      	ldr	r0, [sp, #4]
 80074e2:	f7ff ff85 	bl	80073f0 <chThdCreateSuspendedI>
 80074e6:	9003      	str	r0, [sp, #12]
  chSchWakeupS(tp, MSG_OK);
 80074e8:	2100      	movs	r1, #0
 80074ea:	9803      	ldr	r0, [sp, #12]
 80074ec:	f7ff fd40 	bl	8006f70 <chSchWakeupS>
  chSysUnlock();
 80074f0:	f7ff febe 	bl	8007270 <chSysUnlock.lto_priv.377>

  return tp;
 80074f4:	9b03      	ldr	r3, [sp, #12]
}
 80074f6:	4618      	mov	r0, r3
 80074f8:	b005      	add	sp, #20
 80074fa:	f85d fb04 	ldr.w	pc, [sp], #4
 80074fe:	bf00      	nop
 8007500:	080096a0 	.word	0x080096a0
	...

08007510 <chThdCreateStatic>:
 *                      the thread into the working space area.
 *
 * @api
 */
thread_t *chThdCreateStatic(void *wsp, size_t size,
                            tprio_t prio, tfunc_t pf, void *arg) {
 8007510:	b500      	push	{lr}
 8007512:	b087      	sub	sp, #28
 8007514:	9003      	str	r0, [sp, #12]
 8007516:	9102      	str	r1, [sp, #8]
 8007518:	9201      	str	r2, [sp, #4]
 800751a:	9300      	str	r3, [sp, #0]
  thread_t *tp;

  chDbgCheck((wsp != NULL) &&
 800751c:	9b03      	ldr	r3, [sp, #12]
 800751e:	2b00      	cmp	r3, #0
 8007520:	d012      	beq.n	8007548 <chThdCreateStatic+0x38>
 8007522:	9b03      	ldr	r3, [sp, #12]
 8007524:	f003 0307 	and.w	r3, r3, #7
 8007528:	2b00      	cmp	r3, #0
 800752a:	d10d      	bne.n	8007548 <chThdCreateStatic+0x38>
 800752c:	9b02      	ldr	r3, [sp, #8]
 800752e:	2bc7      	cmp	r3, #199	; 0xc7
 8007530:	d90a      	bls.n	8007548 <chThdCreateStatic+0x38>
 8007532:	9b02      	ldr	r3, [sp, #8]
 8007534:	f003 0307 	and.w	r3, r3, #7
 8007538:	2b00      	cmp	r3, #0
 800753a:	d105      	bne.n	8007548 <chThdCreateStatic+0x38>
 800753c:	9b01      	ldr	r3, [sp, #4]
 800753e:	2bff      	cmp	r3, #255	; 0xff
 8007540:	d802      	bhi.n	8007548 <chThdCreateStatic+0x38>
 8007542:	9b00      	ldr	r3, [sp, #0]
 8007544:	2b00      	cmp	r3, #0
 8007546:	d102      	bne.n	800754e <chThdCreateStatic+0x3e>
 8007548:	481f      	ldr	r0, [pc, #124]	; (80075c8 <chThdCreateStatic+0xb8>)
 800754a:	f7fe fef1 	bl	8006330 <chSysHalt>
             MEM_IS_ALIGNED(size, PORT_STACK_ALIGN) &&
             (prio <= HIGHPRIO) && (pf != NULL));

#if (CH_CFG_USE_REGISTRY == TRUE) &&                                        \
    ((CH_DBG_ENABLE_STACK_CHECK == TRUE) || (CH_CFG_USE_DYNAMIC == TRUE))
  chDbgAssert(chRegFindThreadByWorkingArea(wsp) == NULL,
 800754e:	9803      	ldr	r0, [sp, #12]
 8007550:	f000 fa7e 	bl	8007a50 <chRegFindThreadByWorkingArea>
 8007554:	4603      	mov	r3, r0
 8007556:	2b00      	cmp	r3, #0
 8007558:	d002      	beq.n	8007560 <chThdCreateStatic+0x50>
 800755a:	481b      	ldr	r0, [pc, #108]	; (80075c8 <chThdCreateStatic+0xb8>)
 800755c:	f7fe fee8 	bl	8006330 <chSysHalt>
              "working area in use");
#endif

#if CH_DBG_FILL_THREADS == TRUE
  _thread_memfill((uint8_t *)wsp,
 8007560:	9a03      	ldr	r2, [sp, #12]
 8007562:	9b02      	ldr	r3, [sp, #8]
 8007564:	4413      	add	r3, r2
 8007566:	2255      	movs	r2, #85	; 0x55
 8007568:	4619      	mov	r1, r3
 800756a:	9803      	ldr	r0, [sp, #12]
 800756c:	f7ff ff28 	bl	80073c0 <_thread_memfill>
                  (uint8_t *)wsp + size,
                  CH_DBG_STACK_FILL_VALUE);
#endif

  chSysLock();
 8007570:	f7ff fe76 	bl	8007260 <chSysLock.lto_priv.410>

  /* The thread structure is laid out in the upper part of the thread
     workspace. The thread position structure is aligned to the required
     stack alignment because it represents the stack top.*/
  tp = (thread_t *)((uint8_t *)wsp + size -
 8007574:	9b02      	ldr	r3, [sp, #8]
 8007576:	3b48      	subs	r3, #72	; 0x48
 8007578:	9a03      	ldr	r2, [sp, #12]
 800757a:	4413      	add	r3, r2
 800757c:	9305      	str	r3, [sp, #20]
                    MEM_ALIGN_NEXT(sizeof (thread_t), PORT_STACK_ALIGN));

#if (CH_DBG_ENABLE_STACK_CHECK == TRUE) || (CH_CFG_USE_DYNAMIC == TRUE)
  /* Stack boundary.*/
  tp->wabase = (stkalign_t *)wsp;
 800757e:	9b05      	ldr	r3, [sp, #20]
 8007580:	9a03      	ldr	r2, [sp, #12]
 8007582:	61da      	str	r2, [r3, #28]
#endif

  /* Setting up the port-dependent part of the working area.*/
  PORT_SETUP_CONTEXT(tp, wsp, tp, pf, arg);
 8007584:	9b05      	ldr	r3, [sp, #20]
 8007586:	f1a3 0224 	sub.w	r2, r3, #36	; 0x24
 800758a:	9b05      	ldr	r3, [sp, #20]
 800758c:	60da      	str	r2, [r3, #12]
 800758e:	9b05      	ldr	r3, [sp, #20]
 8007590:	68db      	ldr	r3, [r3, #12]
 8007592:	9a00      	ldr	r2, [sp, #0]
 8007594:	601a      	str	r2, [r3, #0]
 8007596:	9b05      	ldr	r3, [sp, #20]
 8007598:	68db      	ldr	r3, [r3, #12]
 800759a:	9a08      	ldr	r2, [sp, #32]
 800759c:	605a      	str	r2, [r3, #4]
 800759e:	9b05      	ldr	r3, [sp, #20]
 80075a0:	68db      	ldr	r3, [r3, #12]
 80075a2:	4a0a      	ldr	r2, [pc, #40]	; (80075cc <chThdCreateStatic+0xbc>)
 80075a4:	621a      	str	r2, [r3, #32]

  tp = _thread_init(tp, "noname", prio);
 80075a6:	9a01      	ldr	r2, [sp, #4]
 80075a8:	4909      	ldr	r1, [pc, #36]	; (80075d0 <chThdCreateStatic+0xc0>)
 80075aa:	9805      	ldr	r0, [sp, #20]
 80075ac:	f7ff fec8 	bl	8007340 <_thread_init>
 80075b0:	9005      	str	r0, [sp, #20]

  /* Starting the thread immediately.*/
  chSchWakeupS(tp, MSG_OK);
 80075b2:	2100      	movs	r1, #0
 80075b4:	9805      	ldr	r0, [sp, #20]
 80075b6:	f7ff fcdb 	bl	8006f70 <chSchWakeupS>
  chSysUnlock();
 80075ba:	f7ff fe59 	bl	8007270 <chSysUnlock.lto_priv.377>

  return tp;
 80075be:	9b05      	ldr	r3, [sp, #20]
}
 80075c0:	4618      	mov	r0, r3
 80075c2:	b007      	add	sp, #28
 80075c4:	f85d fb04 	ldr.w	pc, [sp], #4
 80075c8:	080096ac 	.word	0x080096ac
 80075cc:	080002e1 	.word	0x080002e1
 80075d0:	080099d0 	.word	0x080099d0
	...

080075e0 <chThdRelease>:
 *
 * @param[in] tp        pointer to the thread
 *
 * @api
 */
void chThdRelease(thread_t *tp) {
 80075e0:	b510      	push	{r4, lr}
 80075e2:	b082      	sub	sp, #8
 80075e4:	9001      	str	r0, [sp, #4]

  chSysLock();
 80075e6:	f7ff fe3b 	bl	8007260 <chSysLock.lto_priv.410>
  chDbgAssert(tp->refs > (trefs_t)0, "not referenced");
 80075ea:	9b01      	ldr	r3, [sp, #4]
 80075ec:	f893 3022 	ldrb.w	r3, [r3, #34]	; 0x22
 80075f0:	2b00      	cmp	r3, #0
 80075f2:	d102      	bne.n	80075fa <chThdRelease+0x1a>
 80075f4:	4820      	ldr	r0, [pc, #128]	; (8007678 <chThdRelease+0x98>)
 80075f6:	f7fe fe9b 	bl	8006330 <chSysHalt>
  tp->refs--;
 80075fa:	9b01      	ldr	r3, [sp, #4]
 80075fc:	f893 3022 	ldrb.w	r3, [r3, #34]	; 0x22
 8007600:	3b01      	subs	r3, #1
 8007602:	b2da      	uxtb	r2, r3
 8007604:	9b01      	ldr	r3, [sp, #4]
 8007606:	f883 2022 	strb.w	r2, [r3, #34]	; 0x22

  /* If the references counter reaches zero and the thread is in its
     terminated state then the memory can be returned to the proper
     allocator.*/
  if ((tp->refs == (trefs_t)0) && (tp->state == CH_STATE_FINAL)) {
 800760a:	9b01      	ldr	r3, [sp, #4]
 800760c:	f893 3022 	ldrb.w	r3, [r3, #34]	; 0x22
 8007610:	2b00      	cmp	r3, #0
 8007612:	d12d      	bne.n	8007670 <chThdRelease+0x90>
 8007614:	9b01      	ldr	r3, [sp, #4]
 8007616:	f893 3020 	ldrb.w	r3, [r3, #32]
 800761a:	2b0f      	cmp	r3, #15
 800761c:	d128      	bne.n	8007670 <chThdRelease+0x90>
    REG_REMOVE(tp);
 800761e:	9b01      	ldr	r3, [sp, #4]
 8007620:	695b      	ldr	r3, [r3, #20]
 8007622:	9a01      	ldr	r2, [sp, #4]
 8007624:	6912      	ldr	r2, [r2, #16]
 8007626:	611a      	str	r2, [r3, #16]
 8007628:	9b01      	ldr	r3, [sp, #4]
 800762a:	691b      	ldr	r3, [r3, #16]
 800762c:	9a01      	ldr	r2, [sp, #4]
 800762e:	6952      	ldr	r2, [r2, #20]
 8007630:	615a      	str	r2, [r3, #20]
    chSysUnlock();
 8007632:	f7ff fe1d 	bl	8007270 <chSysUnlock.lto_priv.377>

#if CH_CFG_USE_DYNAMIC == TRUE
    switch (tp->flags & CH_FLAG_MODE_MASK) {
 8007636:	9b01      	ldr	r3, [sp, #4]
 8007638:	f893 3021 	ldrb.w	r3, [r3, #33]	; 0x21
 800763c:	f003 0303 	and.w	r3, r3, #3
 8007640:	2b01      	cmp	r3, #1
 8007642:	d002      	beq.n	800764a <chThdRelease+0x6a>
 8007644:	2b02      	cmp	r3, #2
 8007646:	d008      	beq.n	800765a <chThdRelease+0x7a>
#if CH_CFG_USE_MEMPOOLS == TRUE
    case CH_FLAG_MODE_MPOOL:
      chPoolFree(tp->mpool, chThdGetWorkingAreaX(tp));
      break;
#endif
    default:
 8007648:	e014      	b.n	8007674 <chThdRelease+0x94>
      chHeapFree(chThdGetWorkingAreaX(tp));
 800764a:	9801      	ldr	r0, [sp, #4]
 800764c:	f7ff fe30 	bl	80072b0 <chThdGetWorkingAreaX.lto_priv.626>
 8007650:	4603      	mov	r3, r0
 8007652:	4618      	mov	r0, r3
 8007654:	f000 fd24 	bl	80080a0 <chHeapFree>
    default:
 8007658:	e00c      	b.n	8007674 <chThdRelease+0x94>
      chPoolFree(tp->mpool, chThdGetWorkingAreaX(tp));
 800765a:	9b01      	ldr	r3, [sp, #4]
 800765c:	6c1c      	ldr	r4, [r3, #64]	; 0x40
 800765e:	9801      	ldr	r0, [sp, #4]
 8007660:	f7ff fe26 	bl	80072b0 <chThdGetWorkingAreaX.lto_priv.626>
 8007664:	4603      	mov	r3, r0
 8007666:	4619      	mov	r1, r3
 8007668:	4620      	mov	r0, r4
 800766a:	f000 fe31 	bl	80082d0 <chPoolFree>
    default:
 800766e:	e001      	b.n	8007674 <chThdRelease+0x94>
      break;
    }
#endif /* CH_CFG_USE_DYNAMIC == TRUE */
    return;
  }
  chSysUnlock();
 8007670:	f7ff fdfe 	bl	8007270 <chSysUnlock.lto_priv.377>
}
 8007674:	b002      	add	sp, #8
 8007676:	bd10      	pop	{r4, pc}
 8007678:	080096c0 	.word	0x080096c0
 800767c:	00000000 	.word	0x00000000

08007680 <chThdExit>:
 *
 * @param[in] msg       thread exit code
 *
 * @api
 */
void chThdExit(msg_t msg) {
 8007680:	b500      	push	{lr}
 8007682:	b083      	sub	sp, #12
 8007684:	9001      	str	r0, [sp, #4]

  chSysLock();
 8007686:	f7ff fdeb 	bl	8007260 <chSysLock.lto_priv.410>
  chThdExitS(msg);
 800768a:	9801      	ldr	r0, [sp, #4]
 800768c:	f000 f808 	bl	80076a0 <chThdExitS>
  /* The thread never returns here.*/
}
 8007690:	b003      	add	sp, #12
 8007692:	f85d fb04 	ldr.w	pc, [sp], #4
 8007696:	bf00      	nop
	...

080076a0 <chThdExitS>:
 *
 * @param[in] msg       thread exit code
 *
 * @sclass
 */
void chThdExitS(msg_t msg) {
 80076a0:	b500      	push	{lr}
 80076a2:	b085      	sub	sp, #20
 80076a4:	9001      	str	r0, [sp, #4]
  thread_t *tp = currp;
 80076a6:	4b1b      	ldr	r3, [pc, #108]	; (8007714 <chThdExitS+0x74>)
 80076a8:	699b      	ldr	r3, [r3, #24]
 80076aa:	9303      	str	r3, [sp, #12]

  /* Storing exit message.*/
  tp->u.exitcode = msg;
 80076ac:	9b03      	ldr	r3, [sp, #12]
 80076ae:	9a01      	ldr	r2, [sp, #4]
 80076b0:	625a      	str	r2, [r3, #36]	; 0x24
 80076b2:	e008      	b.n	80076c6 <chThdExitS+0x26>
  CH_CFG_THREAD_EXIT_HOOK(tp);

#if CH_CFG_USE_WAITEXIT == TRUE
  /* Waking up any waiting thread.*/
  while (list_notempty(&tp->waiting)) {
    (void) chSchReadyI(list_remove(&tp->waiting));
 80076b4:	9b03      	ldr	r3, [sp, #12]
 80076b6:	3328      	adds	r3, #40	; 0x28
 80076b8:	4618      	mov	r0, r3
 80076ba:	f7ff fd91 	bl	80071e0 <list_remove>
 80076be:	4603      	mov	r3, r0
 80076c0:	4618      	mov	r0, r3
 80076c2:	f7ff fb1d 	bl	8006d00 <chSchReadyI>
  while (list_notempty(&tp->waiting)) {
 80076c6:	9b03      	ldr	r3, [sp, #12]
 80076c8:	3328      	adds	r3, #40	; 0x28
 80076ca:	4618      	mov	r0, r3
 80076cc:	f7ff fd58 	bl	8007180 <list_notempty>
 80076d0:	4603      	mov	r3, r0
 80076d2:	2b00      	cmp	r3, #0
 80076d4:	d1ee      	bne.n	80076b4 <chThdExitS+0x14>

#if CH_CFG_USE_REGISTRY == TRUE
  /* Static threads with no references are immediately removed from the
     registry because there is no memory to recover.*/
#if CH_CFG_USE_DYNAMIC == TRUE
  if ((tp->refs == (trefs_t)0) &&
 80076d6:	9b03      	ldr	r3, [sp, #12]
 80076d8:	f893 3022 	ldrb.w	r3, [r3, #34]	; 0x22
 80076dc:	2b00      	cmp	r3, #0
 80076de:	d110      	bne.n	8007702 <chThdExitS+0x62>
      ((tp->flags & CH_FLAG_MODE_MASK) == CH_FLAG_MODE_STATIC)) {
 80076e0:	9b03      	ldr	r3, [sp, #12]
 80076e2:	f893 3021 	ldrb.w	r3, [r3, #33]	; 0x21
 80076e6:	f003 0303 	and.w	r3, r3, #3
  if ((tp->refs == (trefs_t)0) &&
 80076ea:	2b00      	cmp	r3, #0
 80076ec:	d109      	bne.n	8007702 <chThdExitS+0x62>
    REG_REMOVE(tp);
 80076ee:	9b03      	ldr	r3, [sp, #12]
 80076f0:	695b      	ldr	r3, [r3, #20]
 80076f2:	9a03      	ldr	r2, [sp, #12]
 80076f4:	6912      	ldr	r2, [r2, #16]
 80076f6:	611a      	str	r2, [r3, #16]
 80076f8:	9b03      	ldr	r3, [sp, #12]
 80076fa:	691b      	ldr	r3, [r3, #16]
 80076fc:	9a03      	ldr	r2, [sp, #12]
 80076fe:	6952      	ldr	r2, [r2, #20]
 8007700:	615a      	str	r2, [r3, #20]
  }
#endif
#endif

  /* Going into final state.*/
  chSchGoSleepS(CH_STATE_FINAL);
 8007702:	200f      	movs	r0, #15
 8007704:	f7ff fb7c 	bl	8006e00 <chSchGoSleepS>

  /* The thread never returns here.*/
  chDbgAssert(false, "zombies apocalypse");
 8007708:	4803      	ldr	r0, [pc, #12]	; (8007718 <chThdExitS+0x78>)
 800770a:	f7fe fe11 	bl	8006330 <chSysHalt>
}
 800770e:	b005      	add	sp, #20
 8007710:	f85d fb04 	ldr.w	pc, [sp], #4
 8007714:	20000b38 	.word	0x20000b38
 8007718:	080096d0 	.word	0x080096d0
 800771c:	00000000 	.word	0x00000000

08007720 <chThdSleep>:
 *                      - @a TIME_IMMEDIATE this value is not allowed.
 *                      .
 *
 * @api
 */
void chThdSleep(sysinterval_t time) {
 8007720:	b500      	push	{lr}
 8007722:	b083      	sub	sp, #12
 8007724:	9001      	str	r0, [sp, #4]

  chSysLock();
 8007726:	f7ff fd9b 	bl	8007260 <chSysLock.lto_priv.410>
  chThdSleepS(time);
 800772a:	9801      	ldr	r0, [sp, #4]
 800772c:	f7ff fdc8 	bl	80072c0 <chThdSleepS>
  chSysUnlock();
 8007730:	f7ff fd9e 	bl	8007270 <chSysUnlock.lto_priv.377>
}
 8007734:	b003      	add	sp, #12
 8007736:	f85d fb04 	ldr.w	pc, [sp], #4
 800773a:	bf00      	nop
 800773c:	0000      	movs	r0, r0
	...

08007740 <chThdEnqueueTimeoutS>:
 *                      invoked with @p TIME_IMMEDIATE as timeout
 *                      specification.
 *
 * @sclass
 */
msg_t chThdEnqueueTimeoutS(threads_queue_t *tqp, sysinterval_t timeout) {
 8007740:	b500      	push	{lr}
 8007742:	b083      	sub	sp, #12
 8007744:	9001      	str	r0, [sp, #4]
 8007746:	9100      	str	r1, [sp, #0]

  if (TIME_IMMEDIATE == timeout) {
 8007748:	9b00      	ldr	r3, [sp, #0]
 800774a:	2b00      	cmp	r3, #0
 800774c:	d102      	bne.n	8007754 <chThdEnqueueTimeoutS+0x14>
    return MSG_TIMEOUT;
 800774e:	f04f 33ff 	mov.w	r3, #4294967295
 8007752:	e00a      	b.n	800776a <chThdEnqueueTimeoutS+0x2a>
  }

  queue_insert(currp, tqp);
 8007754:	4b07      	ldr	r3, [pc, #28]	; (8007774 <chThdEnqueueTimeoutS+0x34>)
 8007756:	699b      	ldr	r3, [r3, #24]
 8007758:	9901      	ldr	r1, [sp, #4]
 800775a:	4618      	mov	r0, r3
 800775c:	f7ff fd50 	bl	8007200 <queue_insert.lto_priv.604>

  return chSchGoSleepTimeoutS(CH_STATE_QUEUED, timeout);
 8007760:	9900      	ldr	r1, [sp, #0]
 8007762:	2004      	movs	r0, #4
 8007764:	f7ff fbcc 	bl	8006f00 <chSchGoSleepTimeoutS>
 8007768:	4603      	mov	r3, r0
}
 800776a:	4618      	mov	r0, r3
 800776c:	b003      	add	sp, #12
 800776e:	f85d fb04 	ldr.w	pc, [sp], #4
 8007772:	bf00      	nop
 8007774:	20000b38 	.word	0x20000b38
	...

08007780 <chThdDequeueNextI>:
 * @param[in] tqp       pointer to the threads queue object
 * @param[in] msg       the message code
 *
 * @iclass
 */
void chThdDequeueNextI(threads_queue_t *tqp, msg_t msg) {
 8007780:	b500      	push	{lr}
 8007782:	b083      	sub	sp, #12
 8007784:	9001      	str	r0, [sp, #4]
 8007786:	9100      	str	r1, [sp, #0]

  if (queue_notempty(tqp)) {
 8007788:	9801      	ldr	r0, [sp, #4]
 800778a:	f7ff fd19 	bl	80071c0 <queue_notempty.lto_priv.613>
 800778e:	4603      	mov	r3, r0
 8007790:	2b00      	cmp	r3, #0
 8007792:	d003      	beq.n	800779c <chThdDequeueNextI+0x1c>
    chThdDoDequeueNextI(tqp, msg);
 8007794:	9900      	ldr	r1, [sp, #0]
 8007796:	9801      	ldr	r0, [sp, #4]
 8007798:	f7ff fdaa 	bl	80072f0 <chThdDoDequeueNextI>
  }
}
 800779c:	b003      	add	sp, #12
 800779e:	f85d fb04 	ldr.w	pc, [sp], #4
 80077a2:	bf00      	nop
	...

080077b0 <chThdDequeueAllI>:
 * @param[in] tqp       pointer to the threads queue object
 * @param[in] msg       the message code
 *
 * @iclass
 */
void chThdDequeueAllI(threads_queue_t *tqp, msg_t msg) {
 80077b0:	b500      	push	{lr}
 80077b2:	b083      	sub	sp, #12
 80077b4:	9001      	str	r0, [sp, #4]
 80077b6:	9100      	str	r1, [sp, #0]
 80077b8:	e003      	b.n	80077c2 <chThdDequeueAllI+0x12>

  while (queue_notempty(tqp)) {
    chThdDoDequeueNextI(tqp, msg);
 80077ba:	9900      	ldr	r1, [sp, #0]
 80077bc:	9801      	ldr	r0, [sp, #4]
 80077be:	f7ff fd97 	bl	80072f0 <chThdDoDequeueNextI>
  while (queue_notempty(tqp)) {
 80077c2:	9801      	ldr	r0, [sp, #4]
 80077c4:	f7ff fcfc 	bl	80071c0 <queue_notempty.lto_priv.613>
 80077c8:	4603      	mov	r3, r0
 80077ca:	2b00      	cmp	r3, #0
 80077cc:	d1f5      	bne.n	80077ba <chThdDequeueAllI+0xa>
  }
}
 80077ce:	b003      	add	sp, #12
 80077d0:	f85d fb04 	ldr.w	pc, [sp], #4
	...

080077e0 <port_rt_get_counter_value.lto_priv.630>:
  return DWT->CYCCNT;
 80077e0:	4b01      	ldr	r3, [pc, #4]	; (80077e8 <port_rt_get_counter_value.lto_priv.630+0x8>)
 80077e2:	685b      	ldr	r3, [r3, #4]
}
 80077e4:	4618      	mov	r0, r3
 80077e6:	4770      	bx	lr
 80077e8:	e0001000 	.word	0xe0001000
 80077ec:	00000000 	.word	0x00000000

080077f0 <tm_stop>:
/* Module local functions.                                                   */
/*===========================================================================*/

static inline void tm_stop(time_measurement_t *tmp,
                           rtcnt_t now,
                           rtcnt_t offset) {
 80077f0:	e92d 0810 	stmdb	sp!, {r4, fp}
 80077f4:	b084      	sub	sp, #16
 80077f6:	9003      	str	r0, [sp, #12]
 80077f8:	9102      	str	r1, [sp, #8]
 80077fa:	9201      	str	r2, [sp, #4]

  tmp->n++;
 80077fc:	9b03      	ldr	r3, [sp, #12]
 80077fe:	68db      	ldr	r3, [r3, #12]
 8007800:	1c5a      	adds	r2, r3, #1
 8007802:	9b03      	ldr	r3, [sp, #12]
 8007804:	60da      	str	r2, [r3, #12]
  tmp->last = (now - tmp->last) - offset;
 8007806:	9b03      	ldr	r3, [sp, #12]
 8007808:	689b      	ldr	r3, [r3, #8]
 800780a:	9a02      	ldr	r2, [sp, #8]
 800780c:	1ad2      	subs	r2, r2, r3
 800780e:	9b01      	ldr	r3, [sp, #4]
 8007810:	1ad2      	subs	r2, r2, r3
 8007812:	9b03      	ldr	r3, [sp, #12]
 8007814:	609a      	str	r2, [r3, #8]
  tmp->cumulative += (rttime_t)tmp->last;
 8007816:	9b03      	ldr	r3, [sp, #12]
 8007818:	e9d3 1204 	ldrd	r1, r2, [r3, #16]
 800781c:	9b03      	ldr	r3, [sp, #12]
 800781e:	689b      	ldr	r3, [r3, #8]
 8007820:	469b      	mov	fp, r3
 8007822:	f04f 0c00 	mov.w	ip, #0
 8007826:	eb1b 0301 	adds.w	r3, fp, r1
 800782a:	eb4c 0402 	adc.w	r4, ip, r2
 800782e:	9a03      	ldr	r2, [sp, #12]
 8007830:	e9c2 3404 	strd	r3, r4, [r2, #16]
  if (tmp->last > tmp->worst) {
 8007834:	9b03      	ldr	r3, [sp, #12]
 8007836:	689a      	ldr	r2, [r3, #8]
 8007838:	9b03      	ldr	r3, [sp, #12]
 800783a:	685b      	ldr	r3, [r3, #4]
 800783c:	429a      	cmp	r2, r3
 800783e:	d903      	bls.n	8007848 <tm_stop+0x58>
    tmp->worst = tmp->last;
 8007840:	9b03      	ldr	r3, [sp, #12]
 8007842:	689a      	ldr	r2, [r3, #8]
 8007844:	9b03      	ldr	r3, [sp, #12]
 8007846:	605a      	str	r2, [r3, #4]
  }
  if (tmp->last < tmp->best) {
 8007848:	9b03      	ldr	r3, [sp, #12]
 800784a:	689a      	ldr	r2, [r3, #8]
 800784c:	9b03      	ldr	r3, [sp, #12]
 800784e:	681b      	ldr	r3, [r3, #0]
 8007850:	429a      	cmp	r2, r3
 8007852:	d203      	bcs.n	800785c <tm_stop+0x6c>
    tmp->best = tmp->last;
 8007854:	9b03      	ldr	r3, [sp, #12]
 8007856:	689a      	ldr	r2, [r3, #8]
 8007858:	9b03      	ldr	r3, [sp, #12]
 800785a:	601a      	str	r2, [r3, #0]
  }
}
 800785c:	b004      	add	sp, #16
 800785e:	e8bd 0810 	ldmia.w	sp!, {r4, fp}
 8007862:	4770      	bx	lr
	...

08007870 <_tm_init>:
/**
 * @brief   Initializes the time measurement unit.
 *
 * @init
 */
void _tm_init(void) {
 8007870:	b500      	push	{lr}
 8007872:	b087      	sub	sp, #28
  time_measurement_t tm;

  /* Time Measurement subsystem calibration, it does a null measurement
     and calculates the call overhead which is subtracted to real
     measurements.*/
  ch.tm.offset = (rtcnt_t)0;
 8007874:	4b0b      	ldr	r3, [pc, #44]	; (80078a4 <_tm_init+0x34>)
 8007876:	2200      	movs	r2, #0
 8007878:	f8c3 2884 	str.w	r2, [r3, #2180]	; 0x884
  chTMObjectInit(&tm);
 800787c:	466b      	mov	r3, sp
 800787e:	4618      	mov	r0, r3
 8007880:	f000 f816 	bl	80078b0 <chTMObjectInit>
  chTMStartMeasurementX(&tm);
 8007884:	466b      	mov	r3, sp
 8007886:	4618      	mov	r0, r3
 8007888:	f000 f832 	bl	80078f0 <chTMStartMeasurementX>
  chTMStopMeasurementX(&tm);
 800788c:	466b      	mov	r3, sp
 800788e:	4618      	mov	r0, r3
 8007890:	f000 f83e 	bl	8007910 <chTMStopMeasurementX>
  ch.tm.offset = tm.last;
 8007894:	9b02      	ldr	r3, [sp, #8]
 8007896:	4a03      	ldr	r2, [pc, #12]	; (80078a4 <_tm_init+0x34>)
 8007898:	f8c2 3884 	str.w	r3, [r2, #2180]	; 0x884
}
 800789c:	b007      	add	sp, #28
 800789e:	f85d fb04 	ldr.w	pc, [sp], #4
 80078a2:	bf00      	nop
 80078a4:	20000b38 	.word	0x20000b38
	...

080078b0 <chTMObjectInit>:
 *
 * @param[out] tmp      pointer to a @p TimeMeasurement structure
 *
 * @init
 */
void chTMObjectInit(time_measurement_t *tmp) {
 80078b0:	b410      	push	{r4}
 80078b2:	b083      	sub	sp, #12
 80078b4:	9001      	str	r0, [sp, #4]

  tmp->best       = (rtcnt_t)-1;
 80078b6:	9b01      	ldr	r3, [sp, #4]
 80078b8:	f04f 32ff 	mov.w	r2, #4294967295
 80078bc:	601a      	str	r2, [r3, #0]
  tmp->worst      = (rtcnt_t)0;
 80078be:	9b01      	ldr	r3, [sp, #4]
 80078c0:	2200      	movs	r2, #0
 80078c2:	605a      	str	r2, [r3, #4]
  tmp->last       = (rtcnt_t)0;
 80078c4:	9b01      	ldr	r3, [sp, #4]
 80078c6:	2200      	movs	r2, #0
 80078c8:	609a      	str	r2, [r3, #8]
  tmp->n          = (ucnt_t)0;
 80078ca:	9b01      	ldr	r3, [sp, #4]
 80078cc:	2200      	movs	r2, #0
 80078ce:	60da      	str	r2, [r3, #12]
  tmp->cumulative = (rttime_t)0;
 80078d0:	9a01      	ldr	r2, [sp, #4]
 80078d2:	f04f 0300 	mov.w	r3, #0
 80078d6:	f04f 0400 	mov.w	r4, #0
 80078da:	e9c2 3404 	strd	r3, r4, [r2, #16]
}
 80078de:	b003      	add	sp, #12
 80078e0:	bc10      	pop	{r4}
 80078e2:	4770      	bx	lr
	...

080078f0 <chTMStartMeasurementX>:
 *
 * @param[in,out] tmp   pointer to a @p TimeMeasurement structure
 *
 * @xclass
 */
NOINLINE void chTMStartMeasurementX(time_measurement_t *tmp) {
 80078f0:	b500      	push	{lr}
 80078f2:	b083      	sub	sp, #12
 80078f4:	9001      	str	r0, [sp, #4]

  tmp->last = chSysGetRealtimeCounterX();
 80078f6:	f7ff ff73 	bl	80077e0 <port_rt_get_counter_value.lto_priv.630>
 80078fa:	4602      	mov	r2, r0
 80078fc:	9b01      	ldr	r3, [sp, #4]
 80078fe:	609a      	str	r2, [r3, #8]
}
 8007900:	b003      	add	sp, #12
 8007902:	f85d fb04 	ldr.w	pc, [sp], #4
 8007906:	bf00      	nop
	...

08007910 <chTMStopMeasurementX>:
 *
 * @param[in,out] tmp   pointer to a @p time_measurement_t structure
 *
 * @xclass
 */
NOINLINE void chTMStopMeasurementX(time_measurement_t *tmp) {
 8007910:	b500      	push	{lr}
 8007912:	b083      	sub	sp, #12
 8007914:	9001      	str	r0, [sp, #4]

  tm_stop(tmp, chSysGetRealtimeCounterX(), ch.tm.offset);
 8007916:	f7ff ff63 	bl	80077e0 <port_rt_get_counter_value.lto_priv.630>
 800791a:	4601      	mov	r1, r0
 800791c:	4b04      	ldr	r3, [pc, #16]	; (8007930 <chTMStopMeasurementX+0x20>)
 800791e:	f8d3 3884 	ldr.w	r3, [r3, #2180]	; 0x884
 8007922:	461a      	mov	r2, r3
 8007924:	9801      	ldr	r0, [sp, #4]
 8007926:	f7ff ff63 	bl	80077f0 <tm_stop>
}
 800792a:	b003      	add	sp, #12
 800792c:	f85d fb04 	ldr.w	pc, [sp], #4
 8007930:	20000b38 	.word	0x20000b38
	...

08007940 <port_lock.lto_priv.303>:
static inline void port_lock(void) {
 8007940:	b082      	sub	sp, #8
 8007942:	2320      	movs	r3, #32
 8007944:	9301      	str	r3, [sp, #4]
 8007946:	9b01      	ldr	r3, [sp, #4]
 8007948:	f383 8811 	msr	BASEPRI, r3
}
 800794c:	b002      	add	sp, #8
 800794e:	4770      	bx	lr

08007950 <port_unlock.lto_priv.262>:
static inline void port_unlock(void) {
 8007950:	b082      	sub	sp, #8
 8007952:	2300      	movs	r3, #0
 8007954:	9301      	str	r3, [sp, #4]
 8007956:	9b01      	ldr	r3, [sp, #4]
 8007958:	f383 8811 	msr	BASEPRI, r3
}
 800795c:	b002      	add	sp, #8
 800795e:	4770      	bx	lr

08007960 <chSysLock.lto_priv.411>:
static inline void chSysLock(void) {
 8007960:	b508      	push	{r3, lr}
  port_lock();
 8007962:	f7ff ffed 	bl	8007940 <port_lock.lto_priv.303>
  _dbg_check_lock();
 8007966:	f7fe fd63 	bl	8006430 <_dbg_check_lock>
}
 800796a:	bd08      	pop	{r3, pc}
 800796c:	0000      	movs	r0, r0
	...

08007970 <chSysUnlock.lto_priv.378>:
static inline void chSysUnlock(void) {
 8007970:	b508      	push	{r3, lr}
  _dbg_check_unlock();
 8007972:	f7fe fd75 	bl	8006460 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8007976:	4b09      	ldr	r3, [pc, #36]	; (800799c <chSysUnlock.lto_priv.378+0x2c>)
 8007978:	681b      	ldr	r3, [r3, #0]
 800797a:	4a08      	ldr	r2, [pc, #32]	; (800799c <chSysUnlock.lto_priv.378+0x2c>)
 800797c:	4293      	cmp	r3, r2
 800797e:	d00a      	beq.n	8007996 <chSysUnlock.lto_priv.378+0x26>
 8007980:	4b06      	ldr	r3, [pc, #24]	; (800799c <chSysUnlock.lto_priv.378+0x2c>)
 8007982:	699b      	ldr	r3, [r3, #24]
 8007984:	689a      	ldr	r2, [r3, #8]
 8007986:	4b05      	ldr	r3, [pc, #20]	; (800799c <chSysUnlock.lto_priv.378+0x2c>)
 8007988:	681b      	ldr	r3, [r3, #0]
 800798a:	689b      	ldr	r3, [r3, #8]
 800798c:	429a      	cmp	r2, r3
 800798e:	d202      	bcs.n	8007996 <chSysUnlock.lto_priv.378+0x26>
 8007990:	4803      	ldr	r0, [pc, #12]	; (80079a0 <chSysUnlock.lto_priv.378+0x30>)
 8007992:	f7fe fccd 	bl	8006330 <chSysHalt>
  port_unlock();
 8007996:	f7ff ffdb 	bl	8007950 <port_unlock.lto_priv.262>
}
 800799a:	bd08      	pop	{r3, pc}
 800799c:	20000b38 	.word	0x20000b38
 80079a0:	08009714 	.word	0x08009714
	...

080079b0 <chThdGetWorkingAreaX.lto_priv.627>:
static inline stkalign_t *chThdGetWorkingAreaX(thread_t *tp) {
 80079b0:	b082      	sub	sp, #8
 80079b2:	9001      	str	r0, [sp, #4]
  return tp->wabase;
 80079b4:	9b01      	ldr	r3, [sp, #4]
 80079b6:	69db      	ldr	r3, [r3, #28]
}
 80079b8:	4618      	mov	r0, r3
 80079ba:	b002      	add	sp, #8
 80079bc:	4770      	bx	lr
 80079be:	bf00      	nop

080079c0 <chRegFirstThread>:
 *
 * @return              A reference to the most ancient thread.
 *
 * @api
 */
thread_t *chRegFirstThread(void) {
 80079c0:	b500      	push	{lr}
 80079c2:	b083      	sub	sp, #12
  thread_t *tp;

  chSysLock();
 80079c4:	f7ff ffcc 	bl	8007960 <chSysLock.lto_priv.411>
  tp = ch.rlist.newer;
 80079c8:	4b08      	ldr	r3, [pc, #32]	; (80079ec <chRegFirstThread+0x2c>)
 80079ca:	691b      	ldr	r3, [r3, #16]
 80079cc:	9301      	str	r3, [sp, #4]
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->refs++;
 80079ce:	9b01      	ldr	r3, [sp, #4]
 80079d0:	f893 3022 	ldrb.w	r3, [r3, #34]	; 0x22
 80079d4:	3301      	adds	r3, #1
 80079d6:	b2da      	uxtb	r2, r3
 80079d8:	9b01      	ldr	r3, [sp, #4]
 80079da:	f883 2022 	strb.w	r2, [r3, #34]	; 0x22
#endif
  chSysUnlock();
 80079de:	f7ff ffc7 	bl	8007970 <chSysUnlock.lto_priv.378>

  return tp;
 80079e2:	9b01      	ldr	r3, [sp, #4]
}
 80079e4:	4618      	mov	r0, r3
 80079e6:	b003      	add	sp, #12
 80079e8:	f85d fb04 	ldr.w	pc, [sp], #4
 80079ec:	20000b38 	.word	0x20000b38

080079f0 <chRegNextThread>:
 * @return              A reference to the next thread.
 * @retval NULL         if there is no next thread.
 *
 * @api
 */
thread_t *chRegNextThread(thread_t *tp) {
 80079f0:	b500      	push	{lr}
 80079f2:	b085      	sub	sp, #20
 80079f4:	9001      	str	r0, [sp, #4]
  thread_t *ntp;

  chSysLock();
 80079f6:	f7ff ffb3 	bl	8007960 <chSysLock.lto_priv.411>
  ntp = tp->newer;
 80079fa:	9b01      	ldr	r3, [sp, #4]
 80079fc:	691b      	ldr	r3, [r3, #16]
 80079fe:	9303      	str	r3, [sp, #12]
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  if (ntp == (thread_t *)&ch.rlist) {
 8007a00:	9b03      	ldr	r3, [sp, #12]
 8007a02:	4a10      	ldr	r2, [pc, #64]	; (8007a44 <chRegNextThread+0x54>)
 8007a04:	4293      	cmp	r3, r2
 8007a06:	d102      	bne.n	8007a0e <chRegNextThread+0x1e>
  /*lint -restore*/
    ntp = NULL;
 8007a08:	2300      	movs	r3, #0
 8007a0a:	9303      	str	r3, [sp, #12]
 8007a0c:	e00f      	b.n	8007a2e <chRegNextThread+0x3e>
  }
#if CH_CFG_USE_DYNAMIC == TRUE
  else {
    chDbgAssert(ntp->refs < (trefs_t)255, "too many references");
 8007a0e:	9b03      	ldr	r3, [sp, #12]
 8007a10:	f893 3022 	ldrb.w	r3, [r3, #34]	; 0x22
 8007a14:	2bff      	cmp	r3, #255	; 0xff
 8007a16:	d102      	bne.n	8007a1e <chRegNextThread+0x2e>
 8007a18:	480b      	ldr	r0, [pc, #44]	; (8007a48 <chRegNextThread+0x58>)
 8007a1a:	f7fe fc89 	bl	8006330 <chSysHalt>
    ntp->refs++;
 8007a1e:	9b03      	ldr	r3, [sp, #12]
 8007a20:	f893 3022 	ldrb.w	r3, [r3, #34]	; 0x22
 8007a24:	3301      	adds	r3, #1
 8007a26:	b2da      	uxtb	r2, r3
 8007a28:	9b03      	ldr	r3, [sp, #12]
 8007a2a:	f883 2022 	strb.w	r2, [r3, #34]	; 0x22
  }
#endif
  chSysUnlock();
 8007a2e:	f7ff ff9f 	bl	8007970 <chSysUnlock.lto_priv.378>
#if CH_CFG_USE_DYNAMIC == TRUE
  chThdRelease(tp);
 8007a32:	9801      	ldr	r0, [sp, #4]
 8007a34:	f7ff fdd4 	bl	80075e0 <chThdRelease>
#endif

  return ntp;
 8007a38:	9b03      	ldr	r3, [sp, #12]
}
 8007a3a:	4618      	mov	r0, r3
 8007a3c:	b005      	add	sp, #20
 8007a3e:	f85d fb04 	ldr.w	pc, [sp], #4
 8007a42:	bf00      	nop
 8007a44:	20000b38 	.word	0x20000b38
 8007a48:	08009720 	.word	0x08009720
 8007a4c:	00000000 	.word	0x00000000

08007a50 <chRegFindThreadByWorkingArea>:
 * @return              A pointer to the found thread.
 * @retval NULL         if a matching thread has not been found.
 *
 * @api
 */
thread_t *chRegFindThreadByWorkingArea(stkalign_t *wa) {
 8007a50:	b500      	push	{lr}
 8007a52:	b085      	sub	sp, #20
 8007a54:	9001      	str	r0, [sp, #4]
  thread_t *ctp;

  /* Scanning registry.*/
  ctp = chRegFirstThread();
 8007a56:	f7ff ffb3 	bl	80079c0 <chRegFirstThread>
 8007a5a:	9003      	str	r0, [sp, #12]
  do {
    if (chThdGetWorkingAreaX(ctp) == wa) {
 8007a5c:	9803      	ldr	r0, [sp, #12]
 8007a5e:	f7ff ffa7 	bl	80079b0 <chThdGetWorkingAreaX.lto_priv.627>
 8007a62:	4602      	mov	r2, r0
 8007a64:	9b01      	ldr	r3, [sp, #4]
 8007a66:	4293      	cmp	r3, r2
 8007a68:	d101      	bne.n	8007a6e <chRegFindThreadByWorkingArea+0x1e>
      return ctp;
 8007a6a:	9b03      	ldr	r3, [sp, #12]
 8007a6c:	e007      	b.n	8007a7e <chRegFindThreadByWorkingArea+0x2e>
    }
    ctp = chRegNextThread(ctp);
 8007a6e:	9803      	ldr	r0, [sp, #12]
 8007a70:	f7ff ffbe 	bl	80079f0 <chRegNextThread>
 8007a74:	9003      	str	r0, [sp, #12]
  } while (ctp != NULL);
 8007a76:	9b03      	ldr	r3, [sp, #12]
 8007a78:	2b00      	cmp	r3, #0
 8007a7a:	d1ef      	bne.n	8007a5c <chRegFindThreadByWorkingArea+0xc>

  return NULL;
 8007a7c:	2300      	movs	r3, #0
}
 8007a7e:	4618      	mov	r0, r3
 8007a80:	b005      	add	sp, #20
 8007a82:	f85d fb04 	ldr.w	pc, [sp], #4
 8007a86:	bf00      	nop
	...

08007a90 <port_lock.lto_priv.305>:
static inline void port_lock(void) {
 8007a90:	b082      	sub	sp, #8
 8007a92:	2320      	movs	r3, #32
 8007a94:	9301      	str	r3, [sp, #4]
 8007a96:	9b01      	ldr	r3, [sp, #4]
 8007a98:	f383 8811 	msr	BASEPRI, r3
}
 8007a9c:	b002      	add	sp, #8
 8007a9e:	4770      	bx	lr

08007aa0 <port_unlock.lto_priv.264>:
static inline void port_unlock(void) {
 8007aa0:	b082      	sub	sp, #8
 8007aa2:	2300      	movs	r3, #0
 8007aa4:	9301      	str	r3, [sp, #4]
 8007aa6:	9b01      	ldr	r3, [sp, #4]
 8007aa8:	f383 8811 	msr	BASEPRI, r3
}
 8007aac:	b002      	add	sp, #8
 8007aae:	4770      	bx	lr

08007ab0 <queue_init.lto_priv.595>:
static inline void queue_init(threads_queue_t *tqp) {
 8007ab0:	b082      	sub	sp, #8
 8007ab2:	9001      	str	r0, [sp, #4]
  tqp->next = (thread_t *)tqp;
 8007ab4:	9b01      	ldr	r3, [sp, #4]
 8007ab6:	9a01      	ldr	r2, [sp, #4]
 8007ab8:	601a      	str	r2, [r3, #0]
  tqp->prev = (thread_t *)tqp;
 8007aba:	9b01      	ldr	r3, [sp, #4]
 8007abc:	9a01      	ldr	r2, [sp, #4]
 8007abe:	605a      	str	r2, [r3, #4]
}
 8007ac0:	b002      	add	sp, #8
 8007ac2:	4770      	bx	lr
	...

08007ad0 <queue_notempty.lto_priv.615>:
static inline bool queue_notempty(const threads_queue_t *tqp) {
 8007ad0:	b082      	sub	sp, #8
 8007ad2:	9001      	str	r0, [sp, #4]
  return (bool)(tqp->next != (const thread_t *)tqp);
 8007ad4:	9b01      	ldr	r3, [sp, #4]
 8007ad6:	681b      	ldr	r3, [r3, #0]
 8007ad8:	9a01      	ldr	r2, [sp, #4]
 8007ada:	429a      	cmp	r2, r3
 8007adc:	bf14      	ite	ne
 8007ade:	2301      	movne	r3, #1
 8007ae0:	2300      	moveq	r3, #0
 8007ae2:	b2db      	uxtb	r3, r3
}
 8007ae4:	4618      	mov	r0, r3
 8007ae6:	b002      	add	sp, #8
 8007ae8:	4770      	bx	lr
 8007aea:	bf00      	nop
 8007aec:	0000      	movs	r0, r0
	...

08007af0 <queue_prio_insert.lto_priv.611>:
static inline void queue_prio_insert(thread_t *tp, threads_queue_t *tqp) {
 8007af0:	b084      	sub	sp, #16
 8007af2:	9001      	str	r0, [sp, #4]
 8007af4:	9100      	str	r1, [sp, #0]
  thread_t *cp = (thread_t *)tqp;
 8007af6:	9b00      	ldr	r3, [sp, #0]
 8007af8:	9303      	str	r3, [sp, #12]
    cp = cp->queue.next;
 8007afa:	9b03      	ldr	r3, [sp, #12]
 8007afc:	681b      	ldr	r3, [r3, #0]
 8007afe:	9303      	str	r3, [sp, #12]
  } while ((cp != (thread_t *)tqp) && (cp->prio >= tp->prio));
 8007b00:	9a03      	ldr	r2, [sp, #12]
 8007b02:	9b00      	ldr	r3, [sp, #0]
 8007b04:	429a      	cmp	r2, r3
 8007b06:	d005      	beq.n	8007b14 <queue_prio_insert.lto_priv.611+0x24>
 8007b08:	9b03      	ldr	r3, [sp, #12]
 8007b0a:	689a      	ldr	r2, [r3, #8]
 8007b0c:	9b01      	ldr	r3, [sp, #4]
 8007b0e:	689b      	ldr	r3, [r3, #8]
 8007b10:	429a      	cmp	r2, r3
 8007b12:	d2f2      	bcs.n	8007afa <queue_prio_insert.lto_priv.611+0xa>
  tp->queue.next             = cp;
 8007b14:	9b01      	ldr	r3, [sp, #4]
 8007b16:	9a03      	ldr	r2, [sp, #12]
 8007b18:	601a      	str	r2, [r3, #0]
  tp->queue.prev             = cp->queue.prev;
 8007b1a:	9b03      	ldr	r3, [sp, #12]
 8007b1c:	685a      	ldr	r2, [r3, #4]
 8007b1e:	9b01      	ldr	r3, [sp, #4]
 8007b20:	605a      	str	r2, [r3, #4]
  tp->queue.prev->queue.next = tp;
 8007b22:	9b01      	ldr	r3, [sp, #4]
 8007b24:	685b      	ldr	r3, [r3, #4]
 8007b26:	9a01      	ldr	r2, [sp, #4]
 8007b28:	601a      	str	r2, [r3, #0]
  cp->queue.prev             = tp;
 8007b2a:	9b03      	ldr	r3, [sp, #12]
 8007b2c:	9a01      	ldr	r2, [sp, #4]
 8007b2e:	605a      	str	r2, [r3, #4]
}
 8007b30:	b004      	add	sp, #16
 8007b32:	4770      	bx	lr
	...

08007b40 <queue_fifo_remove.lto_priv.601>:
static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
 8007b40:	b084      	sub	sp, #16
 8007b42:	9001      	str	r0, [sp, #4]
  thread_t *tp = tqp->next;
 8007b44:	9b01      	ldr	r3, [sp, #4]
 8007b46:	681b      	ldr	r3, [r3, #0]
 8007b48:	9303      	str	r3, [sp, #12]
  tqp->next             = tp->queue.next;
 8007b4a:	9b03      	ldr	r3, [sp, #12]
 8007b4c:	681a      	ldr	r2, [r3, #0]
 8007b4e:	9b01      	ldr	r3, [sp, #4]
 8007b50:	601a      	str	r2, [r3, #0]
  tqp->next->queue.prev = (thread_t *)tqp;
 8007b52:	9b01      	ldr	r3, [sp, #4]
 8007b54:	681b      	ldr	r3, [r3, #0]
 8007b56:	9a01      	ldr	r2, [sp, #4]
 8007b58:	605a      	str	r2, [r3, #4]
  return tp;
 8007b5a:	9b03      	ldr	r3, [sp, #12]
}
 8007b5c:	4618      	mov	r0, r3
 8007b5e:	b004      	add	sp, #16
 8007b60:	4770      	bx	lr
 8007b62:	bf00      	nop
	...

08007b70 <queue_dequeue.lto_priv.620>:
static inline thread_t *queue_dequeue(thread_t *tp) {
 8007b70:	b082      	sub	sp, #8
 8007b72:	9001      	str	r0, [sp, #4]
  tp->queue.prev->queue.next = tp->queue.next;
 8007b74:	9b01      	ldr	r3, [sp, #4]
 8007b76:	685b      	ldr	r3, [r3, #4]
 8007b78:	9a01      	ldr	r2, [sp, #4]
 8007b7a:	6812      	ldr	r2, [r2, #0]
 8007b7c:	601a      	str	r2, [r3, #0]
  tp->queue.next->queue.prev = tp->queue.prev;
 8007b7e:	9b01      	ldr	r3, [sp, #4]
 8007b80:	681b      	ldr	r3, [r3, #0]
 8007b82:	9a01      	ldr	r2, [sp, #4]
 8007b84:	6852      	ldr	r2, [r2, #4]
 8007b86:	605a      	str	r2, [r3, #4]
  return tp;
 8007b88:	9b01      	ldr	r3, [sp, #4]
}
 8007b8a:	4618      	mov	r0, r3
 8007b8c:	b002      	add	sp, #8
 8007b8e:	4770      	bx	lr

08007b90 <chSysLock.lto_priv.413>:
static inline void chSysLock(void) {
 8007b90:	b508      	push	{r3, lr}
  port_lock();
 8007b92:	f7ff ff7d 	bl	8007a90 <port_lock.lto_priv.305>
  _dbg_check_lock();
 8007b96:	f7fe fc4b 	bl	8006430 <_dbg_check_lock>
}
 8007b9a:	bd08      	pop	{r3, pc}
 8007b9c:	0000      	movs	r0, r0
	...

08007ba0 <chSysUnlock.lto_priv.380>:
static inline void chSysUnlock(void) {
 8007ba0:	b508      	push	{r3, lr}
  _dbg_check_unlock();
 8007ba2:	f7fe fc5d 	bl	8006460 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8007ba6:	4b09      	ldr	r3, [pc, #36]	; (8007bcc <chSysUnlock.lto_priv.380+0x2c>)
 8007ba8:	681b      	ldr	r3, [r3, #0]
 8007baa:	4a08      	ldr	r2, [pc, #32]	; (8007bcc <chSysUnlock.lto_priv.380+0x2c>)
 8007bac:	4293      	cmp	r3, r2
 8007bae:	d00a      	beq.n	8007bc6 <chSysUnlock.lto_priv.380+0x26>
 8007bb0:	4b06      	ldr	r3, [pc, #24]	; (8007bcc <chSysUnlock.lto_priv.380+0x2c>)
 8007bb2:	699b      	ldr	r3, [r3, #24]
 8007bb4:	689a      	ldr	r2, [r3, #8]
 8007bb6:	4b05      	ldr	r3, [pc, #20]	; (8007bcc <chSysUnlock.lto_priv.380+0x2c>)
 8007bb8:	681b      	ldr	r3, [r3, #0]
 8007bba:	689b      	ldr	r3, [r3, #8]
 8007bbc:	429a      	cmp	r2, r3
 8007bbe:	d202      	bcs.n	8007bc6 <chSysUnlock.lto_priv.380+0x26>
 8007bc0:	4803      	ldr	r0, [pc, #12]	; (8007bd0 <chSysUnlock.lto_priv.380+0x30>)
 8007bc2:	f7fe fbb5 	bl	8006330 <chSysHalt>
  port_unlock();
 8007bc6:	f7ff ff6b 	bl	8007aa0 <port_unlock.lto_priv.264>
}
 8007bca:	bd08      	pop	{r3, pc}
 8007bcc:	20000b38 	.word	0x20000b38
 8007bd0:	08009740 	.word	0x08009740
	...

08007be0 <chMtxQueueNotEmptyS>:
 * @param[out] mp       pointer to a @p mutex_t structure
 * @return              The mutex queue status.
 *
 * @sclass
 */
static inline bool chMtxQueueNotEmptyS(mutex_t *mp) {
 8007be0:	b500      	push	{lr}
 8007be2:	b083      	sub	sp, #12
 8007be4:	9001      	str	r0, [sp, #4]

  chDbgCheckClassS();
 8007be6:	f7fe fcdb 	bl	80065a0 <chDbgCheckClassS>

  return queue_notempty(&mp->queue);
 8007bea:	9b01      	ldr	r3, [sp, #4]
 8007bec:	4618      	mov	r0, r3
 8007bee:	f7ff ff6f 	bl	8007ad0 <queue_notempty.lto_priv.615>
 8007bf2:	4603      	mov	r3, r0
}
 8007bf4:	4618      	mov	r0, r3
 8007bf6:	b003      	add	sp, #12
 8007bf8:	f85d fb04 	ldr.w	pc, [sp], #4
 8007bfc:	0000      	movs	r0, r0
	...

08007c00 <chMtxObjectInit>:
 *
 * @param[out] mp       pointer to a @p mutex_t structure
 *
 * @init
 */
void chMtxObjectInit(mutex_t *mp) {
 8007c00:	b500      	push	{lr}
 8007c02:	b083      	sub	sp, #12
 8007c04:	9001      	str	r0, [sp, #4]

  chDbgCheck(mp != NULL);
 8007c06:	9b01      	ldr	r3, [sp, #4]
 8007c08:	2b00      	cmp	r3, #0
 8007c0a:	d102      	bne.n	8007c12 <chMtxObjectInit+0x12>
 8007c0c:	4806      	ldr	r0, [pc, #24]	; (8007c28 <chMtxObjectInit+0x28>)
 8007c0e:	f7fe fb8f 	bl	8006330 <chSysHalt>

  queue_init(&mp->queue);
 8007c12:	9b01      	ldr	r3, [sp, #4]
 8007c14:	4618      	mov	r0, r3
 8007c16:	f7ff ff4b 	bl	8007ab0 <queue_init.lto_priv.595>
  mp->owner = NULL;
 8007c1a:	9b01      	ldr	r3, [sp, #4]
 8007c1c:	2200      	movs	r2, #0
 8007c1e:	609a      	str	r2, [r3, #8]
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
  mp->cnt = (cnt_t)0;
#endif
}
 8007c20:	b003      	add	sp, #12
 8007c22:	f85d fb04 	ldr.w	pc, [sp], #4
 8007c26:	bf00      	nop
 8007c28:	08009730 	.word	0x08009730
 8007c2c:	00000000 	.word	0x00000000

08007c30 <chMtxLock>:
 *
 * @param[in] mp        pointer to the @p mutex_t structure
 *
 * @api
 */
void chMtxLock(mutex_t *mp) {
 8007c30:	b500      	push	{lr}
 8007c32:	b083      	sub	sp, #12
 8007c34:	9001      	str	r0, [sp, #4]

  chSysLock();
 8007c36:	f7ff ffab 	bl	8007b90 <chSysLock.lto_priv.413>
  chMtxLockS(mp);
 8007c3a:	9801      	ldr	r0, [sp, #4]
 8007c3c:	f000 f808 	bl	8007c50 <chMtxLockS>
  chSysUnlock();
 8007c40:	f7ff ffae 	bl	8007ba0 <chSysUnlock.lto_priv.380>
}
 8007c44:	b003      	add	sp, #12
 8007c46:	f85d fb04 	ldr.w	pc, [sp], #4
 8007c4a:	bf00      	nop
 8007c4c:	0000      	movs	r0, r0
	...

08007c50 <chMtxLockS>:
 *
 * @param[in] mp        pointer to the @p mutex_t structure
 *
 * @sclass
 */
void chMtxLockS(mutex_t *mp) {
 8007c50:	b500      	push	{lr}
 8007c52:	b085      	sub	sp, #20
 8007c54:	9001      	str	r0, [sp, #4]
  thread_t *ctp = currp;
 8007c56:	4b3b      	ldr	r3, [pc, #236]	; (8007d44 <chMtxLockS+0xf4>)
 8007c58:	699b      	ldr	r3, [r3, #24]
 8007c5a:	9302      	str	r3, [sp, #8]

  chDbgCheckClassS();
 8007c5c:	f7fe fca0 	bl	80065a0 <chDbgCheckClassS>
  chDbgCheck(mp != NULL);
 8007c60:	9b01      	ldr	r3, [sp, #4]
 8007c62:	2b00      	cmp	r3, #0
 8007c64:	d102      	bne.n	8007c6c <chMtxLockS+0x1c>
 8007c66:	4838      	ldr	r0, [pc, #224]	; (8007d48 <chMtxLockS+0xf8>)
 8007c68:	f7fe fb62 	bl	8006330 <chSysHalt>

  /* Is the mutex already locked? */
  if (mp->owner != NULL) {
 8007c6c:	9b01      	ldr	r3, [sp, #4]
 8007c6e:	689b      	ldr	r3, [r3, #8]
 8007c70:	2b00      	cmp	r3, #0
 8007c72:	d059      	beq.n	8007d28 <chMtxLockS+0xd8>
    else {
#endif
      /* Priority inheritance protocol; explores the thread-mutex dependencies
         boosting the priority of all the affected threads to equal the
         priority of the running thread requesting the mutex.*/
      thread_t *tp = mp->owner;
 8007c74:	9b01      	ldr	r3, [sp, #4]
 8007c76:	689b      	ldr	r3, [r3, #8]
 8007c78:	9303      	str	r3, [sp, #12]
 8007c7a:	e033      	b.n	8007ce4 <chMtxLockS+0x94>

      /* Does the running thread have higher priority than the mutex
         owning thread? */
      while (tp->prio < ctp->prio) {
        /* Make priority of thread tp match the running thread's priority.*/
        tp->prio = ctp->prio;
 8007c7c:	9b02      	ldr	r3, [sp, #8]
 8007c7e:	689a      	ldr	r2, [r3, #8]
 8007c80:	9b03      	ldr	r3, [sp, #12]
 8007c82:	609a      	str	r2, [r3, #8]

        /* The following states need priority queues reordering.*/
        switch (tp->state) {
 8007c84:	9b03      	ldr	r3, [sp, #12]
 8007c86:	f893 3020 	ldrb.w	r3, [r3, #32]
 8007c8a:	2b06      	cmp	r3, #6
 8007c8c:	d004      	beq.n	8007c98 <chMtxLockS+0x48>
 8007c8e:	2b07      	cmp	r3, #7
 8007c90:	d011      	beq.n	8007cb6 <chMtxLockS+0x66>
 8007c92:	2b00      	cmp	r3, #0
 8007c94:	d01a      	beq.n	8007ccc <chMtxLockS+0x7c>
          tp->state = CH_STATE_CURRENT;
#endif
          /* Re-enqueues tp with its new priority on the ready list.*/
          (void) chSchReadyI(queue_dequeue(tp));
          break;
        default:
 8007c96:	e02b      	b.n	8007cf0 <chMtxLockS+0xa0>
          queue_prio_insert(queue_dequeue(tp), &tp->u.wtmtxp->queue);
 8007c98:	9803      	ldr	r0, [sp, #12]
 8007c9a:	f7ff ff69 	bl	8007b70 <queue_dequeue.lto_priv.620>
 8007c9e:	4602      	mov	r2, r0
 8007ca0:	9b03      	ldr	r3, [sp, #12]
 8007ca2:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8007ca4:	4619      	mov	r1, r3
 8007ca6:	4610      	mov	r0, r2
 8007ca8:	f7ff ff22 	bl	8007af0 <queue_prio_insert.lto_priv.611>
          tp = tp->u.wtmtxp->owner;
 8007cac:	9b03      	ldr	r3, [sp, #12]
 8007cae:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8007cb0:	689b      	ldr	r3, [r3, #8]
 8007cb2:	9303      	str	r3, [sp, #12]
 8007cb4:	e016      	b.n	8007ce4 <chMtxLockS+0x94>
          queue_prio_insert(queue_dequeue(tp), &tp->u.wtmtxp->queue);
 8007cb6:	9803      	ldr	r0, [sp, #12]
 8007cb8:	f7ff ff5a 	bl	8007b70 <queue_dequeue.lto_priv.620>
 8007cbc:	4602      	mov	r2, r0
 8007cbe:	9b03      	ldr	r3, [sp, #12]
 8007cc0:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8007cc2:	4619      	mov	r1, r3
 8007cc4:	4610      	mov	r0, r2
 8007cc6:	f7ff ff13 	bl	8007af0 <queue_prio_insert.lto_priv.611>
        default:
 8007cca:	e011      	b.n	8007cf0 <chMtxLockS+0xa0>
          tp->state = CH_STATE_CURRENT;
 8007ccc:	9b03      	ldr	r3, [sp, #12]
 8007cce:	2201      	movs	r2, #1
 8007cd0:	f883 2020 	strb.w	r2, [r3, #32]
          (void) chSchReadyI(queue_dequeue(tp));
 8007cd4:	9803      	ldr	r0, [sp, #12]
 8007cd6:	f7ff ff4b 	bl	8007b70 <queue_dequeue.lto_priv.620>
 8007cda:	4603      	mov	r3, r0
 8007cdc:	4618      	mov	r0, r3
 8007cde:	f7ff f80f 	bl	8006d00 <chSchReadyI>
        default:
 8007ce2:	e005      	b.n	8007cf0 <chMtxLockS+0xa0>
      while (tp->prio < ctp->prio) {
 8007ce4:	9b03      	ldr	r3, [sp, #12]
 8007ce6:	689a      	ldr	r2, [r3, #8]
 8007ce8:	9b02      	ldr	r3, [sp, #8]
 8007cea:	689b      	ldr	r3, [r3, #8]
 8007cec:	429a      	cmp	r2, r3
 8007cee:	d3c5      	bcc.n	8007c7c <chMtxLockS+0x2c>
        }
        break;
      }

      /* Sleep on the mutex.*/
      queue_prio_insert(ctp, &mp->queue);
 8007cf0:	9b01      	ldr	r3, [sp, #4]
 8007cf2:	4619      	mov	r1, r3
 8007cf4:	9802      	ldr	r0, [sp, #8]
 8007cf6:	f7ff fefb 	bl	8007af0 <queue_prio_insert.lto_priv.611>
      ctp->u.wtmtxp = mp;
 8007cfa:	9b02      	ldr	r3, [sp, #8]
 8007cfc:	9a01      	ldr	r2, [sp, #4]
 8007cfe:	625a      	str	r2, [r3, #36]	; 0x24
      chSchGoSleepS(CH_STATE_WTMTX);
 8007d00:	2006      	movs	r0, #6
 8007d02:	f7ff f87d 	bl	8006e00 <chSchGoSleepS>

      /* It is assumed that the thread performing the unlock operation assigns
         the mutex to this thread.*/
      chDbgAssert(mp->owner == ctp, "not owner");
 8007d06:	9b01      	ldr	r3, [sp, #4]
 8007d08:	689b      	ldr	r3, [r3, #8]
 8007d0a:	9a02      	ldr	r2, [sp, #8]
 8007d0c:	429a      	cmp	r2, r3
 8007d0e:	d002      	beq.n	8007d16 <chMtxLockS+0xc6>
 8007d10:	480d      	ldr	r0, [pc, #52]	; (8007d48 <chMtxLockS+0xf8>)
 8007d12:	f7fe fb0d 	bl	8006330 <chSysHalt>
      chDbgAssert(ctp->mtxlist == mp, "not owned");
 8007d16:	9b02      	ldr	r3, [sp, #8]
 8007d18:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8007d1a:	9a01      	ldr	r2, [sp, #4]
 8007d1c:	429a      	cmp	r2, r3
 8007d1e:	d00d      	beq.n	8007d3c <chMtxLockS+0xec>
 8007d20:	4809      	ldr	r0, [pc, #36]	; (8007d48 <chMtxLockS+0xf8>)
 8007d22:	f7fe fb05 	bl	8006330 <chSysHalt>
 8007d26:	e009      	b.n	8007d3c <chMtxLockS+0xec>
    chDbgAssert(mp->cnt == (cnt_t)0, "counter is not zero");

    mp->cnt++;
#endif
    /* It was not owned, inserted in the owned mutexes list.*/
    mp->owner = ctp;
 8007d28:	9b01      	ldr	r3, [sp, #4]
 8007d2a:	9a02      	ldr	r2, [sp, #8]
 8007d2c:	609a      	str	r2, [r3, #8]
    mp->next = ctp->mtxlist;
 8007d2e:	9b02      	ldr	r3, [sp, #8]
 8007d30:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 8007d32:	9b01      	ldr	r3, [sp, #4]
 8007d34:	60da      	str	r2, [r3, #12]
    ctp->mtxlist = mp;
 8007d36:	9b02      	ldr	r3, [sp, #8]
 8007d38:	9a01      	ldr	r2, [sp, #4]
 8007d3a:	639a      	str	r2, [r3, #56]	; 0x38
  }
}
 8007d3c:	b005      	add	sp, #20
 8007d3e:	f85d fb04 	ldr.w	pc, [sp], #4
 8007d42:	bf00      	nop
 8007d44:	20000b38 	.word	0x20000b38
 8007d48:	0800974c 	.word	0x0800974c
 8007d4c:	00000000 	.word	0x00000000

08007d50 <chMtxUnlock>:
 *
 * @param[in] mp        pointer to the @p mutex_t structure
 *
 * @api
 */
void chMtxUnlock(mutex_t *mp) {
 8007d50:	b500      	push	{lr}
 8007d52:	b087      	sub	sp, #28
 8007d54:	9001      	str	r0, [sp, #4]
  thread_t *ctp = currp;
 8007d56:	4b35      	ldr	r3, [pc, #212]	; (8007e2c <chMtxUnlock+0xdc>)
 8007d58:	699b      	ldr	r3, [r3, #24]
 8007d5a:	9303      	str	r3, [sp, #12]
  mutex_t *lmp;

  chDbgCheck(mp != NULL);
 8007d5c:	9b01      	ldr	r3, [sp, #4]
 8007d5e:	2b00      	cmp	r3, #0
 8007d60:	d102      	bne.n	8007d68 <chMtxUnlock+0x18>
 8007d62:	4833      	ldr	r0, [pc, #204]	; (8007e30 <chMtxUnlock+0xe0>)
 8007d64:	f7fe fae4 	bl	8006330 <chSysHalt>

  chSysLock();
 8007d68:	f7ff ff12 	bl	8007b90 <chSysLock.lto_priv.413>

  chDbgAssert(ctp->mtxlist != NULL, "owned mutexes list empty");
 8007d6c:	9b03      	ldr	r3, [sp, #12]
 8007d6e:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8007d70:	2b00      	cmp	r3, #0
 8007d72:	d102      	bne.n	8007d7a <chMtxUnlock+0x2a>
 8007d74:	482e      	ldr	r0, [pc, #184]	; (8007e30 <chMtxUnlock+0xe0>)
 8007d76:	f7fe fadb 	bl	8006330 <chSysHalt>
  chDbgAssert(ctp->mtxlist->owner == ctp, "ownership failure");
 8007d7a:	9b03      	ldr	r3, [sp, #12]
 8007d7c:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8007d7e:	689b      	ldr	r3, [r3, #8]
 8007d80:	9a03      	ldr	r2, [sp, #12]
 8007d82:	429a      	cmp	r2, r3
 8007d84:	d002      	beq.n	8007d8c <chMtxUnlock+0x3c>
 8007d86:	482a      	ldr	r0, [pc, #168]	; (8007e30 <chMtxUnlock+0xe0>)
 8007d88:	f7fe fad2 	bl	8006330 <chSysHalt>
  chDbgAssert(mp->cnt >= (cnt_t)1, "counter is not positive");

  if (--mp->cnt == (cnt_t)0) {
#endif

    chDbgAssert(ctp->mtxlist == mp, "not next in list");
 8007d8c:	9b03      	ldr	r3, [sp, #12]
 8007d8e:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8007d90:	9a01      	ldr	r2, [sp, #4]
 8007d92:	429a      	cmp	r2, r3
 8007d94:	d002      	beq.n	8007d9c <chMtxUnlock+0x4c>
 8007d96:	4826      	ldr	r0, [pc, #152]	; (8007e30 <chMtxUnlock+0xe0>)
 8007d98:	f7fe faca 	bl	8006330 <chSysHalt>

    /* Removes the top mutex from the thread's owned mutexes list and marks
       it as not owned. Note, it is assumed to be the same mutex passed as
       parameter of this function.*/
    ctp->mtxlist = mp->next;
 8007d9c:	9b01      	ldr	r3, [sp, #4]
 8007d9e:	68da      	ldr	r2, [r3, #12]
 8007da0:	9b03      	ldr	r3, [sp, #12]
 8007da2:	639a      	str	r2, [r3, #56]	; 0x38

    /* If a thread is waiting on the mutex then the fun part begins.*/
    if (chMtxQueueNotEmptyS(mp)) {
 8007da4:	9801      	ldr	r0, [sp, #4]
 8007da6:	f7ff ff1b 	bl	8007be0 <chMtxQueueNotEmptyS>
 8007daa:	4603      	mov	r3, r0
 8007dac:	2b00      	cmp	r3, #0
 8007dae:	d034      	beq.n	8007e1a <chMtxUnlock+0xca>
      thread_t *tp;

      /* Recalculates the optimal thread priority by scanning the owned
         mutexes list.*/
      tprio_t newprio = ctp->realprio;
 8007db0:	9b03      	ldr	r3, [sp, #12]
 8007db2:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8007db4:	9304      	str	r3, [sp, #16]
      lmp = ctp->mtxlist;
 8007db6:	9b03      	ldr	r3, [sp, #12]
 8007db8:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8007dba:	9305      	str	r3, [sp, #20]
 8007dbc:	e012      	b.n	8007de4 <chMtxUnlock+0x94>
      while (lmp != NULL) {
        /* If the highest priority thread waiting in the mutexes list has a
           greater priority than the current thread base priority then the
           final priority will have at least that priority.*/
        if (chMtxQueueNotEmptyS(lmp) &&
 8007dbe:	9805      	ldr	r0, [sp, #20]
 8007dc0:	f7ff ff0e 	bl	8007be0 <chMtxQueueNotEmptyS>
 8007dc4:	4603      	mov	r3, r0
 8007dc6:	2b00      	cmp	r3, #0
 8007dc8:	d009      	beq.n	8007dde <chMtxUnlock+0x8e>
            (lmp->queue.next->prio > newprio)) {
 8007dca:	9b05      	ldr	r3, [sp, #20]
 8007dcc:	681b      	ldr	r3, [r3, #0]
 8007dce:	689b      	ldr	r3, [r3, #8]
        if (chMtxQueueNotEmptyS(lmp) &&
 8007dd0:	9a04      	ldr	r2, [sp, #16]
 8007dd2:	429a      	cmp	r2, r3
 8007dd4:	d203      	bcs.n	8007dde <chMtxUnlock+0x8e>
          newprio = lmp->queue.next->prio;
 8007dd6:	9b05      	ldr	r3, [sp, #20]
 8007dd8:	681b      	ldr	r3, [r3, #0]
 8007dda:	689b      	ldr	r3, [r3, #8]
 8007ddc:	9304      	str	r3, [sp, #16]
        }
        lmp = lmp->next;
 8007dde:	9b05      	ldr	r3, [sp, #20]
 8007de0:	68db      	ldr	r3, [r3, #12]
 8007de2:	9305      	str	r3, [sp, #20]
      while (lmp != NULL) {
 8007de4:	9b05      	ldr	r3, [sp, #20]
 8007de6:	2b00      	cmp	r3, #0
 8007de8:	d1e9      	bne.n	8007dbe <chMtxUnlock+0x6e>
      }

      /* Assigns to the current thread the highest priority among all the
         waiting threads.*/
      ctp->prio = newprio;
 8007dea:	9b03      	ldr	r3, [sp, #12]
 8007dec:	9a04      	ldr	r2, [sp, #16]
 8007dee:	609a      	str	r2, [r3, #8]
      /* Awakens the highest priority thread waiting for the unlocked mutex and
         assigns the mutex to it.*/
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
      mp->cnt = (cnt_t)1;
#endif
      tp = queue_fifo_remove(&mp->queue);
 8007df0:	9b01      	ldr	r3, [sp, #4]
 8007df2:	4618      	mov	r0, r3
 8007df4:	f7ff fea4 	bl	8007b40 <queue_fifo_remove.lto_priv.601>
 8007df8:	9002      	str	r0, [sp, #8]
      mp->owner = tp;
 8007dfa:	9b01      	ldr	r3, [sp, #4]
 8007dfc:	9a02      	ldr	r2, [sp, #8]
 8007dfe:	609a      	str	r2, [r3, #8]
      mp->next = tp->mtxlist;
 8007e00:	9b02      	ldr	r3, [sp, #8]
 8007e02:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 8007e04:	9b01      	ldr	r3, [sp, #4]
 8007e06:	60da      	str	r2, [r3, #12]
      tp->mtxlist = mp;
 8007e08:	9b02      	ldr	r3, [sp, #8]
 8007e0a:	9a01      	ldr	r2, [sp, #4]
 8007e0c:	639a      	str	r2, [r3, #56]	; 0x38

      /* Note, not using chSchWakeupS() becuase that function expects the
         current thread to have the higher or equal priority than the ones
         in the ready list. This is not necessarily true here because we
         just changed priority.*/
      (void) chSchReadyI(tp);
 8007e0e:	9802      	ldr	r0, [sp, #8]
 8007e10:	f7fe ff76 	bl	8006d00 <chSchReadyI>
      chSchRescheduleS();
 8007e14:	f7ff f904 	bl	8007020 <chSchRescheduleS>
 8007e18:	e002      	b.n	8007e20 <chMtxUnlock+0xd0>
    }
    else {
      mp->owner = NULL;
 8007e1a:	9b01      	ldr	r3, [sp, #4]
 8007e1c:	2200      	movs	r2, #0
 8007e1e:	609a      	str	r2, [r3, #8]
    }
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
  }
#endif

  chSysUnlock();
 8007e20:	f7ff febe 	bl	8007ba0 <chSysUnlock.lto_priv.380>
}
 8007e24:	b007      	add	sp, #28
 8007e26:	f85d fb04 	ldr.w	pc, [sp], #4
 8007e2a:	bf00      	nop
 8007e2c:	20000b38 	.word	0x20000b38
 8007e30:	08009758 	.word	0x08009758
	...

08007e40 <chEvtBroadcastFlagsI>:
 * @param[in] esp       pointer to the @p event_source_t structure
 * @param[in] flags     the flags set to be added to the listener flags mask
 *
 * @iclass
 */
void chEvtBroadcastFlagsI(event_source_t *esp, eventflags_t flags) {
 8007e40:	b500      	push	{lr}
 8007e42:	b085      	sub	sp, #20
 8007e44:	9001      	str	r0, [sp, #4]
 8007e46:	9100      	str	r1, [sp, #0]
  event_listener_t *elp;

  chDbgCheckClassI();
 8007e48:	f7fe fb92 	bl	8006570 <chDbgCheckClassI>
  chDbgCheck(esp != NULL);
 8007e4c:	9b01      	ldr	r3, [sp, #4]
 8007e4e:	2b00      	cmp	r3, #0
 8007e50:	d102      	bne.n	8007e58 <chEvtBroadcastFlagsI+0x18>
 8007e52:	4814      	ldr	r0, [pc, #80]	; (8007ea4 <chEvtBroadcastFlagsI+0x64>)
 8007e54:	f7fe fa6c 	bl	8006330 <chSysHalt>

  elp = esp->next;
 8007e58:	9b01      	ldr	r3, [sp, #4]
 8007e5a:	681b      	ldr	r3, [r3, #0]
 8007e5c:	9303      	str	r3, [sp, #12]
 8007e5e:	e019      	b.n	8007e94 <chEvtBroadcastFlagsI+0x54>
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  while (elp != (event_listener_t *)esp) {
  /*lint -restore*/
    elp->flags |= flags;
 8007e60:	9b03      	ldr	r3, [sp, #12]
 8007e62:	68da      	ldr	r2, [r3, #12]
 8007e64:	9b00      	ldr	r3, [sp, #0]
 8007e66:	431a      	orrs	r2, r3
 8007e68:	9b03      	ldr	r3, [sp, #12]
 8007e6a:	60da      	str	r2, [r3, #12]
    /* When flags == 0 the thread will always be signaled because the
       source does not emit any flag.*/
    if ((flags == (eventflags_t)0) ||
 8007e6c:	9b00      	ldr	r3, [sp, #0]
 8007e6e:	2b00      	cmp	r3, #0
 8007e70:	d005      	beq.n	8007e7e <chEvtBroadcastFlagsI+0x3e>
        ((flags & elp->wflags) != (eventflags_t)0)) {
 8007e72:	9b03      	ldr	r3, [sp, #12]
 8007e74:	691a      	ldr	r2, [r3, #16]
 8007e76:	9b00      	ldr	r3, [sp, #0]
 8007e78:	4013      	ands	r3, r2
    if ((flags == (eventflags_t)0) ||
 8007e7a:	2b00      	cmp	r3, #0
 8007e7c:	d007      	beq.n	8007e8e <chEvtBroadcastFlagsI+0x4e>
      chEvtSignalI(elp->listener, elp->events);
 8007e7e:	9b03      	ldr	r3, [sp, #12]
 8007e80:	685a      	ldr	r2, [r3, #4]
 8007e82:	9b03      	ldr	r3, [sp, #12]
 8007e84:	689b      	ldr	r3, [r3, #8]
 8007e86:	4619      	mov	r1, r3
 8007e88:	4610      	mov	r0, r2
 8007e8a:	f000 f811 	bl	8007eb0 <chEvtSignalI>
    }
    elp = elp->next;
 8007e8e:	9b03      	ldr	r3, [sp, #12]
 8007e90:	681b      	ldr	r3, [r3, #0]
 8007e92:	9303      	str	r3, [sp, #12]
  while (elp != (event_listener_t *)esp) {
 8007e94:	9a03      	ldr	r2, [sp, #12]
 8007e96:	9b01      	ldr	r3, [sp, #4]
 8007e98:	429a      	cmp	r2, r3
 8007e9a:	d1e1      	bne.n	8007e60 <chEvtBroadcastFlagsI+0x20>
  }
}
 8007e9c:	b005      	add	sp, #20
 8007e9e:	f85d fb04 	ldr.w	pc, [sp], #4
 8007ea2:	bf00      	nop
 8007ea4:	08009764 	.word	0x08009764
	...

08007eb0 <chEvtSignalI>:
 * @param[in] tp        the thread to be signaled
 * @param[in] events    the events set to be ORed
 *
 * @iclass
 */
void chEvtSignalI(thread_t *tp, eventmask_t events) {
 8007eb0:	b500      	push	{lr}
 8007eb2:	b083      	sub	sp, #12
 8007eb4:	9001      	str	r0, [sp, #4]
 8007eb6:	9100      	str	r1, [sp, #0]

  chDbgCheckClassI();
 8007eb8:	f7fe fb5a 	bl	8006570 <chDbgCheckClassI>
  chDbgCheck(tp != NULL);
 8007ebc:	9b01      	ldr	r3, [sp, #4]
 8007ebe:	2b00      	cmp	r3, #0
 8007ec0:	d102      	bne.n	8007ec8 <chEvtSignalI+0x18>
 8007ec2:	4816      	ldr	r0, [pc, #88]	; (8007f1c <chEvtSignalI+0x6c>)
 8007ec4:	f7fe fa34 	bl	8006330 <chSysHalt>

  tp->epending |= events;
 8007ec8:	9b01      	ldr	r3, [sp, #4]
 8007eca:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8007ecc:	9b00      	ldr	r3, [sp, #0]
 8007ece:	431a      	orrs	r2, r3
 8007ed0:	9b01      	ldr	r3, [sp, #4]
 8007ed2:	635a      	str	r2, [r3, #52]	; 0x34
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->state == CH_STATE_WTOREVT) &&
 8007ed4:	9b01      	ldr	r3, [sp, #4]
 8007ed6:	f893 3020 	ldrb.w	r3, [r3, #32]
 8007eda:	2b0a      	cmp	r3, #10
 8007edc:	d106      	bne.n	8007eec <chEvtSignalI+0x3c>
       ((tp->epending & tp->u.ewmask) != (eventmask_t)0)) ||
 8007ede:	9b01      	ldr	r3, [sp, #4]
 8007ee0:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8007ee2:	9b01      	ldr	r3, [sp, #4]
 8007ee4:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8007ee6:	4013      	ands	r3, r2
  if (((tp->state == CH_STATE_WTOREVT) &&
 8007ee8:	2b00      	cmp	r3, #0
 8007eea:	d10d      	bne.n	8007f08 <chEvtSignalI+0x58>
      ((tp->state == CH_STATE_WTANDEVT) &&
 8007eec:	9b01      	ldr	r3, [sp, #4]
 8007eee:	f893 3020 	ldrb.w	r3, [r3, #32]
       ((tp->epending & tp->u.ewmask) != (eventmask_t)0)) ||
 8007ef2:	2b0b      	cmp	r3, #11
 8007ef4:	d10e      	bne.n	8007f14 <chEvtSignalI+0x64>
       ((tp->epending & tp->u.ewmask) == tp->u.ewmask))) {
 8007ef6:	9b01      	ldr	r3, [sp, #4]
 8007ef8:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8007efa:	9b01      	ldr	r3, [sp, #4]
 8007efc:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8007efe:	401a      	ands	r2, r3
 8007f00:	9b01      	ldr	r3, [sp, #4]
 8007f02:	6a5b      	ldr	r3, [r3, #36]	; 0x24
      ((tp->state == CH_STATE_WTANDEVT) &&
 8007f04:	429a      	cmp	r2, r3
 8007f06:	d105      	bne.n	8007f14 <chEvtSignalI+0x64>
    tp->u.rdymsg = MSG_OK;
 8007f08:	9b01      	ldr	r3, [sp, #4]
 8007f0a:	2200      	movs	r2, #0
 8007f0c:	625a      	str	r2, [r3, #36]	; 0x24
    (void) chSchReadyI(tp);
 8007f0e:	9801      	ldr	r0, [sp, #4]
 8007f10:	f7fe fef6 	bl	8006d00 <chSchReadyI>
  }
}
 8007f14:	b003      	add	sp, #12
 8007f16:	f85d fb04 	ldr.w	pc, [sp], #4
 8007f1a:	bf00      	nop
 8007f1c:	0800977c 	.word	0x0800977c

08007f20 <port_lock.lto_priv.311>:
static inline void port_lock(void) {
 8007f20:	b082      	sub	sp, #8
 8007f22:	2320      	movs	r3, #32
 8007f24:	9301      	str	r3, [sp, #4]
 8007f26:	9b01      	ldr	r3, [sp, #4]
 8007f28:	f383 8811 	msr	BASEPRI, r3
}
 8007f2c:	b002      	add	sp, #8
 8007f2e:	4770      	bx	lr

08007f30 <port_unlock.lto_priv.270>:
static inline void port_unlock(void) {
 8007f30:	b082      	sub	sp, #8
 8007f32:	2300      	movs	r3, #0
 8007f34:	9301      	str	r3, [sp, #4]
 8007f36:	9b01      	ldr	r3, [sp, #4]
 8007f38:	f383 8811 	msr	BASEPRI, r3
}
 8007f3c:	b002      	add	sp, #8
 8007f3e:	4770      	bx	lr

08007f40 <chSysLock.lto_priv.419>:
static inline void chSysLock(void) {
 8007f40:	b508      	push	{r3, lr}
  port_lock();
 8007f42:	f7ff ffed 	bl	8007f20 <port_lock.lto_priv.311>
  _dbg_check_lock();
 8007f46:	f7fe fa73 	bl	8006430 <_dbg_check_lock>
}
 8007f4a:	bd08      	pop	{r3, pc}
 8007f4c:	0000      	movs	r0, r0
	...

08007f50 <chSysUnlock.lto_priv.386>:
static inline void chSysUnlock(void) {
 8007f50:	b508      	push	{r3, lr}
  _dbg_check_unlock();
 8007f52:	f7fe fa85 	bl	8006460 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8007f56:	4b09      	ldr	r3, [pc, #36]	; (8007f7c <chSysUnlock.lto_priv.386+0x2c>)
 8007f58:	681b      	ldr	r3, [r3, #0]
 8007f5a:	4a08      	ldr	r2, [pc, #32]	; (8007f7c <chSysUnlock.lto_priv.386+0x2c>)
 8007f5c:	4293      	cmp	r3, r2
 8007f5e:	d00a      	beq.n	8007f76 <chSysUnlock.lto_priv.386+0x26>
 8007f60:	4b06      	ldr	r3, [pc, #24]	; (8007f7c <chSysUnlock.lto_priv.386+0x2c>)
 8007f62:	699b      	ldr	r3, [r3, #24]
 8007f64:	689a      	ldr	r2, [r3, #8]
 8007f66:	4b05      	ldr	r3, [pc, #20]	; (8007f7c <chSysUnlock.lto_priv.386+0x2c>)
 8007f68:	681b      	ldr	r3, [r3, #0]
 8007f6a:	689b      	ldr	r3, [r3, #8]
 8007f6c:	429a      	cmp	r2, r3
 8007f6e:	d202      	bcs.n	8007f76 <chSysUnlock.lto_priv.386+0x26>
 8007f70:	4803      	ldr	r0, [pc, #12]	; (8007f80 <chSysUnlock.lto_priv.386+0x30>)
 8007f72:	f7fe f9dd 	bl	8006330 <chSysHalt>
  port_unlock();
 8007f76:	f7ff ffdb 	bl	8007f30 <port_unlock.lto_priv.270>
}
 8007f7a:	bd08      	pop	{r3, pc}
 8007f7c:	20000b38 	.word	0x20000b38
 8007f80:	080097ac 	.word	0x080097ac
	...

08007f90 <_core_init>:
#if CH_CFG_MEMCORE_SIZE == 0
  extern uint8_t __heap_base__[];
  extern uint8_t __heap_end__[];

  /*lint -save -e9033 [10.8] Required cast operations.*/
  ch_memcore.nextmem = __heap_base__;
 8007f90:	4b03      	ldr	r3, [pc, #12]	; (8007fa0 <_core_init+0x10>)
 8007f92:	4a04      	ldr	r2, [pc, #16]	; (8007fa4 <_core_init+0x14>)
 8007f94:	601a      	str	r2, [r3, #0]
  ch_memcore.endmem  = __heap_end__;
 8007f96:	4b02      	ldr	r3, [pc, #8]	; (8007fa0 <_core_init+0x10>)
 8007f98:	4a03      	ldr	r2, [pc, #12]	; (8007fa8 <_core_init+0x18>)
 8007f9a:	605a      	str	r2, [r3, #4]
  static uint8_t static_heap[CH_CFG_MEMCORE_SIZE];

  ch_memcore.nextmem = &static_heap[0];
  ch_memcore.endmem  = &static_heap[CH_CFG_MEMCORE_SIZE];
#endif
}
 8007f9c:	4770      	bx	lr
 8007f9e:	bf00      	nop
 8007fa0:	200013c0 	.word	0x200013c0
 8007fa4:	20002560 	.word	0x20002560
 8007fa8:	20020000 	.word	0x20020000
 8007fac:	00000000 	.word	0x00000000

08007fb0 <chCoreAllocAlignedWithOffsetI>:
 *
 * @iclass
 */
void *chCoreAllocAlignedWithOffsetI(size_t size,
                                    unsigned align,
                                    size_t offset) {
 8007fb0:	b500      	push	{lr}
 8007fb2:	b087      	sub	sp, #28
 8007fb4:	9003      	str	r0, [sp, #12]
 8007fb6:	9102      	str	r1, [sp, #8]
 8007fb8:	9201      	str	r2, [sp, #4]
  uint8_t *p, *next;

  chDbgCheckClassI();
 8007fba:	f7fe fad9 	bl	8006570 <chDbgCheckClassI>
  chDbgCheck(MEM_IS_VALID_ALIGNMENT(align));
 8007fbe:	9b02      	ldr	r3, [sp, #8]
 8007fc0:	2b00      	cmp	r3, #0
 8007fc2:	d005      	beq.n	8007fd0 <chCoreAllocAlignedWithOffsetI+0x20>
 8007fc4:	9b02      	ldr	r3, [sp, #8]
 8007fc6:	1e5a      	subs	r2, r3, #1
 8007fc8:	9b02      	ldr	r3, [sp, #8]
 8007fca:	4013      	ands	r3, r2
 8007fcc:	2b00      	cmp	r3, #0
 8007fce:	d002      	beq.n	8007fd6 <chCoreAllocAlignedWithOffsetI+0x26>
 8007fd0:	4817      	ldr	r0, [pc, #92]	; (8008030 <chCoreAllocAlignedWithOffsetI+0x80>)
 8007fd2:	f7fe f9ad 	bl	8006330 <chSysHalt>

  size = MEM_ALIGN_NEXT(size, align);
 8007fd6:	9a02      	ldr	r2, [sp, #8]
 8007fd8:	9b03      	ldr	r3, [sp, #12]
 8007fda:	4413      	add	r3, r2
 8007fdc:	1e5a      	subs	r2, r3, #1
 8007fde:	9b02      	ldr	r3, [sp, #8]
 8007fe0:	425b      	negs	r3, r3
 8007fe2:	4013      	ands	r3, r2
 8007fe4:	9303      	str	r3, [sp, #12]
  p = (uint8_t *)MEM_ALIGN_NEXT(ch_memcore.nextmem + offset, align);
 8007fe6:	4b13      	ldr	r3, [pc, #76]	; (8008034 <chCoreAllocAlignedWithOffsetI+0x84>)
 8007fe8:	681a      	ldr	r2, [r3, #0]
 8007fea:	9b01      	ldr	r3, [sp, #4]
 8007fec:	4413      	add	r3, r2
 8007fee:	461a      	mov	r2, r3
 8007ff0:	9b02      	ldr	r3, [sp, #8]
 8007ff2:	4413      	add	r3, r2
 8007ff4:	1e5a      	subs	r2, r3, #1
 8007ff6:	9b02      	ldr	r3, [sp, #8]
 8007ff8:	425b      	negs	r3, r3
 8007ffa:	4013      	ands	r3, r2
 8007ffc:	9305      	str	r3, [sp, #20]
  next = p + size;
 8007ffe:	9a05      	ldr	r2, [sp, #20]
 8008000:	9b03      	ldr	r3, [sp, #12]
 8008002:	4413      	add	r3, r2
 8008004:	9304      	str	r3, [sp, #16]

  /* Considering also the case where there is numeric overflow.*/
  if ((next > ch_memcore.endmem) || (next < ch_memcore.nextmem)) {
 8008006:	4b0b      	ldr	r3, [pc, #44]	; (8008034 <chCoreAllocAlignedWithOffsetI+0x84>)
 8008008:	685b      	ldr	r3, [r3, #4]
 800800a:	9a04      	ldr	r2, [sp, #16]
 800800c:	429a      	cmp	r2, r3
 800800e:	d804      	bhi.n	800801a <chCoreAllocAlignedWithOffsetI+0x6a>
 8008010:	4b08      	ldr	r3, [pc, #32]	; (8008034 <chCoreAllocAlignedWithOffsetI+0x84>)
 8008012:	681b      	ldr	r3, [r3, #0]
 8008014:	9a04      	ldr	r2, [sp, #16]
 8008016:	429a      	cmp	r2, r3
 8008018:	d201      	bcs.n	800801e <chCoreAllocAlignedWithOffsetI+0x6e>
    return NULL;
 800801a:	2300      	movs	r3, #0
 800801c:	e003      	b.n	8008026 <chCoreAllocAlignedWithOffsetI+0x76>
  }

  ch_memcore.nextmem = next;
 800801e:	4a05      	ldr	r2, [pc, #20]	; (8008034 <chCoreAllocAlignedWithOffsetI+0x84>)
 8008020:	9b04      	ldr	r3, [sp, #16]
 8008022:	6013      	str	r3, [r2, #0]

  return p;
 8008024:	9b05      	ldr	r3, [sp, #20]
}
 8008026:	4618      	mov	r0, r3
 8008028:	b007      	add	sp, #28
 800802a:	f85d fb04 	ldr.w	pc, [sp], #4
 800802e:	bf00      	nop
 8008030:	0800978c 	.word	0x0800978c
 8008034:	200013c0 	.word	0x200013c0
	...

08008040 <chCoreAllocAlignedWithOffset>:
 *
 * @api
 */
void *chCoreAllocAlignedWithOffset(size_t size,
                                   unsigned align,
                                   size_t offset) {
 8008040:	b500      	push	{lr}
 8008042:	b087      	sub	sp, #28
 8008044:	9003      	str	r0, [sp, #12]
 8008046:	9102      	str	r1, [sp, #8]
 8008048:	9201      	str	r2, [sp, #4]
  void *p;

  chSysLock();
 800804a:	f7ff ff79 	bl	8007f40 <chSysLock.lto_priv.419>
  p = chCoreAllocAlignedWithOffsetI(size, align, offset);
 800804e:	9a01      	ldr	r2, [sp, #4]
 8008050:	9902      	ldr	r1, [sp, #8]
 8008052:	9803      	ldr	r0, [sp, #12]
 8008054:	f7ff ffac 	bl	8007fb0 <chCoreAllocAlignedWithOffsetI>
 8008058:	9005      	str	r0, [sp, #20]
  chSysUnlock();
 800805a:	f7ff ff79 	bl	8007f50 <chSysUnlock.lto_priv.386>

  return p;
 800805e:	9b05      	ldr	r3, [sp, #20]
}
 8008060:	4618      	mov	r0, r3
 8008062:	b007      	add	sp, #28
 8008064:	f85d fb04 	ldr.w	pc, [sp], #4
	...

08008070 <_heap_init>:
/**
 * @brief   Initializes the default heap.
 *
 * @notapi
 */
void _heap_init(void) {
 8008070:	b508      	push	{r3, lr}

  default_heap.provider = chCoreAllocAlignedWithOffset;
 8008072:	4b06      	ldr	r3, [pc, #24]	; (800808c <_heap_init+0x1c>)
 8008074:	4a06      	ldr	r2, [pc, #24]	; (8008090 <_heap_init+0x20>)
 8008076:	601a      	str	r2, [r3, #0]
  H_NEXT(&default_heap.header) = NULL;
 8008078:	4b04      	ldr	r3, [pc, #16]	; (800808c <_heap_init+0x1c>)
 800807a:	2200      	movs	r2, #0
 800807c:	605a      	str	r2, [r3, #4]
  H_PAGES(&default_heap.header) = 0;
 800807e:	4b03      	ldr	r3, [pc, #12]	; (800808c <_heap_init+0x1c>)
 8008080:	2200      	movs	r2, #0
 8008082:	609a      	str	r2, [r3, #8]
#if (CH_CFG_USE_MUTEXES == TRUE) || defined(__DOXYGEN__)
  chMtxObjectInit(&default_heap.mtx);
 8008084:	4803      	ldr	r0, [pc, #12]	; (8008094 <_heap_init+0x24>)
 8008086:	f7ff fdbb 	bl	8007c00 <chMtxObjectInit>
#else
  chSemObjectInit(&default_heap.sem, (cnt_t)1);
#endif
}
 800808a:	bd08      	pop	{r3, pc}
 800808c:	200013c8 	.word	0x200013c8
 8008090:	08008041 	.word	0x08008041
 8008094:	200013d4 	.word	0x200013d4
	...

080080a0 <chHeapFree>:
 *
 * @param[in] p         pointer to the memory block to be freed
 *
 * @api
 */
void chHeapFree(void *p) {
 80080a0:	b500      	push	{lr}
 80080a2:	b087      	sub	sp, #28
 80080a4:	9001      	str	r0, [sp, #4]
  heap_header_t *qp, *hp;
  memory_heap_t *heapp;

  chDbgCheck((p != NULL) && MEM_IS_ALIGNED(p, CH_HEAP_ALIGNMENT));
 80080a6:	9b01      	ldr	r3, [sp, #4]
 80080a8:	2b00      	cmp	r3, #0
 80080aa:	d004      	beq.n	80080b6 <chHeapFree+0x16>
 80080ac:	9b01      	ldr	r3, [sp, #4]
 80080ae:	f003 0307 	and.w	r3, r3, #7
 80080b2:	2b00      	cmp	r3, #0
 80080b4:	d002      	beq.n	80080bc <chHeapFree+0x1c>
 80080b6:	483d      	ldr	r0, [pc, #244]	; (80081ac <chHeapFree+0x10c>)
 80080b8:	f7fe f93a 	bl	8006330 <chSysHalt>

  /*lint -save -e9087 [11.3] Safe cast.*/
  hp = (heap_header_t *)p - 1U;
 80080bc:	9b01      	ldr	r3, [sp, #4]
 80080be:	3b08      	subs	r3, #8
 80080c0:	9304      	str	r3, [sp, #16]
  /*lint -restore*/
  heapp = H_HEAP(hp);
 80080c2:	9b04      	ldr	r3, [sp, #16]
 80080c4:	681b      	ldr	r3, [r3, #0]
 80080c6:	9303      	str	r3, [sp, #12]
  qp = &heapp->header;
 80080c8:	9b03      	ldr	r3, [sp, #12]
 80080ca:	3304      	adds	r3, #4
 80080cc:	9305      	str	r3, [sp, #20]

  /* Size is converted in number of elementary allocation units.*/
  H_PAGES(hp) = MEM_ALIGN_NEXT(H_SIZE(hp),
 80080ce:	9b04      	ldr	r3, [sp, #16]
 80080d0:	685b      	ldr	r3, [r3, #4]
 80080d2:	3307      	adds	r3, #7
                               CH_HEAP_ALIGNMENT) / CH_HEAP_ALIGNMENT;
 80080d4:	08da      	lsrs	r2, r3, #3
  H_PAGES(hp) = MEM_ALIGN_NEXT(H_SIZE(hp),
 80080d6:	9b04      	ldr	r3, [sp, #16]
 80080d8:	605a      	str	r2, [r3, #4]

  /* Taking heap mutex/semaphore.*/
  H_LOCK(heapp);
 80080da:	9b03      	ldr	r3, [sp, #12]
 80080dc:	330c      	adds	r3, #12
 80080de:	4618      	mov	r0, r3
 80080e0:	f7ff fda6 	bl	8007c30 <chMtxLock>

  while (true) {
    chDbgAssert((hp < qp) || (hp >= H_LIMIT(qp)), "within free block");
 80080e4:	9a04      	ldr	r2, [sp, #16]
 80080e6:	9b05      	ldr	r3, [sp, #20]
 80080e8:	429a      	cmp	r2, r3
 80080ea:	d30b      	bcc.n	8008104 <chHeapFree+0x64>
 80080ec:	9b05      	ldr	r3, [sp, #20]
 80080ee:	685b      	ldr	r3, [r3, #4]
 80080f0:	3301      	adds	r3, #1
 80080f2:	00db      	lsls	r3, r3, #3
 80080f4:	9a05      	ldr	r2, [sp, #20]
 80080f6:	4413      	add	r3, r2
 80080f8:	9a04      	ldr	r2, [sp, #16]
 80080fa:	429a      	cmp	r2, r3
 80080fc:	d202      	bcs.n	8008104 <chHeapFree+0x64>
 80080fe:	482b      	ldr	r0, [pc, #172]	; (80081ac <chHeapFree+0x10c>)
 8008100:	f7fe f916 	bl	8006330 <chSysHalt>

    if (((qp == &heapp->header) || (hp > qp)) &&
 8008104:	9b03      	ldr	r3, [sp, #12]
 8008106:	3304      	adds	r3, #4
 8008108:	9a05      	ldr	r2, [sp, #20]
 800810a:	429a      	cmp	r2, r3
 800810c:	d003      	beq.n	8008116 <chHeapFree+0x76>
 800810e:	9a04      	ldr	r2, [sp, #16]
 8008110:	9b05      	ldr	r3, [sp, #20]
 8008112:	429a      	cmp	r2, r3
 8008114:	d942      	bls.n	800819c <chHeapFree+0xfc>
        ((H_NEXT(qp) == NULL) || (hp < H_NEXT(qp)))) {
 8008116:	9b05      	ldr	r3, [sp, #20]
 8008118:	681b      	ldr	r3, [r3, #0]
    if (((qp == &heapp->header) || (hp > qp)) &&
 800811a:	2b00      	cmp	r3, #0
 800811c:	d004      	beq.n	8008128 <chHeapFree+0x88>
        ((H_NEXT(qp) == NULL) || (hp < H_NEXT(qp)))) {
 800811e:	9b05      	ldr	r3, [sp, #20]
 8008120:	681b      	ldr	r3, [r3, #0]
 8008122:	9a04      	ldr	r2, [sp, #16]
 8008124:	429a      	cmp	r2, r3
 8008126:	d239      	bcs.n	800819c <chHeapFree+0xfc>
      /* Insertion after qp.*/
      H_NEXT(hp) = H_NEXT(qp);
 8008128:	9b05      	ldr	r3, [sp, #20]
 800812a:	681a      	ldr	r2, [r3, #0]
 800812c:	9b04      	ldr	r3, [sp, #16]
 800812e:	601a      	str	r2, [r3, #0]
      H_NEXT(qp) = hp;
 8008130:	9b05      	ldr	r3, [sp, #20]
 8008132:	9a04      	ldr	r2, [sp, #16]
 8008134:	601a      	str	r2, [r3, #0]
      /* Verifies if the newly inserted block should be merged.*/
      if (H_LIMIT(hp) == H_NEXT(hp)) {
 8008136:	9b04      	ldr	r3, [sp, #16]
 8008138:	685b      	ldr	r3, [r3, #4]
 800813a:	3301      	adds	r3, #1
 800813c:	00db      	lsls	r3, r3, #3
 800813e:	9a04      	ldr	r2, [sp, #16]
 8008140:	441a      	add	r2, r3
 8008142:	9b04      	ldr	r3, [sp, #16]
 8008144:	681b      	ldr	r3, [r3, #0]
 8008146:	429a      	cmp	r2, r3
 8008148:	d10d      	bne.n	8008166 <chHeapFree+0xc6>
        /* Merge with the next block.*/
        H_PAGES(hp) += H_PAGES(H_NEXT(hp)) + 1U;
 800814a:	9b04      	ldr	r3, [sp, #16]
 800814c:	685a      	ldr	r2, [r3, #4]
 800814e:	9b04      	ldr	r3, [sp, #16]
 8008150:	681b      	ldr	r3, [r3, #0]
 8008152:	685b      	ldr	r3, [r3, #4]
 8008154:	4413      	add	r3, r2
 8008156:	1c5a      	adds	r2, r3, #1
 8008158:	9b04      	ldr	r3, [sp, #16]
 800815a:	605a      	str	r2, [r3, #4]
        H_NEXT(hp) = H_NEXT(H_NEXT(hp));
 800815c:	9b04      	ldr	r3, [sp, #16]
 800815e:	681b      	ldr	r3, [r3, #0]
 8008160:	681a      	ldr	r2, [r3, #0]
 8008162:	9b04      	ldr	r3, [sp, #16]
 8008164:	601a      	str	r2, [r3, #0]
      }
      if ((H_LIMIT(qp) == hp)) {
 8008166:	9b05      	ldr	r3, [sp, #20]
 8008168:	685b      	ldr	r3, [r3, #4]
 800816a:	3301      	adds	r3, #1
 800816c:	00db      	lsls	r3, r3, #3
 800816e:	9a05      	ldr	r2, [sp, #20]
 8008170:	4413      	add	r3, r2
 8008172:	9a04      	ldr	r2, [sp, #16]
 8008174:	429a      	cmp	r2, r3
 8008176:	d10b      	bne.n	8008190 <chHeapFree+0xf0>
        /* Merge with the previous block.*/
        H_PAGES(qp) += H_PAGES(hp) + 1U;
 8008178:	9b05      	ldr	r3, [sp, #20]
 800817a:	685a      	ldr	r2, [r3, #4]
 800817c:	9b04      	ldr	r3, [sp, #16]
 800817e:	685b      	ldr	r3, [r3, #4]
 8008180:	4413      	add	r3, r2
 8008182:	1c5a      	adds	r2, r3, #1
 8008184:	9b05      	ldr	r3, [sp, #20]
 8008186:	605a      	str	r2, [r3, #4]
        H_NEXT(qp) = H_NEXT(hp);
 8008188:	9b04      	ldr	r3, [sp, #16]
 800818a:	681a      	ldr	r2, [r3, #0]
 800818c:	9b05      	ldr	r3, [sp, #20]
 800818e:	601a      	str	r2, [r3, #0]
    }
    qp = H_NEXT(qp);
  }

  /* Releasing heap mutex/semaphore.*/
  H_UNLOCK(heapp);
 8008190:	9b03      	ldr	r3, [sp, #12]
 8008192:	330c      	adds	r3, #12
 8008194:	4618      	mov	r0, r3
 8008196:	f7ff fddb 	bl	8007d50 <chMtxUnlock>
 800819a:	e003      	b.n	80081a4 <chHeapFree+0x104>
    qp = H_NEXT(qp);
 800819c:	9b05      	ldr	r3, [sp, #20]
 800819e:	681b      	ldr	r3, [r3, #0]
 80081a0:	9305      	str	r3, [sp, #20]
 80081a2:	e79f      	b.n	80080e4 <chHeapFree+0x44>

  return;
}
 80081a4:	b007      	add	sp, #28
 80081a6:	f85d fb04 	ldr.w	pc, [sp], #4
 80081aa:	bf00      	nop
 80081ac:	080097b8 	.word	0x080097b8

080081b0 <port_lock.lto_priv.312>:
static inline void port_lock(void) {
 80081b0:	b082      	sub	sp, #8
 80081b2:	2320      	movs	r3, #32
 80081b4:	9301      	str	r3, [sp, #4]
 80081b6:	9b01      	ldr	r3, [sp, #4]
 80081b8:	f383 8811 	msr	BASEPRI, r3
}
 80081bc:	b002      	add	sp, #8
 80081be:	4770      	bx	lr

080081c0 <port_unlock.lto_priv.271>:
static inline void port_unlock(void) {
 80081c0:	b082      	sub	sp, #8
 80081c2:	2300      	movs	r3, #0
 80081c4:	9301      	str	r3, [sp, #4]
 80081c6:	9b01      	ldr	r3, [sp, #4]
 80081c8:	f383 8811 	msr	BASEPRI, r3
}
 80081cc:	b002      	add	sp, #8
 80081ce:	4770      	bx	lr

080081d0 <chSysLock.lto_priv.420>:
static inline void chSysLock(void) {
 80081d0:	b508      	push	{r3, lr}
  port_lock();
 80081d2:	f7ff ffed 	bl	80081b0 <port_lock.lto_priv.312>
  _dbg_check_lock();
 80081d6:	f7fe f92b 	bl	8006430 <_dbg_check_lock>
}
 80081da:	bd08      	pop	{r3, pc}
 80081dc:	0000      	movs	r0, r0
	...

080081e0 <chSysUnlock.lto_priv.387>:
static inline void chSysUnlock(void) {
 80081e0:	b508      	push	{r3, lr}
  _dbg_check_unlock();
 80081e2:	f7fe f93d 	bl	8006460 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 80081e6:	4b09      	ldr	r3, [pc, #36]	; (800820c <chSysUnlock.lto_priv.387+0x2c>)
 80081e8:	681b      	ldr	r3, [r3, #0]
 80081ea:	4a08      	ldr	r2, [pc, #32]	; (800820c <chSysUnlock.lto_priv.387+0x2c>)
 80081ec:	4293      	cmp	r3, r2
 80081ee:	d00a      	beq.n	8008206 <chSysUnlock.lto_priv.387+0x26>
 80081f0:	4b06      	ldr	r3, [pc, #24]	; (800820c <chSysUnlock.lto_priv.387+0x2c>)
 80081f2:	699b      	ldr	r3, [r3, #24]
 80081f4:	689a      	ldr	r2, [r3, #8]
 80081f6:	4b05      	ldr	r3, [pc, #20]	; (800820c <chSysUnlock.lto_priv.387+0x2c>)
 80081f8:	681b      	ldr	r3, [r3, #0]
 80081fa:	689b      	ldr	r3, [r3, #8]
 80081fc:	429a      	cmp	r2, r3
 80081fe:	d202      	bcs.n	8008206 <chSysUnlock.lto_priv.387+0x26>
 8008200:	4803      	ldr	r0, [pc, #12]	; (8008210 <chSysUnlock.lto_priv.387+0x30>)
 8008202:	f7fe f895 	bl	8006330 <chSysHalt>
  port_unlock();
 8008206:	f7ff ffdb 	bl	80081c0 <port_unlock.lto_priv.271>
}
 800820a:	bd08      	pop	{r3, pc}
 800820c:	20000b38 	.word	0x20000b38
 8008210:	080097dc 	.word	0x080097dc
	...

08008220 <chPoolObjectInitAligned>:
 *                      automatically
 *
 * @init
 */
void chPoolObjectInitAligned(memory_pool_t *mp, size_t size,
                             unsigned align, memgetfunc_t provider) {
 8008220:	b500      	push	{lr}
 8008222:	b085      	sub	sp, #20
 8008224:	9003      	str	r0, [sp, #12]
 8008226:	9102      	str	r1, [sp, #8]
 8008228:	9201      	str	r2, [sp, #4]
 800822a:	9300      	str	r3, [sp, #0]

  chDbgCheck((mp != NULL) &&
 800822c:	9b03      	ldr	r3, [sp, #12]
 800822e:	2b00      	cmp	r3, #0
 8008230:	d00e      	beq.n	8008250 <chPoolObjectInitAligned+0x30>
 8008232:	9b02      	ldr	r3, [sp, #8]
 8008234:	2b03      	cmp	r3, #3
 8008236:	d90b      	bls.n	8008250 <chPoolObjectInitAligned+0x30>
 8008238:	9b01      	ldr	r3, [sp, #4]
 800823a:	2b03      	cmp	r3, #3
 800823c:	d908      	bls.n	8008250 <chPoolObjectInitAligned+0x30>
 800823e:	9b01      	ldr	r3, [sp, #4]
 8008240:	2b00      	cmp	r3, #0
 8008242:	d005      	beq.n	8008250 <chPoolObjectInitAligned+0x30>
 8008244:	9b01      	ldr	r3, [sp, #4]
 8008246:	1e5a      	subs	r2, r3, #1
 8008248:	9b01      	ldr	r3, [sp, #4]
 800824a:	4013      	ands	r3, r2
 800824c:	2b00      	cmp	r3, #0
 800824e:	d002      	beq.n	8008256 <chPoolObjectInitAligned+0x36>
 8008250:	4808      	ldr	r0, [pc, #32]	; (8008274 <chPoolObjectInitAligned+0x54>)
 8008252:	f7fe f86d 	bl	8006330 <chSysHalt>
             (size >= sizeof(void *)) &&
             (align >= PORT_NATURAL_ALIGN) &&
             MEM_IS_VALID_ALIGNMENT(align));

  mp->next = NULL;
 8008256:	9b03      	ldr	r3, [sp, #12]
 8008258:	2200      	movs	r2, #0
 800825a:	601a      	str	r2, [r3, #0]
  mp->object_size = size;
 800825c:	9b03      	ldr	r3, [sp, #12]
 800825e:	9a02      	ldr	r2, [sp, #8]
 8008260:	605a      	str	r2, [r3, #4]
  mp->align = align;
 8008262:	9b03      	ldr	r3, [sp, #12]
 8008264:	9a01      	ldr	r2, [sp, #4]
 8008266:	609a      	str	r2, [r3, #8]
  mp->provider = provider;
 8008268:	9b03      	ldr	r3, [sp, #12]
 800826a:	9a00      	ldr	r2, [sp, #0]
 800826c:	60da      	str	r2, [r3, #12]
}
 800826e:	b005      	add	sp, #20
 8008270:	f85d fb04 	ldr.w	pc, [sp], #4
 8008274:	080097c4 	.word	0x080097c4
	...

08008280 <chPoolFreeI>:
 * @param[in] mp        pointer to a @p memory_pool_t structure
 * @param[in] objp      the pointer to the object to be released
 *
 * @iclass
 */
void chPoolFreeI(memory_pool_t *mp, void *objp) {
 8008280:	b500      	push	{lr}
 8008282:	b085      	sub	sp, #20
 8008284:	9001      	str	r0, [sp, #4]
 8008286:	9100      	str	r1, [sp, #0]
  struct pool_header *php = objp;
 8008288:	9b00      	ldr	r3, [sp, #0]
 800828a:	9303      	str	r3, [sp, #12]

  chDbgCheckClassI();
 800828c:	f7fe f970 	bl	8006570 <chDbgCheckClassI>
  chDbgCheck((mp != NULL) &&
 8008290:	9b01      	ldr	r3, [sp, #4]
 8008292:	2b00      	cmp	r3, #0
 8008294:	d009      	beq.n	80082aa <chPoolFreeI+0x2a>
 8008296:	9b00      	ldr	r3, [sp, #0]
 8008298:	2b00      	cmp	r3, #0
 800829a:	d006      	beq.n	80082aa <chPoolFreeI+0x2a>
 800829c:	9b01      	ldr	r3, [sp, #4]
 800829e:	689b      	ldr	r3, [r3, #8]
 80082a0:	1e5a      	subs	r2, r3, #1
 80082a2:	9b00      	ldr	r3, [sp, #0]
 80082a4:	4013      	ands	r3, r2
 80082a6:	2b00      	cmp	r3, #0
 80082a8:	d002      	beq.n	80082b0 <chPoolFreeI+0x30>
 80082aa:	4806      	ldr	r0, [pc, #24]	; (80082c4 <chPoolFreeI+0x44>)
 80082ac:	f7fe f840 	bl	8006330 <chSysHalt>
             (objp != NULL) &&
             MEM_IS_ALIGNED(objp, mp->align));

  php->next = mp->next;
 80082b0:	9b01      	ldr	r3, [sp, #4]
 80082b2:	681a      	ldr	r2, [r3, #0]
 80082b4:	9b03      	ldr	r3, [sp, #12]
 80082b6:	601a      	str	r2, [r3, #0]
  mp->next = php;
 80082b8:	9b01      	ldr	r3, [sp, #4]
 80082ba:	9a03      	ldr	r2, [sp, #12]
 80082bc:	601a      	str	r2, [r3, #0]
}
 80082be:	b005      	add	sp, #20
 80082c0:	f85d fb04 	ldr.w	pc, [sp], #4
 80082c4:	080097e8 	.word	0x080097e8
	...

080082d0 <chPoolFree>:
 * @param[in] mp        pointer to a @p memory_pool_t structure
 * @param[in] objp      the pointer to the object to be released
 *
 * @api
 */
void chPoolFree(memory_pool_t *mp, void *objp) {
 80082d0:	b500      	push	{lr}
 80082d2:	b083      	sub	sp, #12
 80082d4:	9001      	str	r0, [sp, #4]
 80082d6:	9100      	str	r1, [sp, #0]

  chSysLock();
 80082d8:	f7ff ff7a 	bl	80081d0 <chSysLock.lto_priv.420>
  chPoolFreeI(mp, objp);
 80082dc:	9900      	ldr	r1, [sp, #0]
 80082de:	9801      	ldr	r0, [sp, #4]
 80082e0:	f7ff ffce 	bl	8008280 <chPoolFreeI>
  chSysUnlock();
 80082e4:	f7ff ff7c 	bl	80081e0 <chSysUnlock.lto_priv.387>
}
 80082e8:	b003      	add	sp, #12
 80082ea:	f85d fb04 	ldr.w	pc, [sp], #4
 80082ee:	bf00      	nop

080082f0 <chCoreAllocAlignedI>:
 * @return              A pointer to the allocated memory block.
 * @retval NULL         allocation failed, core memory exhausted.
 *
 * @iclass
 */
static inline void *chCoreAllocAlignedI(size_t size, unsigned align) {
 80082f0:	b500      	push	{lr}
 80082f2:	b083      	sub	sp, #12
 80082f4:	9001      	str	r0, [sp, #4]
 80082f6:	9100      	str	r1, [sp, #0]

  return chCoreAllocAlignedWithOffsetI(size, align, 0U);
 80082f8:	2200      	movs	r2, #0
 80082fa:	9900      	ldr	r1, [sp, #0]
 80082fc:	9801      	ldr	r0, [sp, #4]
 80082fe:	f7ff fe57 	bl	8007fb0 <chCoreAllocAlignedWithOffsetI>
 8008302:	4603      	mov	r3, r0
}
 8008304:	4618      	mov	r0, r3
 8008306:	b003      	add	sp, #12
 8008308:	f85d fb04 	ldr.w	pc, [sp], #4
 800830c:	0000      	movs	r0, r0
	...

08008310 <chPoolObjectInit.lto_priv.467>:
 *
 * @init
 */
static inline void chPoolObjectInit(memory_pool_t *mp,
                                    size_t size,
                                    memgetfunc_t provider) {
 8008310:	b500      	push	{lr}
 8008312:	b085      	sub	sp, #20
 8008314:	9003      	str	r0, [sp, #12]
 8008316:	9102      	str	r1, [sp, #8]
 8008318:	9201      	str	r2, [sp, #4]

  chPoolObjectInitAligned(mp, size, PORT_NATURAL_ALIGN, provider);
 800831a:	9b01      	ldr	r3, [sp, #4]
 800831c:	2204      	movs	r2, #4
 800831e:	9902      	ldr	r1, [sp, #8]
 8008320:	9803      	ldr	r0, [sp, #12]
 8008322:	f7ff ff7d 	bl	8008220 <chPoolObjectInitAligned>
}
 8008326:	b005      	add	sp, #20
 8008328:	f85d fb04 	ldr.w	pc, [sp], #4
 800832c:	0000      	movs	r0, r0
	...

08008330 <dyn_list_init>:

/*===========================================================================*/
/* Module local functions.                                                   */
/*===========================================================================*/

static inline void dyn_list_init(dyn_list_t *dlp) {
 8008330:	b082      	sub	sp, #8
 8008332:	9001      	str	r0, [sp, #4]

  dlp->next = (dyn_element_t *)dlp;
 8008334:	9b01      	ldr	r3, [sp, #4]
 8008336:	9a01      	ldr	r2, [sp, #4]
 8008338:	601a      	str	r2, [r3, #0]
}
 800833a:	b002      	add	sp, #8
 800833c:	4770      	bx	lr
 800833e:	bf00      	nop

08008340 <_factory_init>:
/**
 * @brief   Initializes the objects factory.
 *
 * @init
 */
void _factory_init(void) {
 8008340:	b508      	push	{r3, lr}

#if (CH_CFG_USE_MUTEXES == TRUE) || defined(__DOXYGEN__)
  chMtxObjectInit(&ch_factory.mtx);
 8008342:	4810      	ldr	r0, [pc, #64]	; (8008384 <_factory_init+0x44>)
 8008344:	f7ff fc5c 	bl	8007c00 <chMtxObjectInit>
#else
  chSemObjectInit(&ch_factory.sem, (cnt_t)1);
#endif

#if CH_CFG_FACTORY_OBJECTS_REGISTRY == TRUE
  dyn_list_init(&ch_factory.obj_list);
 8008348:	480f      	ldr	r0, [pc, #60]	; (8008388 <_factory_init+0x48>)
 800834a:	f7ff fff1 	bl	8008330 <dyn_list_init>
  chPoolObjectInit(&ch_factory.obj_pool,
 800834e:	4a0f      	ldr	r2, [pc, #60]	; (800838c <_factory_init+0x4c>)
 8008350:	2114      	movs	r1, #20
 8008352:	480f      	ldr	r0, [pc, #60]	; (8008390 <_factory_init+0x50>)
 8008354:	f7ff ffdc 	bl	8008310 <chPoolObjectInit.lto_priv.467>
                   sizeof (registered_object_t),
                   chCoreAllocAlignedI);
#endif
#if CH_CFG_FACTORY_GENERIC_BUFFERS == TRUE
  dyn_list_init(&ch_factory.buf_list);
 8008358:	480e      	ldr	r0, [pc, #56]	; (8008394 <_factory_init+0x54>)
 800835a:	f7ff ffe9 	bl	8008330 <dyn_list_init>
#endif
#if CH_CFG_FACTORY_SEMAPHORES == TRUE
  dyn_list_init(&ch_factory.sem_list);
 800835e:	480e      	ldr	r0, [pc, #56]	; (8008398 <_factory_init+0x58>)
 8008360:	f7ff ffe6 	bl	8008330 <dyn_list_init>
  chPoolObjectInit(&ch_factory.sem_pool,
 8008364:	4a09      	ldr	r2, [pc, #36]	; (800838c <_factory_init+0x4c>)
 8008366:	211c      	movs	r1, #28
 8008368:	480c      	ldr	r0, [pc, #48]	; (800839c <_factory_init+0x5c>)
 800836a:	f7ff ffd1 	bl	8008310 <chPoolObjectInit.lto_priv.467>
                   sizeof (dyn_semaphore_t),
                   chCoreAllocAlignedI);
#endif
#if CH_CFG_FACTORY_MAILBOXES == TRUE
  dyn_list_init(&ch_factory.mbx_list);
 800836e:	480c      	ldr	r0, [pc, #48]	; (80083a0 <_factory_init+0x60>)
 8008370:	f7ff ffde 	bl	8008330 <dyn_list_init>
#endif
#if CH_CFG_FACTORY_OBJ_FIFOS == TRUE
  dyn_list_init(&ch_factory.fifo_list);
 8008374:	480b      	ldr	r0, [pc, #44]	; (80083a4 <_factory_init+0x64>)
 8008376:	f7ff ffdb 	bl	8008330 <dyn_list_init>
#endif
#if CH_CFG_FACTORY_PIPES == TRUE
  dyn_list_init(&ch_factory.pipe_list);
 800837a:	480b      	ldr	r0, [pc, #44]	; (80083a8 <_factory_init+0x68>)
 800837c:	f7ff ffd8 	bl	8008330 <dyn_list_init>
#endif
}
 8008380:	bd08      	pop	{r3, pc}
 8008382:	bf00      	nop
 8008384:	200013e4 	.word	0x200013e4
 8008388:	200013f4 	.word	0x200013f4
 800838c:	080082f1 	.word	0x080082f1
 8008390:	200013f8 	.word	0x200013f8
 8008394:	20001408 	.word	0x20001408
 8008398:	2000140c 	.word	0x2000140c
 800839c:	20001410 	.word	0x20001410
 80083a0:	20001420 	.word	0x20001420
 80083a4:	20001424 	.word	0x20001424
 80083a8:	20001428 	.word	0x20001428
 80083ac:	00000000 	.word	0x00000000

080083b0 <port_lock.lto_priv.314>:
static inline void port_lock(void) {
 80083b0:	b082      	sub	sp, #8
 80083b2:	2320      	movs	r3, #32
 80083b4:	9301      	str	r3, [sp, #4]
 80083b6:	9b01      	ldr	r3, [sp, #4]
 80083b8:	f383 8811 	msr	BASEPRI, r3
}
 80083bc:	b002      	add	sp, #8
 80083be:	4770      	bx	lr

080083c0 <port_unlock.lto_priv.273>:
static inline void port_unlock(void) {
 80083c0:	b082      	sub	sp, #8
 80083c2:	2300      	movs	r3, #0
 80083c4:	9301      	str	r3, [sp, #4]
 80083c6:	9b01      	ldr	r3, [sp, #4]
 80083c8:	f383 8811 	msr	BASEPRI, r3
}
 80083cc:	b002      	add	sp, #8
 80083ce:	4770      	bx	lr

080083d0 <port_lock_from_isr.lto_priv.556>:
static inline void port_lock_from_isr(void) {
 80083d0:	b508      	push	{r3, lr}
  port_lock();
 80083d2:	f7ff ffed 	bl	80083b0 <port_lock.lto_priv.314>
}
 80083d6:	bd08      	pop	{r3, pc}
	...

080083e0 <port_unlock_from_isr.lto_priv.544>:
static inline void port_unlock_from_isr(void) {
 80083e0:	b508      	push	{r3, lr}
  port_unlock();
 80083e2:	f7ff ffed 	bl	80083c0 <port_unlock.lto_priv.273>
}
 80083e6:	bd08      	pop	{r3, pc}
	...

080083f0 <SVC_Handler>:
 * @details The SVC vector is used for exception mode re-entering after a
 *          context switch.
 * @note    The PendSV vector is only used in advanced kernel mode.
 */
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void SVC_Handler(void) {
 80083f0:	b500      	push	{lr}
 80083f2:	b085      	sub	sp, #20
  __ASM volatile ("MRS %0, psp"  : "=r" (result) );
 80083f4:	f3ef 8309 	mrs	r3, PSP
 80083f8:	9301      	str	r3, [sp, #4]
  return(result);
 80083fa:	9b01      	ldr	r3, [sp, #4]
  /* Enforcing unstacking of the FP part of the context.*/
  FPU->FPCCR &= ~FPU_FPCCR_LSPACT_Msk;
#endif

  /* The port_extctx structure is pointed by the PSP register.*/
  ctxp = (struct port_extctx *)__get_PSP();
 80083fc:	9303      	str	r3, [sp, #12]

  /* Discarding the current exception context and positioning the stack to
     point to the real one.*/
  ctxp++;
 80083fe:	9b03      	ldr	r3, [sp, #12]
 8008400:	3320      	adds	r3, #32
 8008402:	9303      	str	r3, [sp, #12]

  /* Restoring real position of the original stack frame.*/
  __set_PSP((uint32_t)ctxp);
 8008404:	9b03      	ldr	r3, [sp, #12]
 8008406:	9302      	str	r3, [sp, #8]
  __ASM volatile ("MSR psp, %0" : : "r" (topOfProcStack) : );
 8008408:	9b02      	ldr	r3, [sp, #8]
 800840a:	f383 8809 	msr	PSP, r3

  /* Restoring the normal interrupts status.*/
  port_unlock_from_isr();
 800840e:	f7ff ffe7 	bl	80083e0 <port_unlock_from_isr.lto_priv.544>
}
 8008412:	b005      	add	sp, #20
 8008414:	f85d fb04 	ldr.w	pc, [sp], #4
	...

08008420 <_port_irq_epilogue>:
/*===========================================================================*/

/**
 * @brief   Exception exit redirection to _port_switch_from_isr().
 */
void _port_irq_epilogue(void) {
 8008420:	b500      	push	{lr}
 8008422:	b085      	sub	sp, #20

  port_lock_from_isr();
 8008424:	f7ff ffd4 	bl	80083d0 <port_lock_from_isr.lto_priv.556>
  if ((SCB->ICSR & SCB_ICSR_RETTOBASE_Msk) != 0U) {
 8008428:	4b14      	ldr	r3, [pc, #80]	; (800847c <_port_irq_epilogue+0x5c>)
 800842a:	685b      	ldr	r3, [r3, #4]
 800842c:	f403 6300 	and.w	r3, r3, #2048	; 0x800
 8008430:	2b00      	cmp	r3, #0
 8008432:	d01d      	beq.n	8008470 <_port_irq_epilogue+0x50>
  __ASM volatile ("MRS %0, psp"  : "=r" (result) );
 8008434:	f3ef 8309 	mrs	r3, PSP
 8008438:	9301      	str	r3, [sp, #4]
  return(result);
 800843a:	9b01      	ldr	r3, [sp, #4]
      /* Enforcing a lazy FPU state save by accessing the FPCSR register.*/
      (void) __get_FPSCR();
#endif

    /* The port_extctx structure is pointed by the PSP register.*/
    ctxp = (struct port_extctx *)__get_PSP();
 800843c:	9303      	str	r3, [sp, #12]

    /* Adding an artificial exception return context, there is no need to
       populate it fully.*/
    ctxp--;
 800843e:	9b03      	ldr	r3, [sp, #12]
 8008440:	3b20      	subs	r3, #32
 8008442:	9303      	str	r3, [sp, #12]

    /* Setting up a fake XPSR register value.*/
    ctxp->xpsr = (regarm_t)0x01000000;
 8008444:	9b03      	ldr	r3, [sp, #12]
 8008446:	f04f 7280 	mov.w	r2, #16777216	; 0x1000000
 800844a:	61da      	str	r2, [r3, #28]
#if CORTEX_USE_FPU == TRUE
    ctxp->fpscr = (regarm_t)FPU->FPDSCR;
#endif

    /* Writing back the modified PSP value.*/
    __set_PSP((uint32_t)ctxp);
 800844c:	9b03      	ldr	r3, [sp, #12]
 800844e:	9302      	str	r3, [sp, #8]
  __ASM volatile ("MSR psp, %0" : : "r" (topOfProcStack) : );
 8008450:	9b02      	ldr	r3, [sp, #8]
 8008452:	f383 8809 	msr	PSP, r3

    /* The exit sequence is different depending on if a preemption is
       required or not.*/
    if (chSchIsPreemptionRequired()) {
 8008456:	f7fe fdf3 	bl	8007040 <chSchIsPreemptionRequired>
 800845a:	4603      	mov	r3, r0
 800845c:	2b00      	cmp	r3, #0
 800845e:	d003      	beq.n	8008468 <_port_irq_epilogue+0x48>
      /* Preemption is required we need to enforce a context switch.*/
      ctxp->pc = (regarm_t)_port_switch_from_isr;
 8008460:	9b03      	ldr	r3, [sp, #12]
 8008462:	4a07      	ldr	r2, [pc, #28]	; (8008480 <_port_irq_epilogue+0x60>)
 8008464:	619a      	str	r2, [r3, #24]
    }
    else {
      /* Preemption not required, we just need to exit the exception
         atomically.*/
      ctxp->pc = (regarm_t)_port_exit_from_isr;
 8008466:	e005      	b.n	8008474 <_port_irq_epilogue+0x54>
 8008468:	9b03      	ldr	r3, [sp, #12]
 800846a:	4a06      	ldr	r2, [pc, #24]	; (8008484 <_port_irq_epilogue+0x64>)
 800846c:	619a      	str	r2, [r3, #24]
 800846e:	e001      	b.n	8008474 <_port_irq_epilogue+0x54>

    /* Note, returning without unlocking is intentional, this is done in
       order to keep the rest of the context switch atomic.*/
    return;
  }
  port_unlock_from_isr();
 8008470:	f7ff ffb6 	bl	80083e0 <port_unlock_from_isr.lto_priv.544>
}
 8008474:	b005      	add	sp, #20
 8008476:	f85d fb04 	ldr.w	pc, [sp], #4
 800847a:	bf00      	nop
 800847c:	e000ed00 	.word	0xe000ed00
 8008480:	080002f5 	.word	0x080002f5
 8008484:	08000300 	.word	0x08000300

08008488 <memset>:
 8008488:	b4f0      	push	{r4, r5, r6, r7}
 800848a:	0786      	lsls	r6, r0, #30
 800848c:	d043      	beq.n	8008516 <memset+0x8e>
 800848e:	1e54      	subs	r4, r2, #1
 8008490:	2a00      	cmp	r2, #0
 8008492:	d03e      	beq.n	8008512 <memset+0x8a>
 8008494:	b2ca      	uxtb	r2, r1
 8008496:	4603      	mov	r3, r0
 8008498:	e002      	b.n	80084a0 <memset+0x18>
 800849a:	f114 34ff 	adds.w	r4, r4, #4294967295
 800849e:	d338      	bcc.n	8008512 <memset+0x8a>
 80084a0:	f803 2b01 	strb.w	r2, [r3], #1
 80084a4:	079d      	lsls	r5, r3, #30
 80084a6:	d1f8      	bne.n	800849a <memset+0x12>
 80084a8:	2c03      	cmp	r4, #3
 80084aa:	d92b      	bls.n	8008504 <memset+0x7c>
 80084ac:	b2cd      	uxtb	r5, r1
 80084ae:	ea45 2505 	orr.w	r5, r5, r5, lsl #8
 80084b2:	2c0f      	cmp	r4, #15
 80084b4:	ea45 4505 	orr.w	r5, r5, r5, lsl #16
 80084b8:	d916      	bls.n	80084e8 <memset+0x60>
 80084ba:	f1a4 0710 	sub.w	r7, r4, #16
 80084be:	093f      	lsrs	r7, r7, #4
 80084c0:	f103 0620 	add.w	r6, r3, #32
 80084c4:	eb06 1607 	add.w	r6, r6, r7, lsl #4
 80084c8:	f103 0210 	add.w	r2, r3, #16
 80084cc:	e942 5504 	strd	r5, r5, [r2, #-16]
 80084d0:	e942 5502 	strd	r5, r5, [r2, #-8]
 80084d4:	3210      	adds	r2, #16
 80084d6:	42b2      	cmp	r2, r6
 80084d8:	d1f8      	bne.n	80084cc <memset+0x44>
 80084da:	f004 040f 	and.w	r4, r4, #15
 80084de:	3701      	adds	r7, #1
 80084e0:	2c03      	cmp	r4, #3
 80084e2:	eb03 1307 	add.w	r3, r3, r7, lsl #4
 80084e6:	d90d      	bls.n	8008504 <memset+0x7c>
 80084e8:	461e      	mov	r6, r3
 80084ea:	4622      	mov	r2, r4
 80084ec:	3a04      	subs	r2, #4
 80084ee:	2a03      	cmp	r2, #3
 80084f0:	f846 5b04 	str.w	r5, [r6], #4
 80084f4:	d8fa      	bhi.n	80084ec <memset+0x64>
 80084f6:	1f22      	subs	r2, r4, #4
 80084f8:	f022 0203 	bic.w	r2, r2, #3
 80084fc:	3204      	adds	r2, #4
 80084fe:	4413      	add	r3, r2
 8008500:	f004 0403 	and.w	r4, r4, #3
 8008504:	b12c      	cbz	r4, 8008512 <memset+0x8a>
 8008506:	b2c9      	uxtb	r1, r1
 8008508:	441c      	add	r4, r3
 800850a:	f803 1b01 	strb.w	r1, [r3], #1
 800850e:	429c      	cmp	r4, r3
 8008510:	d1fb      	bne.n	800850a <memset+0x82>
 8008512:	bcf0      	pop	{r4, r5, r6, r7}
 8008514:	4770      	bx	lr
 8008516:	4614      	mov	r4, r2
 8008518:	4603      	mov	r3, r0
 800851a:	e7c5      	b.n	80084a8 <memset+0x20>
